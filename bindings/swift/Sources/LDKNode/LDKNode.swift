// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import SystemConfiguration
// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(LDKNodeFFI)
    import LDKNodeFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ldk_node_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ldk_node_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol Bolt11InvoiceProtocol: AnyObject {
    func amountMilliSatoshis() -> UInt64?

    func currency() -> Currency

    func expiryTimeSeconds() -> UInt64

    func fallbackAddresses() -> [Address]

    func invoiceDescription() -> Bolt11InvoiceDescription

    func isExpired() -> Bool

    func minFinalCltvExpiryDelta() -> UInt64

    func network() -> Network

    func paymentHash() -> PaymentHash

    func paymentSecret() -> PaymentSecret

    func recoverPayeePubKey() -> PublicKey

    func routeHints() -> [[RouteHintHop]]

    func secondsSinceEpoch() -> UInt64

    func secondsUntilExpiry() -> UInt64

    func signableHash() -> [UInt8]

    func wouldExpire(atTimeSeconds: UInt64) -> Bool
}

open class Bolt11Invoice:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    Bolt11InvoiceProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11invoice(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt11invoice(pointer, $0) }
    }

    public static func fromStr(invoiceStr: String) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_constructor_bolt11invoice_from_str(
                FfiConverterString.lower(invoiceStr), $0
            )
        })
    }

    open func amountMilliSatoshis() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_amount_milli_satoshis(self.uniffiClonePointer(), $0)
        })
    }

    open func currency() -> Currency {
        return try! FfiConverterTypeCurrency.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_currency(self.uniffiClonePointer(), $0)
        })
    }

    open func expiryTimeSeconds() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_expiry_time_seconds(self.uniffiClonePointer(), $0)
        })
    }

    open func fallbackAddresses() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_fallback_addresses(self.uniffiClonePointer(), $0)
        })
    }

    open func invoiceDescription() -> Bolt11InvoiceDescription {
        return try! FfiConverterTypeBolt11InvoiceDescription.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_invoice_description(self.uniffiClonePointer(), $0)
        })
    }

    open func isExpired() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_is_expired(self.uniffiClonePointer(), $0)
        })
    }

    open func minFinalCltvExpiryDelta() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_min_final_cltv_expiry_delta(self.uniffiClonePointer(), $0)
        })
    }

    open func network() -> Network {
        return try! FfiConverterTypeNetwork.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_network(self.uniffiClonePointer(), $0)
        })
    }

    open func paymentHash() -> PaymentHash {
        return try! FfiConverterTypePaymentHash.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_payment_hash(self.uniffiClonePointer(), $0)
        })
    }

    open func paymentSecret() -> PaymentSecret {
        return try! FfiConverterTypePaymentSecret.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_payment_secret(self.uniffiClonePointer(), $0)
        })
    }

    open func recoverPayeePubKey() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_recover_payee_pub_key(self.uniffiClonePointer(), $0)
        })
    }

    open func routeHints() -> [[RouteHintHop]] {
        return try! FfiConverterSequenceSequenceTypeRouteHintHop.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_route_hints(self.uniffiClonePointer(), $0)
        })
    }

    open func secondsSinceEpoch() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_seconds_since_epoch(self.uniffiClonePointer(), $0)
        })
    }

    open func secondsUntilExpiry() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_seconds_until_expiry(self.uniffiClonePointer(), $0)
        })
    }

    open func signableHash() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_signable_hash(self.uniffiClonePointer(), $0)
        })
    }

    open func wouldExpire(atTimeSeconds: UInt64) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt11invoice_would_expire(self.uniffiClonePointer(),
                                                                 FfiConverterUInt64.lower(atTimeSeconds), $0)
        })
    }

    open var debugDescription: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_debug(self.uniffiClonePointer(), $0)
            }
        )
    }

    open var description: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_display(self.uniffiClonePointer(), $0)
            }
        )
    }

    public static func == (self: Bolt11Invoice, other: Bolt11Invoice) -> Bool {
        return try! FfiConverterBool.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_eq(self.uniffiClonePointer(),
                                                                           FfiConverterTypeBolt11Invoice.lower(other), $0)
            }
        )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11Invoice: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Invoice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Invoice {
        return Bolt11Invoice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Invoice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}

public protocol Bolt11PaymentProtocol: AnyObject {
    func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws

    func estimateRoutingFees(invoice: Bolt11Invoice) throws -> UInt64

    func estimateRoutingFeesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws -> UInt64

    func failForHash(paymentHash: PaymentHash) throws

    func receive(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32) throws -> Bolt11Invoice

    func receiveForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func receiveVariableAmount(description: Bolt11InvoiceDescription, expirySecs: UInt32) throws -> Bolt11Invoice

    func receiveVariableAmountForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func receiveVariableAmountViaJitChannel(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws -> Bolt11Invoice

    func receiveVariableAmountViaJitChannelForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func receiveViaJitChannel(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws -> Bolt11Invoice

    func receiveViaJitChannelForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func send(invoice: Bolt11Invoice, routeParameters: RouteParametersConfig?) throws -> PaymentId

    func sendProbes(invoice: Bolt11Invoice, routeParameters: RouteParametersConfig?) throws

    func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, routeParameters: RouteParametersConfig?) throws

    func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, routeParameters: RouteParametersConfig?) throws -> PaymentId
}

open class Bolt11Payment:
    Bolt11PaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11payment(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt11payment(pointer, $0) }
    }

    open func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash(self.uniffiClonePointer(),
                                                               FfiConverterTypePaymentHash.lower(paymentHash),
                                                               FfiConverterUInt64.lower(claimableAmountMsat),
                                                               FfiConverterTypePaymentPreimage.lower(preimage), $0)
    }
    }

    open func estimateRoutingFees(invoice: Bolt11Invoice) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees(self.uniffiClonePointer(),
                                                                          FfiConverterTypeBolt11Invoice.lower(invoice), $0)
        })
    }

    open func estimateRoutingFeesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees_using_amount(self.uniffiClonePointer(),
                                                                                       FfiConverterTypeBolt11Invoice.lower(invoice),
                                                                                       FfiConverterUInt64.lower(amountMsat), $0)
        })
    }

    open func failForHash(paymentHash: PaymentHash) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash(self.uniffiClonePointer(),
                                                              FfiConverterTypePaymentHash.lower(paymentHash), $0)
    }
    }

    open func receive(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive(self.uniffiClonePointer(),
                                                            FfiConverterUInt64.lower(amountMsat),
                                                            FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                            FfiConverterUInt32.lower(expirySecs), $0)
        })
    }

    open func receiveForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash(self.uniffiClonePointer(),
                                                                     FfiConverterUInt64.lower(amountMsat),
                                                                     FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                     FfiConverterUInt32.lower(expirySecs),
                                                                     FfiConverterTypePaymentHash.lower(paymentHash), $0)
        })
    }

    open func receiveVariableAmount(description: Bolt11InvoiceDescription, expirySecs: UInt32) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount(self.uniffiClonePointer(),
                                                                            FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                            FfiConverterUInt32.lower(expirySecs), $0)
        })
    }

    open func receiveVariableAmountForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash(self.uniffiClonePointer(),
                                                                                     FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                                     FfiConverterUInt32.lower(expirySecs),
                                                                                     FfiConverterTypePaymentHash.lower(paymentHash), $0)
        })
    }

    open func receiveVariableAmountViaJitChannel(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel(self.uniffiClonePointer(),
                                                                                            FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                                            FfiConverterUInt32.lower(expirySecs),
                                                                                            FfiConverterOptionUInt64.lower(maxProportionalLspFeeLimitPpmMsat), $0)
        })
    }

    open func receiveVariableAmountViaJitChannelForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash(self.uniffiClonePointer(),
                                                                                                     FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                                                     FfiConverterUInt32.lower(expirySecs),
                                                                                                     FfiConverterOptionUInt64.lower(maxProportionalLspFeeLimitPpmMsat),
                                                                                                     FfiConverterTypePaymentHash.lower(paymentHash), $0)
        })
    }

    open func receiveViaJitChannel(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel(self.uniffiClonePointer(),
                                                                            FfiConverterUInt64.lower(amountMsat),
                                                                            FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                            FfiConverterUInt32.lower(expirySecs),
                                                                            FfiConverterOptionUInt64.lower(maxLspFeeLimitMsat), $0)
        })
    }

    open func receiveViaJitChannelForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel_for_hash(self.uniffiClonePointer(),
                                                                                     FfiConverterUInt64.lower(amountMsat),
                                                                                     FfiConverterTypeBolt11InvoiceDescription.lower(description),
                                                                                     FfiConverterUInt32.lower(expirySecs),
                                                                                     FfiConverterOptionUInt64.lower(maxLspFeeLimitMsat),
                                                                                     FfiConverterTypePaymentHash.lower(paymentHash), $0)
        })
    }

    open func send(invoice: Bolt11Invoice, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_send(self.uniffiClonePointer(),
                                                         FfiConverterTypeBolt11Invoice.lower(invoice),
                                                         FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func sendProbes(invoice: Bolt11Invoice, routeParameters: RouteParametersConfig?) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_bolt11payment_send_probes(self.uniffiClonePointer(),
                                                            FfiConverterTypeBolt11Invoice.lower(invoice),
                                                            FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
    }
    }

    open func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, routeParameters: RouteParametersConfig?) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount(self.uniffiClonePointer(),
                                                                         FfiConverterTypeBolt11Invoice.lower(invoice),
                                                                         FfiConverterUInt64.lower(amountMsat),
                                                                         FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
    }
    }

    open func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt11payment_send_using_amount(self.uniffiClonePointer(),
                                                                      FfiConverterTypeBolt11Invoice.lower(invoice),
                                                                      FfiConverterUInt64.lower(amountMsat),
                                                                      FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11Payment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
        return Bolt11Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
    return try FfiConverterTypeBolt11Payment.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11Payment_lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Payment.lower(value)
}

public protocol Bolt12InvoiceProtocol: AnyObject {
    func absoluteExpirySeconds() -> UInt64?

    func amount() -> OfferAmount?

    func amountMsats() -> UInt64

    func chain() -> [UInt8]

    func createdAt() -> UInt64

    func encode() -> [UInt8]

    func fallbackAddresses() -> [Address]

    func invoiceDescription() -> String?

    func isExpired() -> Bool

    func issuer() -> String?

    func issuerSigningPubkey() -> PublicKey?

    func metadata() -> [UInt8]?

    func offerChains() -> [[UInt8]]?

    func payerNote() -> String?

    func payerSigningPubkey() -> PublicKey

    func paymentHash() -> PaymentHash

    func quantity() -> UInt64?

    func relativeExpiry() -> UInt64

    func signableHash() -> [UInt8]

    func signingPubkey() -> PublicKey
}

open class Bolt12Invoice:
    Bolt12InvoiceProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt12invoice(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt12invoice(pointer, $0) }
    }

    public static func fromStr(invoiceStr: String) throws -> Bolt12Invoice {
        return try FfiConverterTypeBolt12Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_constructor_bolt12invoice_from_str(
                FfiConverterString.lower(invoiceStr), $0
            )
        })
    }

    open func absoluteExpirySeconds() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_absolute_expiry_seconds(self.uniffiClonePointer(), $0)
        })
    }

    open func amount() -> OfferAmount? {
        return try! FfiConverterOptionTypeOfferAmount.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_amount(self.uniffiClonePointer(), $0)
        })
    }

    open func amountMsats() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_amount_msats(self.uniffiClonePointer(), $0)
        })
    }

    open func chain() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_chain(self.uniffiClonePointer(), $0)
        })
    }

    open func createdAt() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_created_at(self.uniffiClonePointer(), $0)
        })
    }

    open func encode() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_encode(self.uniffiClonePointer(), $0)
        })
    }

    open func fallbackAddresses() -> [Address] {
        return try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_fallback_addresses(self.uniffiClonePointer(), $0)
        })
    }

    open func invoiceDescription() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_invoice_description(self.uniffiClonePointer(), $0)
        })
    }

    open func isExpired() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_is_expired(self.uniffiClonePointer(), $0)
        })
    }

    open func issuer() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_issuer(self.uniffiClonePointer(), $0)
        })
    }

    open func issuerSigningPubkey() -> PublicKey? {
        return try! FfiConverterOptionTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_issuer_signing_pubkey(self.uniffiClonePointer(), $0)
        })
    }

    open func metadata() -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_metadata(self.uniffiClonePointer(), $0)
        })
    }

    open func offerChains() -> [[UInt8]]? {
        return try! FfiConverterOptionSequenceSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_offer_chains(self.uniffiClonePointer(), $0)
        })
    }

    open func payerNote() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_payer_note(self.uniffiClonePointer(), $0)
        })
    }

    open func payerSigningPubkey() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_payer_signing_pubkey(self.uniffiClonePointer(), $0)
        })
    }

    open func paymentHash() -> PaymentHash {
        return try! FfiConverterTypePaymentHash.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_payment_hash(self.uniffiClonePointer(), $0)
        })
    }

    open func quantity() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_quantity(self.uniffiClonePointer(), $0)
        })
    }

    open func relativeExpiry() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_relative_expiry(self.uniffiClonePointer(), $0)
        })
    }

    open func signableHash() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_signable_hash(self.uniffiClonePointer(), $0)
        })
    }

    open func signingPubkey() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_bolt12invoice_signing_pubkey(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Invoice: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt12Invoice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Invoice {
        return Bolt12Invoice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt12Invoice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}

public protocol Bolt12PaymentProtocol: AnyObject {
    func blindedPathsForAsyncRecipient(recipientId: Data) throws -> Data

    func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> Refund

    func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?) throws -> Offer

    func receiveAsync() throws -> Offer

    func receiveVariableAmount(description: String, expirySecs: UInt32?) throws -> Offer

    func requestRefundPayment(refund: Refund) throws -> Bolt12Invoice

    func send(offer: Offer, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> PaymentId

    func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> PaymentId

    func setPathsToStaticInvoiceServer(paths: Data) throws
}

open class Bolt12Payment:
    Bolt12PaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt12payment(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt12payment(pointer, $0) }
    }

    open func blindedPathsForAsyncRecipient(recipientId: Data) throws -> Data {
        return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_blinded_paths_for_async_recipient(self.uniffiClonePointer(),
                                                                                      FfiConverterData.lower(recipientId), $0)
        })
    }

    open func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> Refund {
        return try FfiConverterTypeRefund.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_initiate_refund(self.uniffiClonePointer(),
                                                                    FfiConverterUInt64.lower(amountMsat),
                                                                    FfiConverterUInt32.lower(expirySecs),
                                                                    FfiConverterOptionUInt64.lower(quantity),
                                                                    FfiConverterOptionString.lower(payerNote),
                                                                    FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?) throws -> Offer {
        return try FfiConverterTypeOffer.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_receive(self.uniffiClonePointer(),
                                                            FfiConverterUInt64.lower(amountMsat),
                                                            FfiConverterString.lower(description),
                                                            FfiConverterOptionUInt32.lower(expirySecs),
                                                            FfiConverterOptionUInt64.lower(quantity), $0)
        })
    }

    open func receiveAsync() throws -> Offer {
        return try FfiConverterTypeOffer.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_receive_async(self.uniffiClonePointer(), $0)
        })
    }

    open func receiveVariableAmount(description: String, expirySecs: UInt32?) throws -> Offer {
        return try FfiConverterTypeOffer.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount(self.uniffiClonePointer(),
                                                                            FfiConverterString.lower(description),
                                                                            FfiConverterOptionUInt32.lower(expirySecs), $0)
        })
    }

    open func requestRefundPayment(refund: Refund) throws -> Bolt12Invoice {
        return try FfiConverterTypeBolt12Invoice.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment(self.uniffiClonePointer(),
                                                                           FfiConverterTypeRefund.lower(refund), $0)
        })
    }

    open func send(offer: Offer, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_send(self.uniffiClonePointer(),
                                                         FfiConverterTypeOffer.lower(offer),
                                                         FfiConverterOptionUInt64.lower(quantity),
                                                         FfiConverterOptionString.lower(payerNote),
                                                         FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_bolt12payment_send_using_amount(self.uniffiClonePointer(),
                                                                      FfiConverterTypeOffer.lower(offer),
                                                                      FfiConverterUInt64.lower(amountMsat),
                                                                      FfiConverterOptionUInt64.lower(quantity),
                                                                      FfiConverterOptionString.lower(payerNote),
                                                                      FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func setPathsToStaticInvoiceServer(paths: Data) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_bolt12payment_set_paths_to_static_invoice_server(self.uniffiClonePointer(),
                                                                                   FfiConverterData.lower(paths), $0)
    }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt12Payment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt12Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
        return Bolt12Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt12Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
    return try FfiConverterTypeBolt12Payment.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt12Payment_lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt12Payment.lower(value)
}

public protocol BuilderProtocol: AnyObject {
    func build() throws -> Node

    func buildWithFsStore() throws -> Node

    func buildWithVssStore(vssUrl: String, storeId: String, lnurlAuthServerUrl: String, fixedHeaders: [String: String]) throws -> Node

    func buildWithVssStoreAndFixedHeaders(vssUrl: String, storeId: String, fixedHeaders: [String: String]) throws -> Node

    func buildWithVssStoreAndHeaderProvider(vssUrl: String, storeId: String, headerProvider: VssHeaderProvider) throws -> Node

    func setAnnouncementAddresses(announcementAddresses: [SocketAddress]) throws

    func setAsyncPaymentsRole(role: AsyncPaymentsRole?) throws

    func setChainSourceBitcoindRest(restHost: String, restPort: UInt16, rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String)

    func setChainSourceBitcoindRpc(rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String)

    func setChainSourceElectrum(serverUrl: String, config: ElectrumSyncConfig?)

    func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?)

    func setChannelDataMigration(migration: ChannelDataMigration)

    func setCustomLogger(logWriter: LogWriter)

    func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?)

    func setEntropySeedBytes(seedBytes: [UInt8]) throws

    func setEntropySeedPath(seedPath: String)

    func setFilesystemLogger(logFilePath: String?, maxLogLevel: LogLevel?)

    func setGossipSourceP2p()

    func setGossipSourceRgs(rgsServerUrl: String)

    func setLiquiditySourceLsps1(nodeId: PublicKey, address: SocketAddress, token: String?)

    func setLiquiditySourceLsps2(nodeId: PublicKey, address: SocketAddress, token: String?)

    func setListeningAddresses(listeningAddresses: [SocketAddress]) throws

    func setLogFacadeLogger()

    func setNetwork(network: Network)

    func setNodeAlias(nodeAlias: String) throws

    func setPathfindingScoresSource(url: String)

    func setStorageDirPath(storageDirPath: String)
}

open class Builder:
    BuilderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_builder(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_ldk_node_fn_constructor_builder_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_builder(pointer, $0) }
    }

    public static func fromConfig(config: Config) -> Builder {
        return try! FfiConverterTypeBuilder.lift(try! rustCall {
            uniffi_ldk_node_fn_constructor_builder_from_config(
                FfiConverterTypeConfig.lower(config), $0
            )
        })
    }

    open func build() throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeBuildError.lift) {
            uniffi_ldk_node_fn_method_builder_build(self.uniffiClonePointer(), $0)
        })
    }

    open func buildWithFsStore() throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeBuildError.lift) {
            uniffi_ldk_node_fn_method_builder_build_with_fs_store(self.uniffiClonePointer(), $0)
        })
    }

    open func buildWithVssStore(vssUrl: String, storeId: String, lnurlAuthServerUrl: String, fixedHeaders: [String: String]) throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeBuildError.lift) {
            uniffi_ldk_node_fn_method_builder_build_with_vss_store(self.uniffiClonePointer(),
                                                                   FfiConverterString.lower(vssUrl),
                                                                   FfiConverterString.lower(storeId),
                                                                   FfiConverterString.lower(lnurlAuthServerUrl),
                                                                   FfiConverterDictionaryStringString.lower(fixedHeaders), $0)
        })
    }

    open func buildWithVssStoreAndFixedHeaders(vssUrl: String, storeId: String, fixedHeaders: [String: String]) throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeBuildError.lift) {
            uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_fixed_headers(self.uniffiClonePointer(),
                                                                                     FfiConverterString.lower(vssUrl),
                                                                                     FfiConverterString.lower(storeId),
                                                                                     FfiConverterDictionaryStringString.lower(fixedHeaders), $0)
        })
    }

    open func buildWithVssStoreAndHeaderProvider(vssUrl: String, storeId: String, headerProvider: VssHeaderProvider) throws -> Node {
        return try FfiConverterTypeNode.lift(rustCallWithError(FfiConverterTypeBuildError.lift) {
            uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_header_provider(self.uniffiClonePointer(),
                                                                                       FfiConverterString.lower(vssUrl),
                                                                                       FfiConverterString.lower(storeId),
                                                                                       FfiConverterTypeVssHeaderProvider.lower(headerProvider), $0)
        })
    }

    open func setAnnouncementAddresses(announcementAddresses: [SocketAddress]) throws { try rustCallWithError(FfiConverterTypeBuildError.lift) {
        uniffi_ldk_node_fn_method_builder_set_announcement_addresses(self.uniffiClonePointer(),
                                                                     FfiConverterSequenceTypeSocketAddress.lower(announcementAddresses), $0)
    }
    }

    open func setAsyncPaymentsRole(role: AsyncPaymentsRole?) throws { try rustCallWithError(FfiConverterTypeBuildError.lift) {
        uniffi_ldk_node_fn_method_builder_set_async_payments_role(self.uniffiClonePointer(),
                                                                  FfiConverterOptionTypeAsyncPaymentsRole.lower(role), $0)
    }
    }

    open func setChainSourceBitcoindRest(restHost: String, restPort: UInt16, rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rest(self.uniffiClonePointer(),
                                                                         FfiConverterString.lower(restHost),
                                                                         FfiConverterUInt16.lower(restPort),
                                                                         FfiConverterString.lower(rpcHost),
                                                                         FfiConverterUInt16.lower(rpcPort),
                                                                         FfiConverterString.lower(rpcUser),
                                                                         FfiConverterString.lower(rpcPassword), $0)
    }
    }

    open func setChainSourceBitcoindRpc(rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rpc(self.uniffiClonePointer(),
                                                                        FfiConverterString.lower(rpcHost),
                                                                        FfiConverterUInt16.lower(rpcPort),
                                                                        FfiConverterString.lower(rpcUser),
                                                                        FfiConverterString.lower(rpcPassword), $0)
    }
    }

    open func setChainSourceElectrum(serverUrl: String, config: ElectrumSyncConfig?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_chain_source_electrum(self.uniffiClonePointer(),
                                                                    FfiConverterString.lower(serverUrl),
                                                                    FfiConverterOptionTypeElectrumSyncConfig.lower(config), $0)
    }
    }

    open func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_chain_source_esplora(self.uniffiClonePointer(),
                                                                   FfiConverterString.lower(serverUrl),
                                                                   FfiConverterOptionTypeEsploraSyncConfig.lower(config), $0)
    }
    }

    open func setChannelDataMigration(migration: ChannelDataMigration) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_channel_data_migration(self.uniffiClonePointer(),
                                                                     FfiConverterTypeChannelDataMigration.lower(migration), $0)
    }
    }

    open func setCustomLogger(logWriter: LogWriter) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_custom_logger(self.uniffiClonePointer(),
                                                            FfiConverterTypeLogWriter.lower(logWriter), $0)
    }
    }

    open func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic(self.uniffiClonePointer(),
                                                                     FfiConverterTypeMnemonic.lower(mnemonic),
                                                                     FfiConverterOptionString.lower(passphrase), $0)
    }
    }

    open func setEntropySeedBytes(seedBytes: [UInt8]) throws { try rustCallWithError(FfiConverterTypeBuildError.lift) {
        uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes(self.uniffiClonePointer(),
                                                                 FfiConverterSequenceUInt8.lower(seedBytes), $0)
    }
    }

    open func setEntropySeedPath(seedPath: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_entropy_seed_path(self.uniffiClonePointer(),
                                                                FfiConverterString.lower(seedPath), $0)
    }
    }

    open func setFilesystemLogger(logFilePath: String?, maxLogLevel: LogLevel?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_filesystem_logger(self.uniffiClonePointer(),
                                                                FfiConverterOptionString.lower(logFilePath),
                                                                FfiConverterOptionTypeLogLevel.lower(maxLogLevel), $0)
    }
    }

    open func setGossipSourceP2p() { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p(self.uniffiClonePointer(), $0)
    }
    }

    open func setGossipSourceRgs(rgsServerUrl: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs(self.uniffiClonePointer(),
                                                                FfiConverterString.lower(rgsServerUrl), $0)
    }
    }

    open func setLiquiditySourceLsps1(nodeId: PublicKey, address: SocketAddress, token: String?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps1(self.uniffiClonePointer(),
                                                                     FfiConverterTypePublicKey.lower(nodeId),
                                                                     FfiConverterTypeSocketAddress.lower(address),
                                                                     FfiConverterOptionString.lower(token), $0)
    }
    }

    open func setLiquiditySourceLsps2(nodeId: PublicKey, address: SocketAddress, token: String?) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2(self.uniffiClonePointer(),
                                                                     FfiConverterTypePublicKey.lower(nodeId),
                                                                     FfiConverterTypeSocketAddress.lower(address),
                                                                     FfiConverterOptionString.lower(token), $0)
    }
    }

    open func setListeningAddresses(listeningAddresses: [SocketAddress]) throws { try rustCallWithError(FfiConverterTypeBuildError.lift) {
        uniffi_ldk_node_fn_method_builder_set_listening_addresses(self.uniffiClonePointer(),
                                                                  FfiConverterSequenceTypeSocketAddress.lower(listeningAddresses), $0)
    }
    }

    open func setLogFacadeLogger() { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_log_facade_logger(self.uniffiClonePointer(), $0)
    }
    }

    open func setNetwork(network: Network) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_network(self.uniffiClonePointer(),
                                                      FfiConverterTypeNetwork.lower(network), $0)
    }
    }

    open func setNodeAlias(nodeAlias: String) throws { try rustCallWithError(FfiConverterTypeBuildError.lift) {
        uniffi_ldk_node_fn_method_builder_set_node_alias(self.uniffiClonePointer(),
                                                         FfiConverterString.lower(nodeAlias), $0)
    }
    }

    open func setPathfindingScoresSource(url: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_pathfinding_scores_source(self.uniffiClonePointer(),
                                                                        FfiConverterString.lower(url), $0)
    }
    }

    open func setStorageDirPath(storageDirPath: String) { try! rustCall {
        uniffi_ldk_node_fn_method_builder_set_storage_dir_path(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(storageDirPath), $0)
    }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Builder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
        return Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Builder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
    return try FfiConverterTypeBuilder.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBuilder_lower(_ value: Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBuilder.lower(value)
}

public protocol FeeRateProtocol: AnyObject {
    func toSatPerKwu() -> UInt64

    func toSatPerVbCeil() -> UInt64

    func toSatPerVbFloor() -> UInt64
}

open class FeeRate:
    FeeRateProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_feerate(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_feerate(pointer, $0) }
    }

    public static func fromSatPerKwu(satKwu: UInt64) -> FeeRate {
        return try! FfiConverterTypeFeeRate.lift(try! rustCall {
            uniffi_ldk_node_fn_constructor_feerate_from_sat_per_kwu(
                FfiConverterUInt64.lower(satKwu), $0
            )
        })
    }

    public static func fromSatPerVbUnchecked(satVb: UInt64) -> FeeRate {
        return try! FfiConverterTypeFeeRate.lift(try! rustCall {
            uniffi_ldk_node_fn_constructor_feerate_from_sat_per_vb_unchecked(
                FfiConverterUInt64.lower(satVb), $0
            )
        })
    }

    open func toSatPerKwu() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_feerate_to_sat_per_kwu(self.uniffiClonePointer(), $0)
        })
    }

    open func toSatPerVbCeil() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_ceil(self.uniffiClonePointer(), $0)
        })
    }

    open func toSatPerVbFloor() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_floor(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeRate: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}

public protocol Lsps1LiquidityProtocol: AnyObject {
    func checkOrderStatus(orderId: Lsps1OrderId) throws -> Lsps1OrderStatus

    func requestChannel(lspBalanceSat: UInt64, clientBalanceSat: UInt64, channelExpiryBlocks: UInt32, announceChannel: Bool) throws -> Lsps1OrderStatus
}

open class Lsps1Liquidity:
    Lsps1LiquidityProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_lsps1liquidity(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_lsps1liquidity(pointer, $0) }
    }

    open func checkOrderStatus(orderId: Lsps1OrderId) throws -> Lsps1OrderStatus {
        return try FfiConverterTypeLSPS1OrderStatus.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_lsps1liquidity_check_order_status(self.uniffiClonePointer(),
                                                                        FfiConverterTypeLSPS1OrderId.lower(orderId), $0)
        })
    }

    open func requestChannel(lspBalanceSat: UInt64, clientBalanceSat: UInt64, channelExpiryBlocks: UInt32, announceChannel: Bool) throws -> Lsps1OrderStatus {
        return try FfiConverterTypeLSPS1OrderStatus.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_lsps1liquidity_request_channel(self.uniffiClonePointer(),
                                                                     FfiConverterUInt64.lower(lspBalanceSat),
                                                                     FfiConverterUInt64.lower(clientBalanceSat),
                                                                     FfiConverterUInt32.lower(channelExpiryBlocks),
                                                                     FfiConverterBool.lower(announceChannel), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1Liquidity: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Lsps1Liquidity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Lsps1Liquidity {
        return Lsps1Liquidity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Lsps1Liquidity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1Liquidity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Lsps1Liquidity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1Liquidity_lift(_ pointer: UnsafeMutableRawPointer) throws -> Lsps1Liquidity {
    return try FfiConverterTypeLSPS1Liquidity.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1Liquidity_lower(_ value: Lsps1Liquidity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLSPS1Liquidity.lower(value)
}

public protocol LogWriter: AnyObject {
    func log(record: LogRecord)
}

open class LogWriterImpl:
    LogWriter
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_logwriter(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_logwriter(pointer, $0) }
    }

    open func log(record: LogRecord) { try! rustCall {
        uniffi_ldk_node_fn_method_logwriter_log(self.uniffiClonePointer(),
                                                FfiConverterTypeLogRecord.lower(record), $0)
    }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceLogWriter {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogWriter = .init(
        log: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeLogWriter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.log(
                    record: FfiConverterTypeLogRecord.lift(record)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeLogWriter.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LogWriter: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogWriter() {
    uniffi_ldk_node_fn_init_callback_vtable_logwriter(&UniffiCallbackInterfaceLogWriter.vtable)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogWriter: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<LogWriter>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LogWriter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
        return LogWriterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogWriter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LogWriter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogWriter_lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
    return try FfiConverterTypeLogWriter.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogWriter_lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogWriter.lower(value)
}

public protocol NetworkGraphProtocol: AnyObject {
    func channel(shortChannelId: UInt64) -> ChannelInfo?

    func listChannels() -> [UInt64]

    func listNodes() -> [NodeId]

    func node(nodeId: NodeId) -> NodeInfo?
}

open class NetworkGraph:
    NetworkGraphProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_networkgraph(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_networkgraph(pointer, $0) }
    }

    open func channel(shortChannelId: UInt64) -> ChannelInfo? {
        return try! FfiConverterOptionTypeChannelInfo.lift(try! rustCall {
            uniffi_ldk_node_fn_method_networkgraph_channel(self.uniffiClonePointer(),
                                                           FfiConverterUInt64.lower(shortChannelId), $0)
        })
    }

    open func listChannels() -> [UInt64] {
        return try! FfiConverterSequenceUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_networkgraph_list_channels(self.uniffiClonePointer(), $0)
        })
    }

    open func listNodes() -> [NodeId] {
        return try! FfiConverterSequenceTypeNodeId.lift(try! rustCall {
            uniffi_ldk_node_fn_method_networkgraph_list_nodes(self.uniffiClonePointer(), $0)
        })
    }

    open func node(nodeId: NodeId) -> NodeInfo? {
        return try! FfiConverterOptionTypeNodeInfo.lift(try! rustCall {
            uniffi_ldk_node_fn_method_networkgraph_node(self.uniffiClonePointer(),
                                                        FfiConverterTypeNodeId.lower(nodeId), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkGraph: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkGraph

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
        return NetworkGraph(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkGraph {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkGraph, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkGraph_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
    return try FfiConverterTypeNetworkGraph.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkGraph_lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkGraph.lower(value)
}

public protocol NodeProtocol: AnyObject {
    func announcementAddresses() -> [SocketAddress]?

    func bolt11Payment() -> Bolt11Payment

    func bolt12Payment() -> Bolt12Payment

    func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws

    func config() -> Config

    func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws

    func currentSyncIntervals() -> RuntimeSyncIntervals

    func disconnect(nodeId: PublicKey) throws

    func eventHandled() throws

    func exportPathfindingScores() throws -> Data

    func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?) throws

    func getAddressBalance(addressStr: String) throws -> UInt64

    func getTransactionDetails(txid: Txid) -> TransactionDetails?

    func listBalances() -> BalanceDetails

    func listChannels() -> [ChannelDetails]

    func listPayments() -> [PaymentDetails]

    func listPeers() -> [PeerDetails]

    func listeningAddresses() -> [SocketAddress]?

    func lsps1Liquidity() -> Lsps1Liquidity

    func networkGraph() -> NetworkGraph

    func nextEvent() -> Event?

    func nextEventAsync() async -> Event

    func nodeAlias() -> NodeAlias?

    func nodeId() -> PublicKey

    func onchainPayment() -> OnchainPayment

    func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId

    func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId

    func payment(paymentId: PaymentId) -> PaymentDetails?

    func removePayment(paymentId: PaymentId) throws

    func signMessage(msg: [UInt8]) -> String

    func spliceIn(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, spliceAmountSats: UInt64) throws

    func spliceOut(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, address: Address, spliceAmountSats: UInt64) throws

    func spontaneousPayment() -> SpontaneousPayment

    func start() throws

    func status() -> NodeStatus

    func stop() throws

    func syncWallets() throws

    func unifiedQrPayment() -> UnifiedQrPayment

    func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws

    func updateSyncIntervals(intervals: RuntimeSyncIntervals) throws

    func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey) -> Bool

    func waitNextEvent() -> Event
}

open class Node:
    NodeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_node(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_node(pointer, $0) }
    }

    open func announcementAddresses() -> [SocketAddress]? {
        return try! FfiConverterOptionSequenceTypeSocketAddress.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_announcement_addresses(self.uniffiClonePointer(), $0)
        })
    }

    open func bolt11Payment() -> Bolt11Payment {
        return try! FfiConverterTypeBolt11Payment.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_bolt11_payment(self.uniffiClonePointer(), $0)
        })
    }

    open func bolt12Payment() -> Bolt12Payment {
        return try! FfiConverterTypeBolt12Payment.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_bolt12_payment(self.uniffiClonePointer(), $0)
        })
    }

    open func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_close_channel(self.uniffiClonePointer(),
                                                     FfiConverterTypeUserChannelId.lower(userChannelId),
                                                     FfiConverterTypePublicKey.lower(counterpartyNodeId), $0)
    }
    }

    open func config() -> Config {
        return try! FfiConverterTypeConfig.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_config(self.uniffiClonePointer(), $0)
        })
    }

    open func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_connect(self.uniffiClonePointer(),
                                               FfiConverterTypePublicKey.lower(nodeId),
                                               FfiConverterTypeSocketAddress.lower(address),
                                               FfiConverterBool.lower(persist), $0)
    }
    }

    open func currentSyncIntervals() -> RuntimeSyncIntervals {
        return try! FfiConverterTypeRuntimeSyncIntervals.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_current_sync_intervals(self.uniffiClonePointer(), $0)
        })
    }

    open func disconnect(nodeId: PublicKey) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_disconnect(self.uniffiClonePointer(),
                                                  FfiConverterTypePublicKey.lower(nodeId), $0)
    }
    }

    open func eventHandled() throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_event_handled(self.uniffiClonePointer(), $0)
    }
    }

    open func exportPathfindingScores() throws -> Data {
        return try FfiConverterData.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_node_export_pathfinding_scores(self.uniffiClonePointer(), $0)
        })
    }

    open func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_force_close_channel(self.uniffiClonePointer(),
                                                           FfiConverterTypeUserChannelId.lower(userChannelId),
                                                           FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                           FfiConverterOptionString.lower(reason), $0)
    }
    }

    open func getAddressBalance(addressStr: String) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_node_get_address_balance(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(addressStr), $0)
        })
    }

    open func getTransactionDetails(txid: Txid) -> TransactionDetails? {
        return try! FfiConverterOptionTypeTransactionDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_get_transaction_details(self.uniffiClonePointer(),
                                                                   FfiConverterTypeTxid.lower(txid), $0)
        })
    }

    open func listBalances() -> BalanceDetails {
        return try! FfiConverterTypeBalanceDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_list_balances(self.uniffiClonePointer(), $0)
        })
    }

    open func listChannels() -> [ChannelDetails] {
        return try! FfiConverterSequenceTypeChannelDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_list_channels(self.uniffiClonePointer(), $0)
        })
    }

    open func listPayments() -> [PaymentDetails] {
        return try! FfiConverterSequenceTypePaymentDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_list_payments(self.uniffiClonePointer(), $0)
        })
    }

    open func listPeers() -> [PeerDetails] {
        return try! FfiConverterSequenceTypePeerDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_list_peers(self.uniffiClonePointer(), $0)
        })
    }

    open func listeningAddresses() -> [SocketAddress]? {
        return try! FfiConverterOptionSequenceTypeSocketAddress.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_listening_addresses(self.uniffiClonePointer(), $0)
        })
    }

    open func lsps1Liquidity() -> Lsps1Liquidity {
        return try! FfiConverterTypeLSPS1Liquidity.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_lsps1_liquidity(self.uniffiClonePointer(), $0)
        })
    }

    open func networkGraph() -> NetworkGraph {
        return try! FfiConverterTypeNetworkGraph.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_network_graph(self.uniffiClonePointer(), $0)
        })
    }

    open func nextEvent() -> Event? {
        return try! FfiConverterOptionTypeEvent.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_next_event(self.uniffiClonePointer(), $0)
        })
    }

    open func nextEventAsync() async -> Event {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_ldk_node_fn_method_node_next_event_async(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
                completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
                freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeEvent.lift,
                errorHandler: nil
            )
    }

    open func nodeAlias() -> NodeAlias? {
        return try! FfiConverterOptionTypeNodeAlias.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_node_alias(self.uniffiClonePointer(), $0)
        })
    }

    open func nodeId() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_node_id(self.uniffiClonePointer(), $0)
        })
    }

    open func onchainPayment() -> OnchainPayment {
        return try! FfiConverterTypeOnchainPayment.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_onchain_payment(self.uniffiClonePointer(), $0)
        })
    }

    open func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId {
        return try FfiConverterTypeUserChannelId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_node_open_announced_channel(self.uniffiClonePointer(),
                                                                  FfiConverterTypePublicKey.lower(nodeId),
                                                                  FfiConverterTypeSocketAddress.lower(address),
                                                                  FfiConverterUInt64.lower(channelAmountSats),
                                                                  FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
                                                                  FfiConverterOptionTypeChannelConfig.lower(channelConfig), $0)
        })
    }

    open func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId {
        return try FfiConverterTypeUserChannelId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_node_open_channel(self.uniffiClonePointer(),
                                                        FfiConverterTypePublicKey.lower(nodeId),
                                                        FfiConverterTypeSocketAddress.lower(address),
                                                        FfiConverterUInt64.lower(channelAmountSats),
                                                        FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
                                                        FfiConverterOptionTypeChannelConfig.lower(channelConfig), $0)
        })
    }

    open func payment(paymentId: PaymentId) -> PaymentDetails? {
        return try! FfiConverterOptionTypePaymentDetails.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_payment(self.uniffiClonePointer(),
                                                   FfiConverterTypePaymentId.lower(paymentId), $0)
        })
    }

    open func removePayment(paymentId: PaymentId) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_remove_payment(self.uniffiClonePointer(),
                                                      FfiConverterTypePaymentId.lower(paymentId), $0)
    }
    }

    open func signMessage(msg: [UInt8]) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_sign_message(self.uniffiClonePointer(),
                                                        FfiConverterSequenceUInt8.lower(msg), $0)
        })
    }

    open func spliceIn(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, spliceAmountSats: UInt64) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_splice_in(self.uniffiClonePointer(),
                                                 FfiConverterTypeUserChannelId.lower(userChannelId),
                                                 FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                 FfiConverterUInt64.lower(spliceAmountSats), $0)
    }
    }

    open func spliceOut(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, address: Address, spliceAmountSats: UInt64) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_splice_out(self.uniffiClonePointer(),
                                                  FfiConverterTypeUserChannelId.lower(userChannelId),
                                                  FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                  FfiConverterTypeAddress.lower(address),
                                                  FfiConverterUInt64.lower(spliceAmountSats), $0)
    }
    }

    open func spontaneousPayment() -> SpontaneousPayment {
        return try! FfiConverterTypeSpontaneousPayment.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_spontaneous_payment(self.uniffiClonePointer(), $0)
        })
    }

    open func start() throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_start(self.uniffiClonePointer(), $0)
    }
    }

    open func status() -> NodeStatus {
        return try! FfiConverterTypeNodeStatus.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_status(self.uniffiClonePointer(), $0)
        })
    }

    open func stop() throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_stop(self.uniffiClonePointer(), $0)
    }
    }

    open func syncWallets() throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_sync_wallets(self.uniffiClonePointer(), $0)
    }
    }

    open func unifiedQrPayment() -> UnifiedQrPayment {
        return try! FfiConverterTypeUnifiedQrPayment.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_unified_qr_payment(self.uniffiClonePointer(), $0)
        })
    }

    open func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_update_channel_config(self.uniffiClonePointer(),
                                                             FfiConverterTypeUserChannelId.lower(userChannelId),
                                                             FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                             FfiConverterTypeChannelConfig.lower(channelConfig), $0)
    }
    }

    open func updateSyncIntervals(intervals: RuntimeSyncIntervals) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_node_update_sync_intervals(self.uniffiClonePointer(),
                                                             FfiConverterTypeRuntimeSyncIntervals.lower(intervals), $0)
    }
    }

    open func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_verify_signature(self.uniffiClonePointer(),
                                                            FfiConverterSequenceUInt8.lower(msg),
                                                            FfiConverterString.lower(sig),
                                                            FfiConverterTypePublicKey.lower(pkey), $0)
        })
    }

    open func waitNextEvent() -> Event {
        return try! FfiConverterTypeEvent.lift(try! rustCall {
            uniffi_ldk_node_fn_method_node_wait_next_event(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Node

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
        return Node(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Node) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
    return try FfiConverterTypeNode.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lower(_ value: Node) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNode.lower(value)
}

public protocol OfferProtocol: AnyObject {
    func absoluteExpirySeconds() -> UInt64?

    func amount() -> OfferAmount?

    func chains() -> [Network]

    func expectsQuantity() -> Bool

    func id() -> OfferId

    func isExpired() -> Bool

    func isValidQuantity(quantity: UInt64) -> Bool

    func issuer() -> String?

    func issuerSigningPubkey() -> PublicKey?

    func metadata() -> [UInt8]?

    func offerDescription() -> String?

    func supportsChain(chain: Network) -> Bool
}

open class Offer:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    OfferProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_offer(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_offer(pointer, $0) }
    }

    public static func fromStr(offerStr: String) throws -> Offer {
        return try FfiConverterTypeOffer.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_constructor_offer_from_str(
                FfiConverterString.lower(offerStr), $0
            )
        })
    }

    open func absoluteExpirySeconds() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_absolute_expiry_seconds(self.uniffiClonePointer(), $0)
        })
    }

    open func amount() -> OfferAmount? {
        return try! FfiConverterOptionTypeOfferAmount.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_amount(self.uniffiClonePointer(), $0)
        })
    }

    open func chains() -> [Network] {
        return try! FfiConverterSequenceTypeNetwork.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_chains(self.uniffiClonePointer(), $0)
        })
    }

    open func expectsQuantity() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_expects_quantity(self.uniffiClonePointer(), $0)
        })
    }

    open func id() -> OfferId {
        return try! FfiConverterTypeOfferId.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_id(self.uniffiClonePointer(), $0)
        })
    }

    open func isExpired() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_is_expired(self.uniffiClonePointer(), $0)
        })
    }

    open func isValidQuantity(quantity: UInt64) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_is_valid_quantity(self.uniffiClonePointer(),
                                                              FfiConverterUInt64.lower(quantity), $0)
        })
    }

    open func issuer() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_issuer(self.uniffiClonePointer(), $0)
        })
    }

    open func issuerSigningPubkey() -> PublicKey? {
        return try! FfiConverterOptionTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_issuer_signing_pubkey(self.uniffiClonePointer(), $0)
        })
    }

    open func metadata() -> [UInt8]? {
        return try! FfiConverterOptionSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_metadata(self.uniffiClonePointer(), $0)
        })
    }

    open func offerDescription() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_offer_description(self.uniffiClonePointer(), $0)
        })
    }

    open func supportsChain(chain: Network) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_offer_supports_chain(self.uniffiClonePointer(),
                                                           FfiConverterTypeNetwork.lower(chain), $0)
        })
    }

    open var debugDescription: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_offer_uniffi_trait_debug(self.uniffiClonePointer(), $0)
            }
        )
    }

    open var description: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_offer_uniffi_trait_display(self.uniffiClonePointer(), $0)
            }
        )
    }

    public static func == (self: Offer, other: Offer) -> Bool {
        return try! FfiConverterBool.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_eq(self.uniffiClonePointer(),
                                                                   FfiConverterTypeOffer.lower(other), $0)
            }
        )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOffer: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Offer

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Offer {
        return Offer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Offer) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Offer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Offer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOffer_lift(_ pointer: UnsafeMutableRawPointer) throws -> Offer {
    return try FfiConverterTypeOffer.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOffer_lower(_ value: Offer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOffer.lower(value)
}

public protocol OnchainPaymentProtocol: AnyObject {
    func accelerateByCpfp(txid: Txid, feeRate: FeeRate?, destinationAddress: Address?) throws -> Txid

    func bumpFeeByRbf(txid: Txid, feeRate: FeeRate) throws -> Txid

    func calculateCpfpFeeRate(parentTxid: Txid, urgent: Bool) throws -> FeeRate

    func calculateTotalFee(address: Address, amountSats: UInt64, feeRate: FeeRate?, utxosToSpend: [SpendableUtxo]?) throws -> UInt64

    func listSpendableOutputs() throws -> [SpendableUtxo]

    func newAddress() throws -> Address

    func selectUtxosWithAlgorithm(targetAmountSats: UInt64, feeRate: FeeRate?, algorithm: CoinSelectionAlgorithm, utxos: [SpendableUtxo]?) throws -> [SpendableUtxo]

    func sendAllToAddress(address: Address, retainReserve: Bool, feeRate: FeeRate?) throws -> Txid

    func sendToAddress(address: Address, amountSats: UInt64, feeRate: FeeRate?, utxosToSpend: [SpendableUtxo]?) throws -> Txid
}

open class OnchainPayment:
    OnchainPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_onchainpayment(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_onchainpayment(pointer, $0) }
    }

    open func accelerateByCpfp(txid: Txid, feeRate: FeeRate?, destinationAddress: Address?) throws -> Txid {
        return try FfiConverterTypeTxid.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_accelerate_by_cpfp(self.uniffiClonePointer(),
                                                                        FfiConverterTypeTxid.lower(txid),
                                                                        FfiConverterOptionTypeFeeRate.lower(feeRate),
                                                                        FfiConverterOptionTypeAddress.lower(destinationAddress), $0)
        })
    }

    open func bumpFeeByRbf(txid: Txid, feeRate: FeeRate) throws -> Txid {
        return try FfiConverterTypeTxid.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_bump_fee_by_rbf(self.uniffiClonePointer(),
                                                                     FfiConverterTypeTxid.lower(txid),
                                                                     FfiConverterTypeFeeRate.lower(feeRate), $0)
        })
    }

    open func calculateCpfpFeeRate(parentTxid: Txid, urgent: Bool) throws -> FeeRate {
        return try FfiConverterTypeFeeRate.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_calculate_cpfp_fee_rate(self.uniffiClonePointer(),
                                                                             FfiConverterTypeTxid.lower(parentTxid),
                                                                             FfiConverterBool.lower(urgent), $0)
        })
    }

    open func calculateTotalFee(address: Address, amountSats: UInt64, feeRate: FeeRate?, utxosToSpend: [SpendableUtxo]?) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_calculate_total_fee(self.uniffiClonePointer(),
                                                                         FfiConverterTypeAddress.lower(address),
                                                                         FfiConverterUInt64.lower(amountSats),
                                                                         FfiConverterOptionTypeFeeRate.lower(feeRate),
                                                                         FfiConverterOptionSequenceTypeSpendableUtxo.lower(utxosToSpend), $0)
        })
    }

    open func listSpendableOutputs() throws -> [SpendableUtxo] {
        return try FfiConverterSequenceTypeSpendableUtxo.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_list_spendable_outputs(self.uniffiClonePointer(), $0)
        })
    }

    open func newAddress() throws -> Address {
        return try FfiConverterTypeAddress.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_new_address(self.uniffiClonePointer(), $0)
        })
    }

    open func selectUtxosWithAlgorithm(targetAmountSats: UInt64, feeRate: FeeRate?, algorithm: CoinSelectionAlgorithm, utxos: [SpendableUtxo]?) throws -> [SpendableUtxo] {
        return try FfiConverterSequenceTypeSpendableUtxo.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_select_utxos_with_algorithm(self.uniffiClonePointer(),
                                                                                 FfiConverterUInt64.lower(targetAmountSats),
                                                                                 FfiConverterOptionTypeFeeRate.lower(feeRate),
                                                                                 FfiConverterTypeCoinSelectionAlgorithm.lower(algorithm),
                                                                                 FfiConverterOptionSequenceTypeSpendableUtxo.lower(utxos), $0)
        })
    }

    open func sendAllToAddress(address: Address, retainReserve: Bool, feeRate: FeeRate?) throws -> Txid {
        return try FfiConverterTypeTxid.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address(self.uniffiClonePointer(),
                                                                         FfiConverterTypeAddress.lower(address),
                                                                         FfiConverterBool.lower(retainReserve),
                                                                         FfiConverterOptionTypeFeeRate.lower(feeRate), $0)
        })
    }

    open func sendToAddress(address: Address, amountSats: UInt64, feeRate: FeeRate?, utxosToSpend: [SpendableUtxo]?) throws -> Txid {
        return try FfiConverterTypeTxid.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_onchainpayment_send_to_address(self.uniffiClonePointer(),
                                                                     FfiConverterTypeAddress.lower(address),
                                                                     FfiConverterUInt64.lower(amountSats),
                                                                     FfiConverterOptionTypeFeeRate.lower(feeRate),
                                                                     FfiConverterOptionSequenceTypeSpendableUtxo.lower(utxosToSpend), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OnchainPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
        return OnchainPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OnchainPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
    return try FfiConverterTypeOnchainPayment.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainPayment_lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnchainPayment.lower(value)
}

public protocol RefundProtocol: AnyObject {
    func absoluteExpirySeconds() -> UInt64?

    func amountMsats() -> UInt64

    func chain() -> Network?

    func isExpired() -> Bool

    func issuer() -> String?

    func payerMetadata() -> [UInt8]

    func payerNote() -> String?

    func payerSigningPubkey() -> PublicKey

    func quantity() -> UInt64?

    func refundDescription() -> String
}

open class Refund:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    RefundProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_refund(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_refund(pointer, $0) }
    }

    public static func fromStr(refundStr: String) throws -> Refund {
        return try FfiConverterTypeRefund.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_constructor_refund_from_str(
                FfiConverterString.lower(refundStr), $0
            )
        })
    }

    open func absoluteExpirySeconds() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_absolute_expiry_seconds(self.uniffiClonePointer(), $0)
        })
    }

    open func amountMsats() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_amount_msats(self.uniffiClonePointer(), $0)
        })
    }

    open func chain() -> Network? {
        return try! FfiConverterOptionTypeNetwork.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_chain(self.uniffiClonePointer(), $0)
        })
    }

    open func isExpired() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_is_expired(self.uniffiClonePointer(), $0)
        })
    }

    open func issuer() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_issuer(self.uniffiClonePointer(), $0)
        })
    }

    open func payerMetadata() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_payer_metadata(self.uniffiClonePointer(), $0)
        })
    }

    open func payerNote() -> String? {
        return try! FfiConverterOptionString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_payer_note(self.uniffiClonePointer(), $0)
        })
    }

    open func payerSigningPubkey() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_payer_signing_pubkey(self.uniffiClonePointer(), $0)
        })
    }

    open func quantity() -> UInt64? {
        return try! FfiConverterOptionUInt64.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_quantity(self.uniffiClonePointer(), $0)
        })
    }

    open func refundDescription() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_ldk_node_fn_method_refund_refund_description(self.uniffiClonePointer(), $0)
        })
    }

    open var debugDescription: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_refund_uniffi_trait_debug(self.uniffiClonePointer(), $0)
            }
        )
    }

    open var description: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_refund_uniffi_trait_display(self.uniffiClonePointer(), $0)
            }
        )
    }

    public static func == (self: Refund, other: Refund) -> Bool {
        return try! FfiConverterBool.lift(
            try! rustCall {
                uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_eq(self.uniffiClonePointer(),
                                                                    FfiConverterTypeRefund.lower(other), $0)
            }
        )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRefund: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Refund

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Refund {
        return Refund(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Refund) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Refund {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Refund, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRefund_lift(_ pointer: UnsafeMutableRawPointer) throws -> Refund {
    return try FfiConverterTypeRefund.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRefund_lower(_ value: Refund) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRefund.lower(value)
}

public protocol SpontaneousPaymentProtocol: AnyObject {
    func send(amountMsat: UInt64, nodeId: PublicKey, routeParameters: RouteParametersConfig?) throws -> PaymentId

    func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws

    func sendWithCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, routeParameters: RouteParametersConfig?, customTlvs: [CustomTlvRecord]) throws -> PaymentId

    func sendWithPreimage(amountMsat: UInt64, nodeId: PublicKey, preimage: PaymentPreimage, routeParameters: RouteParametersConfig?) throws -> PaymentId

    func sendWithPreimageAndCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, customTlvs: [CustomTlvRecord], preimage: PaymentPreimage, routeParameters: RouteParametersConfig?) throws -> PaymentId
}

open class SpontaneousPayment:
    SpontaneousPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_spontaneouspayment(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_spontaneouspayment(pointer, $0) }
    }

    open func send(amountMsat: UInt64, nodeId: PublicKey, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_spontaneouspayment_send(self.uniffiClonePointer(),
                                                              FfiConverterUInt64.lower(amountMsat),
                                                              FfiConverterTypePublicKey.lower(nodeId),
                                                              FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws { try rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_method_spontaneouspayment_send_probes(self.uniffiClonePointer(),
                                                                 FfiConverterUInt64.lower(amountMsat),
                                                                 FfiConverterTypePublicKey.lower(nodeId), $0)
    }
    }

    open func sendWithCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, routeParameters: RouteParametersConfig?, customTlvs: [CustomTlvRecord]) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_spontaneouspayment_send_with_custom_tlvs(self.uniffiClonePointer(),
                                                                               FfiConverterUInt64.lower(amountMsat),
                                                                               FfiConverterTypePublicKey.lower(nodeId),
                                                                               FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters),
                                                                               FfiConverterSequenceTypeCustomTlvRecord.lower(customTlvs), $0)
        })
    }

    open func sendWithPreimage(amountMsat: UInt64, nodeId: PublicKey, preimage: PaymentPreimage, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage(self.uniffiClonePointer(),
                                                                            FfiConverterUInt64.lower(amountMsat),
                                                                            FfiConverterTypePublicKey.lower(nodeId),
                                                                            FfiConverterTypePaymentPreimage.lower(preimage),
                                                                            FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }

    open func sendWithPreimageAndCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, customTlvs: [CustomTlvRecord], preimage: PaymentPreimage, routeParameters: RouteParametersConfig?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage_and_custom_tlvs(self.uniffiClonePointer(),
                                                                                            FfiConverterUInt64.lower(amountMsat),
                                                                                            FfiConverterTypePublicKey.lower(nodeId),
                                                                                            FfiConverterSequenceTypeCustomTlvRecord.lower(customTlvs),
                                                                                            FfiConverterTypePaymentPreimage.lower(preimage),
                                                                                            FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpontaneousPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpontaneousPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
        return SpontaneousPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpontaneousPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpontaneousPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSpontaneousPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
    return try FfiConverterTypeSpontaneousPayment.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSpontaneousPayment_lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpontaneousPayment.lower(value)
}

public protocol UnifiedQrPaymentProtocol: AnyObject {
    func receive(amountSats: UInt64, message: String, expirySec: UInt32) throws -> String

    func send(uriStr: String, routeParameters: RouteParametersConfig?) throws -> QrPaymentResult
}

open class UnifiedQrPayment:
    UnifiedQrPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_unifiedqrpayment(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_unifiedqrpayment(pointer, $0) }
    }

    open func receive(amountSats: UInt64, message: String, expirySec: UInt32) throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_unifiedqrpayment_receive(self.uniffiClonePointer(),
                                                               FfiConverterUInt64.lower(amountSats),
                                                               FfiConverterString.lower(message),
                                                               FfiConverterUInt32.lower(expirySec), $0)
        })
    }

    open func send(uriStr: String, routeParameters: RouteParametersConfig?) throws -> QrPaymentResult {
        return try FfiConverterTypeQrPaymentResult.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
            uniffi_ldk_node_fn_method_unifiedqrpayment_send(self.uniffiClonePointer(),
                                                            FfiConverterString.lower(uriStr),
                                                            FfiConverterOptionTypeRouteParametersConfig.lower(routeParameters), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnifiedQrPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnifiedQrPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
        return UnifiedQrPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnifiedQrPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnifiedQrPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUnifiedQrPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
    return try FfiConverterTypeUnifiedQrPayment.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUnifiedQrPayment_lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnifiedQrPayment.lower(value)
}

public protocol VssHeaderProviderProtocol: AnyObject {
    func getHeaders(request: [UInt8]) async throws -> [String: String]
}

open class VssHeaderProvider:
    VssHeaderProviderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_vssheaderprovider(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_vssheaderprovider(pointer, $0) }
    }

    open func getHeaders(request: [UInt8]) async throws -> [String: String] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_ldk_node_fn_method_vssheaderprovider_get_headers(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceUInt8.lower(request)
                    )
                },
                pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
                completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
                freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
                liftFunc: FfiConverterDictionaryStringString.lift,
                errorHandler: FfiConverterTypeVssHeaderProviderError.lift
            )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeVssHeaderProvider: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VssHeaderProvider

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VssHeaderProvider {
        return VssHeaderProvider(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VssHeaderProvider) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VssHeaderProvider {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VssHeaderProvider, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeVssHeaderProvider_lift(_ pointer: UnsafeMutableRawPointer) throws -> VssHeaderProvider {
    return try FfiConverterTypeVssHeaderProvider.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeVssHeaderProvider_lower(_ value: VssHeaderProvider) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVssHeaderProvider.lower(value)
}

public struct AnchorChannelsConfig {
    public var trustedPeersNoReserve: [PublicKey]
    public var perChannelReserveSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(trustedPeersNoReserve: [PublicKey], perChannelReserveSats: UInt64) {
        self.trustedPeersNoReserve = trustedPeersNoReserve
        self.perChannelReserveSats = perChannelReserveSats
    }
}

extension AnchorChannelsConfig: Equatable, Hashable {
    public static func == (lhs: AnchorChannelsConfig, rhs: AnchorChannelsConfig) -> Bool {
        if lhs.trustedPeersNoReserve != rhs.trustedPeersNoReserve {
            return false
        }
        if lhs.perChannelReserveSats != rhs.perChannelReserveSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustedPeersNoReserve)
        hasher.combine(perChannelReserveSats)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnchorChannelsConfig {
        return
            try AnchorChannelsConfig(
                trustedPeersNoReserve: FfiConverterSequenceTypePublicKey.read(from: &buf),
                perChannelReserveSats: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: AnchorChannelsConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.trustedPeersNoReserve, into: &buf)
        FfiConverterUInt64.write(value.perChannelReserveSats, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnchorChannelsConfig_lift(_ buf: RustBuffer) throws -> AnchorChannelsConfig {
    return try FfiConverterTypeAnchorChannelsConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAnchorChannelsConfig_lower(_ value: AnchorChannelsConfig) -> RustBuffer {
    return FfiConverterTypeAnchorChannelsConfig.lower(value)
}

public struct BackgroundSyncConfig {
    public var onchainWalletSyncIntervalSecs: UInt64
    public var lightningWalletSyncIntervalSecs: UInt64
    public var feeRateCacheUpdateIntervalSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(onchainWalletSyncIntervalSecs: UInt64, lightningWalletSyncIntervalSecs: UInt64, feeRateCacheUpdateIntervalSecs: UInt64) {
        self.onchainWalletSyncIntervalSecs = onchainWalletSyncIntervalSecs
        self.lightningWalletSyncIntervalSecs = lightningWalletSyncIntervalSecs
        self.feeRateCacheUpdateIntervalSecs = feeRateCacheUpdateIntervalSecs
    }
}

extension BackgroundSyncConfig: Equatable, Hashable {
    public static func == (lhs: BackgroundSyncConfig, rhs: BackgroundSyncConfig) -> Bool {
        if lhs.onchainWalletSyncIntervalSecs != rhs.onchainWalletSyncIntervalSecs {
            return false
        }
        if lhs.lightningWalletSyncIntervalSecs != rhs.lightningWalletSyncIntervalSecs {
            return false
        }
        if lhs.feeRateCacheUpdateIntervalSecs != rhs.feeRateCacheUpdateIntervalSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onchainWalletSyncIntervalSecs)
        hasher.combine(lightningWalletSyncIntervalSecs)
        hasher.combine(feeRateCacheUpdateIntervalSecs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackgroundSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackgroundSyncConfig {
        return
            try BackgroundSyncConfig(
                onchainWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                lightningWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                feeRateCacheUpdateIntervalSecs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: BackgroundSyncConfig, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.onchainWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.lightningWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.feeRateCacheUpdateIntervalSecs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBackgroundSyncConfig_lift(_ buf: RustBuffer) throws -> BackgroundSyncConfig {
    return try FfiConverterTypeBackgroundSyncConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBackgroundSyncConfig_lower(_ value: BackgroundSyncConfig) -> RustBuffer {
    return FfiConverterTypeBackgroundSyncConfig.lower(value)
}

public struct BalanceDetails {
    public var totalOnchainBalanceSats: UInt64
    public var spendableOnchainBalanceSats: UInt64
    public var totalAnchorChannelsReserveSats: UInt64
    public var totalLightningBalanceSats: UInt64
    public var lightningBalances: [LightningBalance]
    public var pendingBalancesFromChannelClosures: [PendingSweepBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalOnchainBalanceSats: UInt64, spendableOnchainBalanceSats: UInt64, totalAnchorChannelsReserveSats: UInt64, totalLightningBalanceSats: UInt64, lightningBalances: [LightningBalance], pendingBalancesFromChannelClosures: [PendingSweepBalance]) {
        self.totalOnchainBalanceSats = totalOnchainBalanceSats
        self.spendableOnchainBalanceSats = spendableOnchainBalanceSats
        self.totalAnchorChannelsReserveSats = totalAnchorChannelsReserveSats
        self.totalLightningBalanceSats = totalLightningBalanceSats
        self.lightningBalances = lightningBalances
        self.pendingBalancesFromChannelClosures = pendingBalancesFromChannelClosures
    }
}

extension BalanceDetails: Equatable, Hashable {
    public static func == (lhs: BalanceDetails, rhs: BalanceDetails) -> Bool {
        if lhs.totalOnchainBalanceSats != rhs.totalOnchainBalanceSats {
            return false
        }
        if lhs.spendableOnchainBalanceSats != rhs.spendableOnchainBalanceSats {
            return false
        }
        if lhs.totalAnchorChannelsReserveSats != rhs.totalAnchorChannelsReserveSats {
            return false
        }
        if lhs.totalLightningBalanceSats != rhs.totalLightningBalanceSats {
            return false
        }
        if lhs.lightningBalances != rhs.lightningBalances {
            return false
        }
        if lhs.pendingBalancesFromChannelClosures != rhs.pendingBalancesFromChannelClosures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalOnchainBalanceSats)
        hasher.combine(spendableOnchainBalanceSats)
        hasher.combine(totalAnchorChannelsReserveSats)
        hasher.combine(totalLightningBalanceSats)
        hasher.combine(lightningBalances)
        hasher.combine(pendingBalancesFromChannelClosures)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalanceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceDetails {
        return
            try BalanceDetails(
                totalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf),
                spendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf),
                totalAnchorChannelsReserveSats: FfiConverterUInt64.read(from: &buf),
                totalLightningBalanceSats: FfiConverterUInt64.read(from: &buf),
                lightningBalances: FfiConverterSequenceTypeLightningBalance.read(from: &buf),
                pendingBalancesFromChannelClosures: FfiConverterSequenceTypePendingSweepBalance.read(from: &buf)
            )
    }

    public static func write(_ value: BalanceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.totalOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.spendableOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.totalAnchorChannelsReserveSats, into: &buf)
        FfiConverterUInt64.write(value.totalLightningBalanceSats, into: &buf)
        FfiConverterSequenceTypeLightningBalance.write(value.lightningBalances, into: &buf)
        FfiConverterSequenceTypePendingSweepBalance.write(value.pendingBalancesFromChannelClosures, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBalanceDetails_lift(_ buf: RustBuffer) throws -> BalanceDetails {
    return try FfiConverterTypeBalanceDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBalanceDetails_lower(_ value: BalanceDetails) -> RustBuffer {
    return FfiConverterTypeBalanceDetails.lower(value)
}

public struct BestBlock {
    public var blockHash: BlockHash
    public var height: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockHash: BlockHash, height: UInt32) {
        self.blockHash = blockHash
        self.height = height
    }
}

extension BestBlock: Equatable, Hashable {
    public static func == (lhs: BestBlock, rhs: BestBlock) -> Bool {
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHash)
        hasher.combine(height)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBestBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BestBlock {
        return
            try BestBlock(
                blockHash: FfiConverterTypeBlockHash.read(from: &buf),
                height: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: BestBlock, into buf: inout [UInt8]) {
        FfiConverterTypeBlockHash.write(value.blockHash, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBestBlock_lift(_ buf: RustBuffer) throws -> BestBlock {
    return try FfiConverterTypeBestBlock.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBestBlock_lower(_ value: BestBlock) -> RustBuffer {
    return FfiConverterTypeBestBlock.lower(value)
}

public struct ChannelConfig {
    public var forwardingFeeProportionalMillionths: UInt32
    public var forwardingFeeBaseMsat: UInt32
    public var cltvExpiryDelta: UInt16
    public var maxDustHtlcExposure: MaxDustHtlcExposure
    public var forceCloseAvoidanceMaxFeeSatoshis: UInt64
    public var acceptUnderpayingHtlcs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(forwardingFeeProportionalMillionths: UInt32, forwardingFeeBaseMsat: UInt32, cltvExpiryDelta: UInt16, maxDustHtlcExposure: MaxDustHtlcExposure, forceCloseAvoidanceMaxFeeSatoshis: UInt64, acceptUnderpayingHtlcs: Bool) {
        self.forwardingFeeProportionalMillionths = forwardingFeeProportionalMillionths
        self.forwardingFeeBaseMsat = forwardingFeeBaseMsat
        self.cltvExpiryDelta = cltvExpiryDelta
        self.maxDustHtlcExposure = maxDustHtlcExposure
        self.forceCloseAvoidanceMaxFeeSatoshis = forceCloseAvoidanceMaxFeeSatoshis
        self.acceptUnderpayingHtlcs = acceptUnderpayingHtlcs
    }
}

extension ChannelConfig: Equatable, Hashable {
    public static func == (lhs: ChannelConfig, rhs: ChannelConfig) -> Bool {
        if lhs.forwardingFeeProportionalMillionths != rhs.forwardingFeeProportionalMillionths {
            return false
        }
        if lhs.forwardingFeeBaseMsat != rhs.forwardingFeeBaseMsat {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.maxDustHtlcExposure != rhs.maxDustHtlcExposure {
            return false
        }
        if lhs.forceCloseAvoidanceMaxFeeSatoshis != rhs.forceCloseAvoidanceMaxFeeSatoshis {
            return false
        }
        if lhs.acceptUnderpayingHtlcs != rhs.acceptUnderpayingHtlcs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(forwardingFeeProportionalMillionths)
        hasher.combine(forwardingFeeBaseMsat)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(maxDustHtlcExposure)
        hasher.combine(forceCloseAvoidanceMaxFeeSatoshis)
        hasher.combine(acceptUnderpayingHtlcs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelConfig {
        return
            try ChannelConfig(
                forwardingFeeProportionalMillionths: FfiConverterUInt32.read(from: &buf),
                forwardingFeeBaseMsat: FfiConverterUInt32.read(from: &buf),
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf),
                maxDustHtlcExposure: FfiConverterTypeMaxDustHTLCExposure.read(from: &buf),
                forceCloseAvoidanceMaxFeeSatoshis: FfiConverterUInt64.read(from: &buf),
                acceptUnderpayingHtlcs: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.forwardingFeeProportionalMillionths, into: &buf)
        FfiConverterUInt32.write(value.forwardingFeeBaseMsat, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterTypeMaxDustHTLCExposure.write(value.maxDustHtlcExposure, into: &buf)
        FfiConverterUInt64.write(value.forceCloseAvoidanceMaxFeeSatoshis, into: &buf)
        FfiConverterBool.write(value.acceptUnderpayingHtlcs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelConfig_lift(_ buf: RustBuffer) throws -> ChannelConfig {
    return try FfiConverterTypeChannelConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelConfig_lower(_ value: ChannelConfig) -> RustBuffer {
    return FfiConverterTypeChannelConfig.lower(value)
}

public struct ChannelDataMigration {
    public var channelManager: [UInt8]?
    public var channelMonitors: [[UInt8]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelManager: [UInt8]?, channelMonitors: [[UInt8]]) {
        self.channelManager = channelManager
        self.channelMonitors = channelMonitors
    }
}

extension ChannelDataMigration: Equatable, Hashable {
    public static func == (lhs: ChannelDataMigration, rhs: ChannelDataMigration) -> Bool {
        if lhs.channelManager != rhs.channelManager {
            return false
        }
        if lhs.channelMonitors != rhs.channelMonitors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelManager)
        hasher.combine(channelMonitors)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelDataMigration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelDataMigration {
        return
            try ChannelDataMigration(
                channelManager: FfiConverterOptionSequenceUInt8.read(from: &buf),
                channelMonitors: FfiConverterSequenceSequenceUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelDataMigration, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceUInt8.write(value.channelManager, into: &buf)
        FfiConverterSequenceSequenceUInt8.write(value.channelMonitors, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelDataMigration_lift(_ buf: RustBuffer) throws -> ChannelDataMigration {
    return try FfiConverterTypeChannelDataMigration.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelDataMigration_lower(_ value: ChannelDataMigration) -> RustBuffer {
    return FfiConverterTypeChannelDataMigration.lower(value)
}

public struct ChannelDetails {
    public var channelId: ChannelId
    public var counterpartyNodeId: PublicKey
    public var fundingTxo: OutPoint?
    public var shortChannelId: UInt64?
    public var outboundScidAlias: UInt64?
    public var inboundScidAlias: UInt64?
    public var channelValueSats: UInt64
    public var unspendablePunishmentReserve: UInt64?
    public var userChannelId: UserChannelId
    public var feerateSatPer1000Weight: UInt32
    public var outboundCapacityMsat: UInt64
    public var inboundCapacityMsat: UInt64
    public var confirmationsRequired: UInt32?
    public var confirmations: UInt32?
    public var isOutbound: Bool
    public var isChannelReady: Bool
    public var isUsable: Bool
    public var isAnnounced: Bool
    public var cltvExpiryDelta: UInt16?
    public var counterpartyUnspendablePunishmentReserve: UInt64
    public var counterpartyOutboundHtlcMinimumMsat: UInt64?
    public var counterpartyOutboundHtlcMaximumMsat: UInt64?
    public var counterpartyForwardingInfoFeeBaseMsat: UInt32?
    public var counterpartyForwardingInfoFeeProportionalMillionths: UInt32?
    public var counterpartyForwardingInfoCltvExpiryDelta: UInt16?
    public var nextOutboundHtlcLimitMsat: UInt64
    public var nextOutboundHtlcMinimumMsat: UInt64
    public var forceCloseSpendDelay: UInt16?
    public var inboundHtlcMinimumMsat: UInt64
    public var inboundHtlcMaximumMsat: UInt64?
    public var config: ChannelConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelId: ChannelId, counterpartyNodeId: PublicKey, fundingTxo: OutPoint?, shortChannelId: UInt64?, outboundScidAlias: UInt64?, inboundScidAlias: UInt64?, channelValueSats: UInt64, unspendablePunishmentReserve: UInt64?, userChannelId: UserChannelId, feerateSatPer1000Weight: UInt32, outboundCapacityMsat: UInt64, inboundCapacityMsat: UInt64, confirmationsRequired: UInt32?, confirmations: UInt32?, isOutbound: Bool, isChannelReady: Bool, isUsable: Bool, isAnnounced: Bool, cltvExpiryDelta: UInt16?, counterpartyUnspendablePunishmentReserve: UInt64, counterpartyOutboundHtlcMinimumMsat: UInt64?, counterpartyOutboundHtlcMaximumMsat: UInt64?, counterpartyForwardingInfoFeeBaseMsat: UInt32?, counterpartyForwardingInfoFeeProportionalMillionths: UInt32?, counterpartyForwardingInfoCltvExpiryDelta: UInt16?, nextOutboundHtlcLimitMsat: UInt64, nextOutboundHtlcMinimumMsat: UInt64, forceCloseSpendDelay: UInt16?, inboundHtlcMinimumMsat: UInt64, inboundHtlcMaximumMsat: UInt64?, config: ChannelConfig) {
        self.channelId = channelId
        self.counterpartyNodeId = counterpartyNodeId
        self.fundingTxo = fundingTxo
        self.shortChannelId = shortChannelId
        self.outboundScidAlias = outboundScidAlias
        self.inboundScidAlias = inboundScidAlias
        self.channelValueSats = channelValueSats
        self.unspendablePunishmentReserve = unspendablePunishmentReserve
        self.userChannelId = userChannelId
        self.feerateSatPer1000Weight = feerateSatPer1000Weight
        self.outboundCapacityMsat = outboundCapacityMsat
        self.inboundCapacityMsat = inboundCapacityMsat
        self.confirmationsRequired = confirmationsRequired
        self.confirmations = confirmations
        self.isOutbound = isOutbound
        self.isChannelReady = isChannelReady
        self.isUsable = isUsable
        self.isAnnounced = isAnnounced
        self.cltvExpiryDelta = cltvExpiryDelta
        self.counterpartyUnspendablePunishmentReserve = counterpartyUnspendablePunishmentReserve
        self.counterpartyOutboundHtlcMinimumMsat = counterpartyOutboundHtlcMinimumMsat
        self.counterpartyOutboundHtlcMaximumMsat = counterpartyOutboundHtlcMaximumMsat
        self.counterpartyForwardingInfoFeeBaseMsat = counterpartyForwardingInfoFeeBaseMsat
        self.counterpartyForwardingInfoFeeProportionalMillionths = counterpartyForwardingInfoFeeProportionalMillionths
        self.counterpartyForwardingInfoCltvExpiryDelta = counterpartyForwardingInfoCltvExpiryDelta
        self.nextOutboundHtlcLimitMsat = nextOutboundHtlcLimitMsat
        self.nextOutboundHtlcMinimumMsat = nextOutboundHtlcMinimumMsat
        self.forceCloseSpendDelay = forceCloseSpendDelay
        self.inboundHtlcMinimumMsat = inboundHtlcMinimumMsat
        self.inboundHtlcMaximumMsat = inboundHtlcMaximumMsat
        self.config = config
    }
}

extension ChannelDetails: Equatable, Hashable {
    public static func == (lhs: ChannelDetails, rhs: ChannelDetails) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.counterpartyNodeId != rhs.counterpartyNodeId {
            return false
        }
        if lhs.fundingTxo != rhs.fundingTxo {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.outboundScidAlias != rhs.outboundScidAlias {
            return false
        }
        if lhs.inboundScidAlias != rhs.inboundScidAlias {
            return false
        }
        if lhs.channelValueSats != rhs.channelValueSats {
            return false
        }
        if lhs.unspendablePunishmentReserve != rhs.unspendablePunishmentReserve {
            return false
        }
        if lhs.userChannelId != rhs.userChannelId {
            return false
        }
        if lhs.feerateSatPer1000Weight != rhs.feerateSatPer1000Weight {
            return false
        }
        if lhs.outboundCapacityMsat != rhs.outboundCapacityMsat {
            return false
        }
        if lhs.inboundCapacityMsat != rhs.inboundCapacityMsat {
            return false
        }
        if lhs.confirmationsRequired != rhs.confirmationsRequired {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.isOutbound != rhs.isOutbound {
            return false
        }
        if lhs.isChannelReady != rhs.isChannelReady {
            return false
        }
        if lhs.isUsable != rhs.isUsable {
            return false
        }
        if lhs.isAnnounced != rhs.isAnnounced {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.counterpartyUnspendablePunishmentReserve != rhs.counterpartyUnspendablePunishmentReserve {
            return false
        }
        if lhs.counterpartyOutboundHtlcMinimumMsat != rhs.counterpartyOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.counterpartyOutboundHtlcMaximumMsat != rhs.counterpartyOutboundHtlcMaximumMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeBaseMsat != rhs.counterpartyForwardingInfoFeeBaseMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeProportionalMillionths != rhs.counterpartyForwardingInfoFeeProportionalMillionths {
            return false
        }
        if lhs.counterpartyForwardingInfoCltvExpiryDelta != rhs.counterpartyForwardingInfoCltvExpiryDelta {
            return false
        }
        if lhs.nextOutboundHtlcLimitMsat != rhs.nextOutboundHtlcLimitMsat {
            return false
        }
        if lhs.nextOutboundHtlcMinimumMsat != rhs.nextOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.forceCloseSpendDelay != rhs.forceCloseSpendDelay {
            return false
        }
        if lhs.inboundHtlcMinimumMsat != rhs.inboundHtlcMinimumMsat {
            return false
        }
        if lhs.inboundHtlcMaximumMsat != rhs.inboundHtlcMaximumMsat {
            return false
        }
        if lhs.config != rhs.config {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(counterpartyNodeId)
        hasher.combine(fundingTxo)
        hasher.combine(shortChannelId)
        hasher.combine(outboundScidAlias)
        hasher.combine(inboundScidAlias)
        hasher.combine(channelValueSats)
        hasher.combine(unspendablePunishmentReserve)
        hasher.combine(userChannelId)
        hasher.combine(feerateSatPer1000Weight)
        hasher.combine(outboundCapacityMsat)
        hasher.combine(inboundCapacityMsat)
        hasher.combine(confirmationsRequired)
        hasher.combine(confirmations)
        hasher.combine(isOutbound)
        hasher.combine(isChannelReady)
        hasher.combine(isUsable)
        hasher.combine(isAnnounced)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(counterpartyUnspendablePunishmentReserve)
        hasher.combine(counterpartyOutboundHtlcMinimumMsat)
        hasher.combine(counterpartyOutboundHtlcMaximumMsat)
        hasher.combine(counterpartyForwardingInfoFeeBaseMsat)
        hasher.combine(counterpartyForwardingInfoFeeProportionalMillionths)
        hasher.combine(counterpartyForwardingInfoCltvExpiryDelta)
        hasher.combine(nextOutboundHtlcLimitMsat)
        hasher.combine(nextOutboundHtlcMinimumMsat)
        hasher.combine(forceCloseSpendDelay)
        hasher.combine(inboundHtlcMinimumMsat)
        hasher.combine(inboundHtlcMaximumMsat)
        hasher.combine(config)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelDetails {
        return
            try ChannelDetails(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                fundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf),
                shortChannelId: FfiConverterOptionUInt64.read(from: &buf),
                outboundScidAlias: FfiConverterOptionUInt64.read(from: &buf),
                inboundScidAlias: FfiConverterOptionUInt64.read(from: &buf),
                channelValueSats: FfiConverterUInt64.read(from: &buf),
                unspendablePunishmentReserve: FfiConverterOptionUInt64.read(from: &buf),
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf),
                feerateSatPer1000Weight: FfiConverterUInt32.read(from: &buf),
                outboundCapacityMsat: FfiConverterUInt64.read(from: &buf),
                inboundCapacityMsat: FfiConverterUInt64.read(from: &buf),
                confirmationsRequired: FfiConverterOptionUInt32.read(from: &buf),
                confirmations: FfiConverterOptionUInt32.read(from: &buf),
                isOutbound: FfiConverterBool.read(from: &buf),
                isChannelReady: FfiConverterBool.read(from: &buf),
                isUsable: FfiConverterBool.read(from: &buf),
                isAnnounced: FfiConverterBool.read(from: &buf),
                cltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf),
                counterpartyUnspendablePunishmentReserve: FfiConverterUInt64.read(from: &buf),
                counterpartyOutboundHtlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf),
                counterpartyOutboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf),
                counterpartyForwardingInfoFeeBaseMsat: FfiConverterOptionUInt32.read(from: &buf),
                counterpartyForwardingInfoFeeProportionalMillionths: FfiConverterOptionUInt32.read(from: &buf),
                counterpartyForwardingInfoCltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf),
                nextOutboundHtlcLimitMsat: FfiConverterUInt64.read(from: &buf),
                nextOutboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                forceCloseSpendDelay: FfiConverterOptionUInt16.read(from: &buf),
                inboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                inboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf),
                config: FfiConverterTypeChannelConfig.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelDetails, into buf: inout [UInt8]) {
        FfiConverterTypeChannelId.write(value.channelId, into: &buf)
        FfiConverterTypePublicKey.write(value.counterpartyNodeId, into: &buf)
        FfiConverterOptionTypeOutPoint.write(value.fundingTxo, into: &buf)
        FfiConverterOptionUInt64.write(value.shortChannelId, into: &buf)
        FfiConverterOptionUInt64.write(value.outboundScidAlias, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundScidAlias, into: &buf)
        FfiConverterUInt64.write(value.channelValueSats, into: &buf)
        FfiConverterOptionUInt64.write(value.unspendablePunishmentReserve, into: &buf)
        FfiConverterTypeUserChannelId.write(value.userChannelId, into: &buf)
        FfiConverterUInt32.write(value.feerateSatPer1000Weight, into: &buf)
        FfiConverterUInt64.write(value.outboundCapacityMsat, into: &buf)
        FfiConverterUInt64.write(value.inboundCapacityMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmationsRequired, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmations, into: &buf)
        FfiConverterBool.write(value.isOutbound, into: &buf)
        FfiConverterBool.write(value.isChannelReady, into: &buf)
        FfiConverterBool.write(value.isUsable, into: &buf)
        FfiConverterBool.write(value.isAnnounced, into: &buf)
        FfiConverterOptionUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.counterpartyUnspendablePunishmentReserve, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMaximumMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeBaseMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeProportionalMillionths, into: &buf)
        FfiConverterOptionUInt16.write(value.counterpartyForwardingInfoCltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcLimitMsat, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt16.write(value.forceCloseSpendDelay, into: &buf)
        FfiConverterUInt64.write(value.inboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundHtlcMaximumMsat, into: &buf)
        FfiConverterTypeChannelConfig.write(value.config, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelDetails_lift(_ buf: RustBuffer) throws -> ChannelDetails {
    return try FfiConverterTypeChannelDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelDetails_lower(_ value: ChannelDetails) -> RustBuffer {
    return FfiConverterTypeChannelDetails.lower(value)
}

public struct ChannelInfo {
    public var nodeOne: NodeId
    public var oneToTwo: ChannelUpdateInfo?
    public var nodeTwo: NodeId
    public var twoToOne: ChannelUpdateInfo?
    public var capacitySats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeOne: NodeId, oneToTwo: ChannelUpdateInfo?, nodeTwo: NodeId, twoToOne: ChannelUpdateInfo?, capacitySats: UInt64?) {
        self.nodeOne = nodeOne
        self.oneToTwo = oneToTwo
        self.nodeTwo = nodeTwo
        self.twoToOne = twoToOne
        self.capacitySats = capacitySats
    }
}

extension ChannelInfo: Equatable, Hashable {
    public static func == (lhs: ChannelInfo, rhs: ChannelInfo) -> Bool {
        if lhs.nodeOne != rhs.nodeOne {
            return false
        }
        if lhs.oneToTwo != rhs.oneToTwo {
            return false
        }
        if lhs.nodeTwo != rhs.nodeTwo {
            return false
        }
        if lhs.twoToOne != rhs.twoToOne {
            return false
        }
        if lhs.capacitySats != rhs.capacitySats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeOne)
        hasher.combine(oneToTwo)
        hasher.combine(nodeTwo)
        hasher.combine(twoToOne)
        hasher.combine(capacitySats)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelInfo {
        return
            try ChannelInfo(
                nodeOne: FfiConverterTypeNodeId.read(from: &buf),
                oneToTwo: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf),
                nodeTwo: FfiConverterTypeNodeId.read(from: &buf),
                twoToOne: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf),
                capacitySats: FfiConverterOptionUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.nodeOne, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.oneToTwo, into: &buf)
        FfiConverterTypeNodeId.write(value.nodeTwo, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.twoToOne, into: &buf)
        FfiConverterOptionUInt64.write(value.capacitySats, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelInfo_lift(_ buf: RustBuffer) throws -> ChannelInfo {
    return try FfiConverterTypeChannelInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelInfo_lower(_ value: ChannelInfo) -> RustBuffer {
    return FfiConverterTypeChannelInfo.lower(value)
}

public struct ChannelUpdateInfo {
    public var lastUpdate: UInt32
    public var enabled: Bool
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64
    public var htlcMaximumMsat: UInt64
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUpdate: UInt32, enabled: Bool, cltvExpiryDelta: UInt16, htlcMinimumMsat: UInt64, htlcMaximumMsat: UInt64, fees: RoutingFees) {
        self.lastUpdate = lastUpdate
        self.enabled = enabled
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}

extension ChannelUpdateInfo: Equatable, Hashable {
    public static func == (lhs: ChannelUpdateInfo, rhs: ChannelUpdateInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(enabled)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelUpdateInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelUpdateInfo {
        return
            try ChannelUpdateInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf),
                enabled: FfiConverterBool.read(from: &buf),
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf),
                htlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                htlcMaximumMsat: FfiConverterUInt64.read(from: &buf),
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelUpdateInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelUpdateInfo_lift(_ buf: RustBuffer) throws -> ChannelUpdateInfo {
    return try FfiConverterTypeChannelUpdateInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelUpdateInfo_lower(_ value: ChannelUpdateInfo) -> RustBuffer {
    return FfiConverterTypeChannelUpdateInfo.lower(value)
}

public struct Config {
    public var storageDirPath: String
    public var network: Network
    public var listeningAddresses: [SocketAddress]?
    public var announcementAddresses: [SocketAddress]?
    public var nodeAlias: NodeAlias?
    public var trustedPeers0conf: [PublicKey]
    public var probingLiquidityLimitMultiplier: UInt64
    public var anchorChannelsConfig: AnchorChannelsConfig?
    public var routeParameters: RouteParametersConfig?
    public var includeUntrustedPendingInSpendable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(storageDirPath: String, network: Network, listeningAddresses: [SocketAddress]?, announcementAddresses: [SocketAddress]?, nodeAlias: NodeAlias?, trustedPeers0conf: [PublicKey], probingLiquidityLimitMultiplier: UInt64, anchorChannelsConfig: AnchorChannelsConfig?, routeParameters: RouteParametersConfig?, includeUntrustedPendingInSpendable: Bool) {
        self.storageDirPath = storageDirPath
        self.network = network
        self.listeningAddresses = listeningAddresses
        self.announcementAddresses = announcementAddresses
        self.nodeAlias = nodeAlias
        self.trustedPeers0conf = trustedPeers0conf
        self.probingLiquidityLimitMultiplier = probingLiquidityLimitMultiplier
        self.anchorChannelsConfig = anchorChannelsConfig
        self.routeParameters = routeParameters
        self.includeUntrustedPendingInSpendable = includeUntrustedPendingInSpendable
    }
}

extension Config: Equatable, Hashable {
    public static func == (lhs: Config, rhs: Config) -> Bool {
        if lhs.storageDirPath != rhs.storageDirPath {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.listeningAddresses != rhs.listeningAddresses {
            return false
        }
        if lhs.announcementAddresses != rhs.announcementAddresses {
            return false
        }
        if lhs.nodeAlias != rhs.nodeAlias {
            return false
        }
        if lhs.trustedPeers0conf != rhs.trustedPeers0conf {
            return false
        }
        if lhs.probingLiquidityLimitMultiplier != rhs.probingLiquidityLimitMultiplier {
            return false
        }
        if lhs.anchorChannelsConfig != rhs.anchorChannelsConfig {
            return false
        }
        if lhs.routeParameters != rhs.routeParameters {
            return false
        }
        if lhs.includeUntrustedPendingInSpendable != rhs.includeUntrustedPendingInSpendable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(storageDirPath)
        hasher.combine(network)
        hasher.combine(listeningAddresses)
        hasher.combine(announcementAddresses)
        hasher.combine(nodeAlias)
        hasher.combine(trustedPeers0conf)
        hasher.combine(probingLiquidityLimitMultiplier)
        hasher.combine(anchorChannelsConfig)
        hasher.combine(routeParameters)
        hasher.combine(includeUntrustedPendingInSpendable)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                storageDirPath: FfiConverterString.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf),
                listeningAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf),
                announcementAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf),
                nodeAlias: FfiConverterOptionTypeNodeAlias.read(from: &buf),
                trustedPeers0conf: FfiConverterSequenceTypePublicKey.read(from: &buf),
                probingLiquidityLimitMultiplier: FfiConverterUInt64.read(from: &buf),
                anchorChannelsConfig: FfiConverterOptionTypeAnchorChannelsConfig.read(from: &buf),
                routeParameters: FfiConverterOptionTypeRouteParametersConfig.read(from: &buf),
                includeUntrustedPendingInSpendable: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.storageDirPath, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.listeningAddresses, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.announcementAddresses, into: &buf)
        FfiConverterOptionTypeNodeAlias.write(value.nodeAlias, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.trustedPeers0conf, into: &buf)
        FfiConverterUInt64.write(value.probingLiquidityLimitMultiplier, into: &buf)
        FfiConverterOptionTypeAnchorChannelsConfig.write(value.anchorChannelsConfig, into: &buf)
        FfiConverterOptionTypeRouteParametersConfig.write(value.routeParameters, into: &buf)
        FfiConverterBool.write(value.includeUntrustedPendingInSpendable, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}

public struct CustomTlvRecord {
    public var typeNum: UInt64
    public var value: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeNum: UInt64, value: [UInt8]) {
        self.typeNum = typeNum
        self.value = value
    }
}

extension CustomTlvRecord: Equatable, Hashable {
    public static func == (lhs: CustomTlvRecord, rhs: CustomTlvRecord) -> Bool {
        if lhs.typeNum != rhs.typeNum {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeNum)
        hasher.combine(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCustomTlvRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomTlvRecord {
        return
            try CustomTlvRecord(
                typeNum: FfiConverterUInt64.read(from: &buf),
                value: FfiConverterSequenceUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: CustomTlvRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.typeNum, into: &buf)
        FfiConverterSequenceUInt8.write(value.value, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomTlvRecord_lift(_ buf: RustBuffer) throws -> CustomTlvRecord {
    return try FfiConverterTypeCustomTlvRecord.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCustomTlvRecord_lower(_ value: CustomTlvRecord) -> RustBuffer {
    return FfiConverterTypeCustomTlvRecord.lower(value)
}

public struct ElectrumSyncConfig {
    public var backgroundSyncConfig: BackgroundSyncConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backgroundSyncConfig: BackgroundSyncConfig?) {
        self.backgroundSyncConfig = backgroundSyncConfig
    }
}

extension ElectrumSyncConfig: Equatable, Hashable {
    public static func == (lhs: ElectrumSyncConfig, rhs: ElectrumSyncConfig) -> Bool {
        if lhs.backgroundSyncConfig != rhs.backgroundSyncConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backgroundSyncConfig)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeElectrumSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumSyncConfig {
        return
            try ElectrumSyncConfig(
                backgroundSyncConfig: FfiConverterOptionTypeBackgroundSyncConfig.read(from: &buf)
            )
    }

    public static func write(_ value: ElectrumSyncConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeBackgroundSyncConfig.write(value.backgroundSyncConfig, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumSyncConfig_lift(_ buf: RustBuffer) throws -> ElectrumSyncConfig {
    return try FfiConverterTypeElectrumSyncConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElectrumSyncConfig_lower(_ value: ElectrumSyncConfig) -> RustBuffer {
    return FfiConverterTypeElectrumSyncConfig.lower(value)
}

public struct EsploraSyncConfig {
    public var backgroundSyncConfig: BackgroundSyncConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backgroundSyncConfig: BackgroundSyncConfig?) {
        self.backgroundSyncConfig = backgroundSyncConfig
    }
}

extension EsploraSyncConfig: Equatable, Hashable {
    public static func == (lhs: EsploraSyncConfig, rhs: EsploraSyncConfig) -> Bool {
        if lhs.backgroundSyncConfig != rhs.backgroundSyncConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backgroundSyncConfig)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeEsploraSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraSyncConfig {
        return
            try EsploraSyncConfig(
                backgroundSyncConfig: FfiConverterOptionTypeBackgroundSyncConfig.read(from: &buf)
            )
    }

    public static func write(_ value: EsploraSyncConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeBackgroundSyncConfig.write(value.backgroundSyncConfig, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraSyncConfig_lift(_ buf: RustBuffer) throws -> EsploraSyncConfig {
    return try FfiConverterTypeEsploraSyncConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEsploraSyncConfig_lower(_ value: EsploraSyncConfig) -> RustBuffer {
    return FfiConverterTypeEsploraSyncConfig.lower(value)
}

public struct LspFeeLimits {
    public var maxTotalOpeningFeeMsat: UInt64?
    public var maxProportionalOpeningFeePpmMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxTotalOpeningFeeMsat: UInt64?, maxProportionalOpeningFeePpmMsat: UInt64?) {
        self.maxTotalOpeningFeeMsat = maxTotalOpeningFeeMsat
        self.maxProportionalOpeningFeePpmMsat = maxProportionalOpeningFeePpmMsat
    }
}

extension LspFeeLimits: Equatable, Hashable {
    public static func == (lhs: LspFeeLimits, rhs: LspFeeLimits) -> Bool {
        if lhs.maxTotalOpeningFeeMsat != rhs.maxTotalOpeningFeeMsat {
            return false
        }
        if lhs.maxProportionalOpeningFeePpmMsat != rhs.maxProportionalOpeningFeePpmMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalOpeningFeeMsat)
        hasher.combine(maxProportionalOpeningFeePpmMsat)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPFeeLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFeeLimits {
        return
            try LspFeeLimits(
                maxTotalOpeningFeeMsat: FfiConverterOptionUInt64.read(from: &buf),
                maxProportionalOpeningFeePpmMsat: FfiConverterOptionUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: LspFeeLimits, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxTotalOpeningFeeMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.maxProportionalOpeningFeePpmMsat, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPFeeLimits_lift(_ buf: RustBuffer) throws -> LspFeeLimits {
    return try FfiConverterTypeLSPFeeLimits.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPFeeLimits_lower(_ value: LspFeeLimits) -> RustBuffer {
    return FfiConverterTypeLSPFeeLimits.lower(value)
}

public struct Lsps1Bolt11PaymentInfo {
    public var state: Lsps1PaymentState
    public var expiresAt: LspsDateTime
    public var feeTotalSat: UInt64
    public var orderTotalSat: UInt64
    public var invoice: Bolt11Invoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: Lsps1PaymentState, expiresAt: LspsDateTime, feeTotalSat: UInt64, orderTotalSat: UInt64, invoice: Bolt11Invoice) {
        self.state = state
        self.expiresAt = expiresAt
        self.feeTotalSat = feeTotalSat
        self.orderTotalSat = orderTotalSat
        self.invoice = invoice
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1Bolt11PaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1Bolt11PaymentInfo {
        return
            try Lsps1Bolt11PaymentInfo(
                state: FfiConverterTypeLSPS1PaymentState.read(from: &buf),
                expiresAt: FfiConverterTypeLSPSDateTime.read(from: &buf),
                feeTotalSat: FfiConverterUInt64.read(from: &buf),
                orderTotalSat: FfiConverterUInt64.read(from: &buf),
                invoice: FfiConverterTypeBolt11Invoice.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1Bolt11PaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypeLSPS1PaymentState.write(value.state, into: &buf)
        FfiConverterTypeLSPSDateTime.write(value.expiresAt, into: &buf)
        FfiConverterUInt64.write(value.feeTotalSat, into: &buf)
        FfiConverterUInt64.write(value.orderTotalSat, into: &buf)
        FfiConverterTypeBolt11Invoice.write(value.invoice, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1Bolt11PaymentInfo_lift(_ buf: RustBuffer) throws -> Lsps1Bolt11PaymentInfo {
    return try FfiConverterTypeLSPS1Bolt11PaymentInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1Bolt11PaymentInfo_lower(_ value: Lsps1Bolt11PaymentInfo) -> RustBuffer {
    return FfiConverterTypeLSPS1Bolt11PaymentInfo.lower(value)
}

public struct Lsps1ChannelInfo {
    public var fundedAt: LspsDateTime
    public var fundingOutpoint: OutPoint
    public var expiresAt: LspsDateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fundedAt: LspsDateTime, fundingOutpoint: OutPoint, expiresAt: LspsDateTime) {
        self.fundedAt = fundedAt
        self.fundingOutpoint = fundingOutpoint
        self.expiresAt = expiresAt
    }
}

extension Lsps1ChannelInfo: Equatable, Hashable {
    public static func == (lhs: Lsps1ChannelInfo, rhs: Lsps1ChannelInfo) -> Bool {
        if lhs.fundedAt != rhs.fundedAt {
            return false
        }
        if lhs.fundingOutpoint != rhs.fundingOutpoint {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fundedAt)
        hasher.combine(fundingOutpoint)
        hasher.combine(expiresAt)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1ChannelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1ChannelInfo {
        return
            try Lsps1ChannelInfo(
                fundedAt: FfiConverterTypeLSPSDateTime.read(from: &buf),
                fundingOutpoint: FfiConverterTypeOutPoint.read(from: &buf),
                expiresAt: FfiConverterTypeLSPSDateTime.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1ChannelInfo, into buf: inout [UInt8]) {
        FfiConverterTypeLSPSDateTime.write(value.fundedAt, into: &buf)
        FfiConverterTypeOutPoint.write(value.fundingOutpoint, into: &buf)
        FfiConverterTypeLSPSDateTime.write(value.expiresAt, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1ChannelInfo_lift(_ buf: RustBuffer) throws -> Lsps1ChannelInfo {
    return try FfiConverterTypeLSPS1ChannelInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1ChannelInfo_lower(_ value: Lsps1ChannelInfo) -> RustBuffer {
    return FfiConverterTypeLSPS1ChannelInfo.lower(value)
}

public struct Lsps1OnchainPaymentInfo {
    public var state: Lsps1PaymentState
    public var expiresAt: LspsDateTime
    public var feeTotalSat: UInt64
    public var orderTotalSat: UInt64
    public var address: Address
    public var minOnchainPaymentConfirmations: UInt16?
    public var minFeeFor0conf: FeeRate
    public var refundOnchainAddress: Address?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: Lsps1PaymentState, expiresAt: LspsDateTime, feeTotalSat: UInt64, orderTotalSat: UInt64, address: Address, minOnchainPaymentConfirmations: UInt16?, minFeeFor0conf: FeeRate, refundOnchainAddress: Address?) {
        self.state = state
        self.expiresAt = expiresAt
        self.feeTotalSat = feeTotalSat
        self.orderTotalSat = orderTotalSat
        self.address = address
        self.minOnchainPaymentConfirmations = minOnchainPaymentConfirmations
        self.minFeeFor0conf = minFeeFor0conf
        self.refundOnchainAddress = refundOnchainAddress
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1OnchainPaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1OnchainPaymentInfo {
        return
            try Lsps1OnchainPaymentInfo(
                state: FfiConverterTypeLSPS1PaymentState.read(from: &buf),
                expiresAt: FfiConverterTypeLSPSDateTime.read(from: &buf),
                feeTotalSat: FfiConverterUInt64.read(from: &buf),
                orderTotalSat: FfiConverterUInt64.read(from: &buf),
                address: FfiConverterTypeAddress.read(from: &buf),
                minOnchainPaymentConfirmations: FfiConverterOptionUInt16.read(from: &buf),
                minFeeFor0conf: FfiConverterTypeFeeRate.read(from: &buf),
                refundOnchainAddress: FfiConverterOptionTypeAddress.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1OnchainPaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypeLSPS1PaymentState.write(value.state, into: &buf)
        FfiConverterTypeLSPSDateTime.write(value.expiresAt, into: &buf)
        FfiConverterUInt64.write(value.feeTotalSat, into: &buf)
        FfiConverterUInt64.write(value.orderTotalSat, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterOptionUInt16.write(value.minOnchainPaymentConfirmations, into: &buf)
        FfiConverterTypeFeeRate.write(value.minFeeFor0conf, into: &buf)
        FfiConverterOptionTypeAddress.write(value.refundOnchainAddress, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OnchainPaymentInfo_lift(_ buf: RustBuffer) throws -> Lsps1OnchainPaymentInfo {
    return try FfiConverterTypeLSPS1OnchainPaymentInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OnchainPaymentInfo_lower(_ value: Lsps1OnchainPaymentInfo) -> RustBuffer {
    return FfiConverterTypeLSPS1OnchainPaymentInfo.lower(value)
}

public struct Lsps1OrderParams {
    public var lspBalanceSat: UInt64
    public var clientBalanceSat: UInt64
    public var requiredChannelConfirmations: UInt16
    public var fundingConfirmsWithinBlocks: UInt16
    public var channelExpiryBlocks: UInt32
    public var token: String?
    public var announceChannel: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lspBalanceSat: UInt64, clientBalanceSat: UInt64, requiredChannelConfirmations: UInt16, fundingConfirmsWithinBlocks: UInt16, channelExpiryBlocks: UInt32, token: String?, announceChannel: Bool) {
        self.lspBalanceSat = lspBalanceSat
        self.clientBalanceSat = clientBalanceSat
        self.requiredChannelConfirmations = requiredChannelConfirmations
        self.fundingConfirmsWithinBlocks = fundingConfirmsWithinBlocks
        self.channelExpiryBlocks = channelExpiryBlocks
        self.token = token
        self.announceChannel = announceChannel
    }
}

extension Lsps1OrderParams: Equatable, Hashable {
    public static func == (lhs: Lsps1OrderParams, rhs: Lsps1OrderParams) -> Bool {
        if lhs.lspBalanceSat != rhs.lspBalanceSat {
            return false
        }
        if lhs.clientBalanceSat != rhs.clientBalanceSat {
            return false
        }
        if lhs.requiredChannelConfirmations != rhs.requiredChannelConfirmations {
            return false
        }
        if lhs.fundingConfirmsWithinBlocks != rhs.fundingConfirmsWithinBlocks {
            return false
        }
        if lhs.channelExpiryBlocks != rhs.channelExpiryBlocks {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        if lhs.announceChannel != rhs.announceChannel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lspBalanceSat)
        hasher.combine(clientBalanceSat)
        hasher.combine(requiredChannelConfirmations)
        hasher.combine(fundingConfirmsWithinBlocks)
        hasher.combine(channelExpiryBlocks)
        hasher.combine(token)
        hasher.combine(announceChannel)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1OrderParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1OrderParams {
        return
            try Lsps1OrderParams(
                lspBalanceSat: FfiConverterUInt64.read(from: &buf),
                clientBalanceSat: FfiConverterUInt64.read(from: &buf),
                requiredChannelConfirmations: FfiConverterUInt16.read(from: &buf),
                fundingConfirmsWithinBlocks: FfiConverterUInt16.read(from: &buf),
                channelExpiryBlocks: FfiConverterUInt32.read(from: &buf),
                token: FfiConverterOptionString.read(from: &buf),
                announceChannel: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1OrderParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.lspBalanceSat, into: &buf)
        FfiConverterUInt64.write(value.clientBalanceSat, into: &buf)
        FfiConverterUInt16.write(value.requiredChannelConfirmations, into: &buf)
        FfiConverterUInt16.write(value.fundingConfirmsWithinBlocks, into: &buf)
        FfiConverterUInt32.write(value.channelExpiryBlocks, into: &buf)
        FfiConverterOptionString.write(value.token, into: &buf)
        FfiConverterBool.write(value.announceChannel, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderParams_lift(_ buf: RustBuffer) throws -> Lsps1OrderParams {
    return try FfiConverterTypeLSPS1OrderParams.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderParams_lower(_ value: Lsps1OrderParams) -> RustBuffer {
    return FfiConverterTypeLSPS1OrderParams.lower(value)
}

public struct Lsps1OrderStatus {
    public var orderId: Lsps1OrderId
    public var orderParams: Lsps1OrderParams
    public var paymentOptions: Lsps1PaymentInfo
    public var channelState: Lsps1ChannelInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(orderId: Lsps1OrderId, orderParams: Lsps1OrderParams, paymentOptions: Lsps1PaymentInfo, channelState: Lsps1ChannelInfo?) {
        self.orderId = orderId
        self.orderParams = orderParams
        self.paymentOptions = paymentOptions
        self.channelState = channelState
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1OrderStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1OrderStatus {
        return
            try Lsps1OrderStatus(
                orderId: FfiConverterTypeLSPS1OrderId.read(from: &buf),
                orderParams: FfiConverterTypeLSPS1OrderParams.read(from: &buf),
                paymentOptions: FfiConverterTypeLSPS1PaymentInfo.read(from: &buf),
                channelState: FfiConverterOptionTypeLSPS1ChannelInfo.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1OrderStatus, into buf: inout [UInt8]) {
        FfiConverterTypeLSPS1OrderId.write(value.orderId, into: &buf)
        FfiConverterTypeLSPS1OrderParams.write(value.orderParams, into: &buf)
        FfiConverterTypeLSPS1PaymentInfo.write(value.paymentOptions, into: &buf)
        FfiConverterOptionTypeLSPS1ChannelInfo.write(value.channelState, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderStatus_lift(_ buf: RustBuffer) throws -> Lsps1OrderStatus {
    return try FfiConverterTypeLSPS1OrderStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderStatus_lower(_ value: Lsps1OrderStatus) -> RustBuffer {
    return FfiConverterTypeLSPS1OrderStatus.lower(value)
}

public struct Lsps1PaymentInfo {
    public var bolt11: Lsps1Bolt11PaymentInfo?
    public var onchain: Lsps1OnchainPaymentInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: Lsps1Bolt11PaymentInfo?, onchain: Lsps1OnchainPaymentInfo?) {
        self.bolt11 = bolt11
        self.onchain = onchain
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1PaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1PaymentInfo {
        return
            try Lsps1PaymentInfo(
                bolt11: FfiConverterOptionTypeLSPS1Bolt11PaymentInfo.read(from: &buf),
                onchain: FfiConverterOptionTypeLSPS1OnchainPaymentInfo.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps1PaymentInfo, into buf: inout [UInt8]) {
        FfiConverterOptionTypeLSPS1Bolt11PaymentInfo.write(value.bolt11, into: &buf)
        FfiConverterOptionTypeLSPS1OnchainPaymentInfo.write(value.onchain, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1PaymentInfo_lift(_ buf: RustBuffer) throws -> Lsps1PaymentInfo {
    return try FfiConverterTypeLSPS1PaymentInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1PaymentInfo_lower(_ value: Lsps1PaymentInfo) -> RustBuffer {
    return FfiConverterTypeLSPS1PaymentInfo.lower(value)
}

public struct Lsps2ServiceConfig {
    public var requireToken: String?
    public var advertiseService: Bool
    public var channelOpeningFeePpm: UInt32
    public var channelOverProvisioningPpm: UInt32
    public var minChannelOpeningFeeMsat: UInt64
    public var minChannelLifetime: UInt32
    public var maxClientToSelfDelay: UInt32
    public var minPaymentSizeMsat: UInt64
    public var maxPaymentSizeMsat: UInt64
    public var clientTrustsLsp: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requireToken: String?, advertiseService: Bool, channelOpeningFeePpm: UInt32, channelOverProvisioningPpm: UInt32, minChannelOpeningFeeMsat: UInt64, minChannelLifetime: UInt32, maxClientToSelfDelay: UInt32, minPaymentSizeMsat: UInt64, maxPaymentSizeMsat: UInt64, clientTrustsLsp: Bool) {
        self.requireToken = requireToken
        self.advertiseService = advertiseService
        self.channelOpeningFeePpm = channelOpeningFeePpm
        self.channelOverProvisioningPpm = channelOverProvisioningPpm
        self.minChannelOpeningFeeMsat = minChannelOpeningFeeMsat
        self.minChannelLifetime = minChannelLifetime
        self.maxClientToSelfDelay = maxClientToSelfDelay
        self.minPaymentSizeMsat = minPaymentSizeMsat
        self.maxPaymentSizeMsat = maxPaymentSizeMsat
        self.clientTrustsLsp = clientTrustsLsp
    }
}

extension Lsps2ServiceConfig: Equatable, Hashable {
    public static func == (lhs: Lsps2ServiceConfig, rhs: Lsps2ServiceConfig) -> Bool {
        if lhs.requireToken != rhs.requireToken {
            return false
        }
        if lhs.advertiseService != rhs.advertiseService {
            return false
        }
        if lhs.channelOpeningFeePpm != rhs.channelOpeningFeePpm {
            return false
        }
        if lhs.channelOverProvisioningPpm != rhs.channelOverProvisioningPpm {
            return false
        }
        if lhs.minChannelOpeningFeeMsat != rhs.minChannelOpeningFeeMsat {
            return false
        }
        if lhs.minChannelLifetime != rhs.minChannelLifetime {
            return false
        }
        if lhs.maxClientToSelfDelay != rhs.maxClientToSelfDelay {
            return false
        }
        if lhs.minPaymentSizeMsat != rhs.minPaymentSizeMsat {
            return false
        }
        if lhs.maxPaymentSizeMsat != rhs.maxPaymentSizeMsat {
            return false
        }
        if lhs.clientTrustsLsp != rhs.clientTrustsLsp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requireToken)
        hasher.combine(advertiseService)
        hasher.combine(channelOpeningFeePpm)
        hasher.combine(channelOverProvisioningPpm)
        hasher.combine(minChannelOpeningFeeMsat)
        hasher.combine(minChannelLifetime)
        hasher.combine(maxClientToSelfDelay)
        hasher.combine(minPaymentSizeMsat)
        hasher.combine(maxPaymentSizeMsat)
        hasher.combine(clientTrustsLsp)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS2ServiceConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps2ServiceConfig {
        return
            try Lsps2ServiceConfig(
                requireToken: FfiConverterOptionString.read(from: &buf),
                advertiseService: FfiConverterBool.read(from: &buf),
                channelOpeningFeePpm: FfiConverterUInt32.read(from: &buf),
                channelOverProvisioningPpm: FfiConverterUInt32.read(from: &buf),
                minChannelOpeningFeeMsat: FfiConverterUInt64.read(from: &buf),
                minChannelLifetime: FfiConverterUInt32.read(from: &buf),
                maxClientToSelfDelay: FfiConverterUInt32.read(from: &buf),
                minPaymentSizeMsat: FfiConverterUInt64.read(from: &buf),
                maxPaymentSizeMsat: FfiConverterUInt64.read(from: &buf),
                clientTrustsLsp: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: Lsps2ServiceConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.requireToken, into: &buf)
        FfiConverterBool.write(value.advertiseService, into: &buf)
        FfiConverterUInt32.write(value.channelOpeningFeePpm, into: &buf)
        FfiConverterUInt32.write(value.channelOverProvisioningPpm, into: &buf)
        FfiConverterUInt64.write(value.minChannelOpeningFeeMsat, into: &buf)
        FfiConverterUInt32.write(value.minChannelLifetime, into: &buf)
        FfiConverterUInt32.write(value.maxClientToSelfDelay, into: &buf)
        FfiConverterUInt64.write(value.minPaymentSizeMsat, into: &buf)
        FfiConverterUInt64.write(value.maxPaymentSizeMsat, into: &buf)
        FfiConverterBool.write(value.clientTrustsLsp, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS2ServiceConfig_lift(_ buf: RustBuffer) throws -> Lsps2ServiceConfig {
    return try FfiConverterTypeLSPS2ServiceConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS2ServiceConfig_lower(_ value: Lsps2ServiceConfig) -> RustBuffer {
    return FfiConverterTypeLSPS2ServiceConfig.lower(value)
}

public struct LogRecord {
    public var level: LogLevel
    public var args: String
    public var modulePath: String
    public var line: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(level: LogLevel, args: String, modulePath: String, line: UInt32) {
        self.level = level
        self.args = args
        self.modulePath = modulePath
        self.line = line
    }
}

extension LogRecord: Equatable, Hashable {
    public static func == (lhs: LogRecord, rhs: LogRecord) -> Bool {
        if lhs.level != rhs.level {
            return false
        }
        if lhs.args != rhs.args {
            return false
        }
        if lhs.modulePath != rhs.modulePath {
            return false
        }
        if lhs.line != rhs.line {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(args)
        hasher.combine(modulePath)
        hasher.combine(line)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogRecord {
        return
            try LogRecord(
                level: FfiConverterTypeLogLevel.read(from: &buf),
                args: FfiConverterString.read(from: &buf),
                modulePath: FfiConverterString.read(from: &buf),
                line: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: LogRecord, into buf: inout [UInt8]) {
        FfiConverterTypeLogLevel.write(value.level, into: &buf)
        FfiConverterString.write(value.args, into: &buf)
        FfiConverterString.write(value.modulePath, into: &buf)
        FfiConverterUInt32.write(value.line, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogRecord_lift(_ buf: RustBuffer) throws -> LogRecord {
    return try FfiConverterTypeLogRecord.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogRecord_lower(_ value: LogRecord) -> RustBuffer {
    return FfiConverterTypeLogRecord.lower(value)
}

public struct NodeAnnouncementInfo {
    public var lastUpdate: UInt32
    public var alias: String
    public var addresses: [SocketAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUpdate: UInt32, alias: String, addresses: [SocketAddress]) {
        self.lastUpdate = lastUpdate
        self.alias = alias
        self.addresses = addresses
    }
}

extension NodeAnnouncementInfo: Equatable, Hashable {
    public static func == (lhs: NodeAnnouncementInfo, rhs: NodeAnnouncementInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(alias)
        hasher.combine(addresses)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAnnouncementInfo {
        return
            try NodeAnnouncementInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf),
                alias: FfiConverterString.read(from: &buf),
                addresses: FfiConverterSequenceTypeSocketAddress.read(from: &buf)
            )
    }

    public static func write(_ value: NodeAnnouncementInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterSequenceTypeSocketAddress.write(value.addresses, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeAnnouncementInfo_lift(_ buf: RustBuffer) throws -> NodeAnnouncementInfo {
    return try FfiConverterTypeNodeAnnouncementInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeAnnouncementInfo_lower(_ value: NodeAnnouncementInfo) -> RustBuffer {
    return FfiConverterTypeNodeAnnouncementInfo.lower(value)
}

public struct NodeInfo {
    public var channels: [UInt64]
    public var announcementInfo: NodeAnnouncementInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channels: [UInt64], announcementInfo: NodeAnnouncementInfo?) {
        self.channels = channels
        self.announcementInfo = announcementInfo
    }
}

extension NodeInfo: Equatable, Hashable {
    public static func == (lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.channels != rhs.channels {
            return false
        }
        if lhs.announcementInfo != rhs.announcementInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channels)
        hasher.combine(announcementInfo)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                channels: FfiConverterSequenceUInt64.read(from: &buf),
                announcementInfo: FfiConverterOptionTypeNodeAnnouncementInfo.read(from: &buf)
            )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.channels, into: &buf)
        FfiConverterOptionTypeNodeAnnouncementInfo.write(value.announcementInfo, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}

public struct NodeStatus {
    public var isRunning: Bool
    public var currentBestBlock: BestBlock
    public var latestLightningWalletSyncTimestamp: UInt64?
    public var latestOnchainWalletSyncTimestamp: UInt64?
    public var latestFeeRateCacheUpdateTimestamp: UInt64?
    public var latestRgsSnapshotTimestamp: UInt64?
    public var latestPathfindingScoresSyncTimestamp: UInt64?
    public var latestNodeAnnouncementBroadcastTimestamp: UInt64?
    public var latestChannelMonitorArchivalHeight: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRunning: Bool, currentBestBlock: BestBlock, latestLightningWalletSyncTimestamp: UInt64?, latestOnchainWalletSyncTimestamp: UInt64?, latestFeeRateCacheUpdateTimestamp: UInt64?, latestRgsSnapshotTimestamp: UInt64?, latestPathfindingScoresSyncTimestamp: UInt64?, latestNodeAnnouncementBroadcastTimestamp: UInt64?, latestChannelMonitorArchivalHeight: UInt32?) {
        self.isRunning = isRunning
        self.currentBestBlock = currentBestBlock
        self.latestLightningWalletSyncTimestamp = latestLightningWalletSyncTimestamp
        self.latestOnchainWalletSyncTimestamp = latestOnchainWalletSyncTimestamp
        self.latestFeeRateCacheUpdateTimestamp = latestFeeRateCacheUpdateTimestamp
        self.latestRgsSnapshotTimestamp = latestRgsSnapshotTimestamp
        self.latestPathfindingScoresSyncTimestamp = latestPathfindingScoresSyncTimestamp
        self.latestNodeAnnouncementBroadcastTimestamp = latestNodeAnnouncementBroadcastTimestamp
        self.latestChannelMonitorArchivalHeight = latestChannelMonitorArchivalHeight
    }
}

extension NodeStatus: Equatable, Hashable {
    public static func == (lhs: NodeStatus, rhs: NodeStatus) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.currentBestBlock != rhs.currentBestBlock {
            return false
        }
        if lhs.latestLightningWalletSyncTimestamp != rhs.latestLightningWalletSyncTimestamp {
            return false
        }
        if lhs.latestOnchainWalletSyncTimestamp != rhs.latestOnchainWalletSyncTimestamp {
            return false
        }
        if lhs.latestFeeRateCacheUpdateTimestamp != rhs.latestFeeRateCacheUpdateTimestamp {
            return false
        }
        if lhs.latestRgsSnapshotTimestamp != rhs.latestRgsSnapshotTimestamp {
            return false
        }
        if lhs.latestPathfindingScoresSyncTimestamp != rhs.latestPathfindingScoresSyncTimestamp {
            return false
        }
        if lhs.latestNodeAnnouncementBroadcastTimestamp != rhs.latestNodeAnnouncementBroadcastTimestamp {
            return false
        }
        if lhs.latestChannelMonitorArchivalHeight != rhs.latestChannelMonitorArchivalHeight {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(currentBestBlock)
        hasher.combine(latestLightningWalletSyncTimestamp)
        hasher.combine(latestOnchainWalletSyncTimestamp)
        hasher.combine(latestFeeRateCacheUpdateTimestamp)
        hasher.combine(latestRgsSnapshotTimestamp)
        hasher.combine(latestPathfindingScoresSyncTimestamp)
        hasher.combine(latestNodeAnnouncementBroadcastTimestamp)
        hasher.combine(latestChannelMonitorArchivalHeight)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatus {
        return
            try NodeStatus(
                isRunning: FfiConverterBool.read(from: &buf),
                currentBestBlock: FfiConverterTypeBestBlock.read(from: &buf),
                latestLightningWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestOnchainWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestFeeRateCacheUpdateTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestRgsSnapshotTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestPathfindingScoresSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestNodeAnnouncementBroadcastTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestChannelMonitorArchivalHeight: FfiConverterOptionUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: NodeStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterTypeBestBlock.write(value.currentBestBlock, into: &buf)
        FfiConverterOptionUInt64.write(value.latestLightningWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestOnchainWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestFeeRateCacheUpdateTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestRgsSnapshotTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestPathfindingScoresSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestNodeAnnouncementBroadcastTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.latestChannelMonitorArchivalHeight, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeStatus_lift(_ buf: RustBuffer) throws -> NodeStatus {
    return try FfiConverterTypeNodeStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeStatus_lower(_ value: NodeStatus) -> RustBuffer {
    return FfiConverterTypeNodeStatus.lower(value)
}

public struct OutPoint {
    public var txid: Txid
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: Txid, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}

extension OutPoint: Equatable, Hashable {
    public static func == (lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterTypeTxid.read(from: &buf),
                vout: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}

public struct PaymentDetails {
    public var id: PaymentId
    public var kind: PaymentKind
    public var amountMsat: UInt64?
    public var feePaidMsat: UInt64?
    public var direction: PaymentDirection
    public var status: PaymentStatus
    public var latestUpdateTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PaymentId, kind: PaymentKind, amountMsat: UInt64?, feePaidMsat: UInt64?, direction: PaymentDirection, status: PaymentStatus, latestUpdateTimestamp: UInt64) {
        self.id = id
        self.kind = kind
        self.amountMsat = amountMsat
        self.feePaidMsat = feePaidMsat
        self.direction = direction
        self.status = status
        self.latestUpdateTimestamp = latestUpdateTimestamp
    }
}

extension PaymentDetails: Equatable, Hashable {
    public static func == (lhs: PaymentDetails, rhs: PaymentDetails) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.feePaidMsat != rhs.feePaidMsat {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.latestUpdateTimestamp != rhs.latestUpdateTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(kind)
        hasher.combine(amountMsat)
        hasher.combine(feePaidMsat)
        hasher.combine(direction)
        hasher.combine(status)
        hasher.combine(latestUpdateTimestamp)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        return
            try PaymentDetails(
                id: FfiConverterTypePaymentId.read(from: &buf),
                kind: FfiConverterTypePaymentKind.read(from: &buf),
                amountMsat: FfiConverterOptionUInt64.read(from: &buf),
                feePaidMsat: FfiConverterOptionUInt64.read(from: &buf),
                direction: FfiConverterTypePaymentDirection.read(from: &buf),
                status: FfiConverterTypePaymentStatus.read(from: &buf),
                latestUpdateTimestamp: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        FfiConverterTypePaymentId.write(value.id, into: &buf)
        FfiConverterTypePaymentKind.write(value.kind, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.feePaidMsat, into: &buf)
        FfiConverterTypePaymentDirection.write(value.direction, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.latestUpdateTimestamp, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}

public struct PeerDetails {
    public var nodeId: PublicKey
    public var address: SocketAddress
    public var isPersisted: Bool
    public var isConnected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeId: PublicKey, address: SocketAddress, isPersisted: Bool, isConnected: Bool) {
        self.nodeId = nodeId
        self.address = address
        self.isPersisted = isPersisted
        self.isConnected = isConnected
    }
}

extension PeerDetails: Equatable, Hashable {
    public static func == (lhs: PeerDetails, rhs: PeerDetails) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.isPersisted != rhs.isPersisted {
            return false
        }
        if lhs.isConnected != rhs.isConnected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(address)
        hasher.combine(isPersisted)
        hasher.combine(isConnected)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePeerDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerDetails {
        return
            try PeerDetails(
                nodeId: FfiConverterTypePublicKey.read(from: &buf),
                address: FfiConverterTypeSocketAddress.read(from: &buf),
                isPersisted: FfiConverterBool.read(from: &buf),
                isConnected: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: PeerDetails, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.nodeId, into: &buf)
        FfiConverterTypeSocketAddress.write(value.address, into: &buf)
        FfiConverterBool.write(value.isPersisted, into: &buf)
        FfiConverterBool.write(value.isConnected, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePeerDetails_lift(_ buf: RustBuffer) throws -> PeerDetails {
    return try FfiConverterTypePeerDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePeerDetails_lower(_ value: PeerDetails) -> RustBuffer {
    return FfiConverterTypePeerDetails.lower(value)
}

public struct RouteHintHop {
    public var srcNodeId: PublicKey
    public var shortChannelId: UInt64
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64?
    public var htlcMaximumMsat: UInt64?
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(srcNodeId: PublicKey, shortChannelId: UInt64, cltvExpiryDelta: UInt16, htlcMinimumMsat: UInt64?, htlcMaximumMsat: UInt64?, fees: RoutingFees) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}

extension RouteHintHop: Equatable, Hashable {
    public static func == (lhs: RouteHintHop, rhs: RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHintHop {
        return
            try RouteHintHop(
                srcNodeId: FfiConverterTypePublicKey.read(from: &buf),
                shortChannelId: FfiConverterUInt64.read(from: &buf),
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf),
                htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf),
                htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf),
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
            )
    }

    public static func write(_ value: RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.srcNodeId, into: &buf)
        FfiConverterUInt64.write(value.shortChannelId, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteHintHop_lift(_ buf: RustBuffer) throws -> RouteHintHop {
    return try FfiConverterTypeRouteHintHop.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteHintHop_lower(_ value: RouteHintHop) -> RustBuffer {
    return FfiConverterTypeRouteHintHop.lower(value)
}

public struct RouteParametersConfig {
    public var maxTotalRoutingFeeMsat: UInt64?
    public var maxTotalCltvExpiryDelta: UInt32
    public var maxPathCount: UInt8
    public var maxChannelSaturationPowerOfHalf: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxTotalRoutingFeeMsat: UInt64?, maxTotalCltvExpiryDelta: UInt32, maxPathCount: UInt8, maxChannelSaturationPowerOfHalf: UInt8) {
        self.maxTotalRoutingFeeMsat = maxTotalRoutingFeeMsat
        self.maxTotalCltvExpiryDelta = maxTotalCltvExpiryDelta
        self.maxPathCount = maxPathCount
        self.maxChannelSaturationPowerOfHalf = maxChannelSaturationPowerOfHalf
    }
}

extension RouteParametersConfig: Equatable, Hashable {
    public static func == (lhs: RouteParametersConfig, rhs: RouteParametersConfig) -> Bool {
        if lhs.maxTotalRoutingFeeMsat != rhs.maxTotalRoutingFeeMsat {
            return false
        }
        if lhs.maxTotalCltvExpiryDelta != rhs.maxTotalCltvExpiryDelta {
            return false
        }
        if lhs.maxPathCount != rhs.maxPathCount {
            return false
        }
        if lhs.maxChannelSaturationPowerOfHalf != rhs.maxChannelSaturationPowerOfHalf {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalRoutingFeeMsat)
        hasher.combine(maxTotalCltvExpiryDelta)
        hasher.combine(maxPathCount)
        hasher.combine(maxChannelSaturationPowerOfHalf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRouteParametersConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteParametersConfig {
        return
            try RouteParametersConfig(
                maxTotalRoutingFeeMsat: FfiConverterOptionUInt64.read(from: &buf),
                maxTotalCltvExpiryDelta: FfiConverterUInt32.read(from: &buf),
                maxPathCount: FfiConverterUInt8.read(from: &buf),
                maxChannelSaturationPowerOfHalf: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: RouteParametersConfig, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxTotalRoutingFeeMsat, into: &buf)
        FfiConverterUInt32.write(value.maxTotalCltvExpiryDelta, into: &buf)
        FfiConverterUInt8.write(value.maxPathCount, into: &buf)
        FfiConverterUInt8.write(value.maxChannelSaturationPowerOfHalf, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteParametersConfig_lift(_ buf: RustBuffer) throws -> RouteParametersConfig {
    return try FfiConverterTypeRouteParametersConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRouteParametersConfig_lower(_ value: RouteParametersConfig) -> RustBuffer {
    return FfiConverterTypeRouteParametersConfig.lower(value)
}

public struct RoutingFees {
    public var baseMsat: UInt32
    public var proportionalMillionths: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseMsat: UInt32, proportionalMillionths: UInt32) {
        self.baseMsat = baseMsat
        self.proportionalMillionths = proportionalMillionths
    }
}

extension RoutingFees: Equatable, Hashable {
    public static func == (lhs: RoutingFees, rhs: RoutingFees) -> Bool {
        if lhs.baseMsat != rhs.baseMsat {
            return false
        }
        if lhs.proportionalMillionths != rhs.proportionalMillionths {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseMsat)
        hasher.combine(proportionalMillionths)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoutingFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoutingFees {
        return
            try RoutingFees(
                baseMsat: FfiConverterUInt32.read(from: &buf),
                proportionalMillionths: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: RoutingFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.baseMsat, into: &buf)
        FfiConverterUInt32.write(value.proportionalMillionths, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRoutingFees_lift(_ buf: RustBuffer) throws -> RoutingFees {
    return try FfiConverterTypeRoutingFees.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRoutingFees_lower(_ value: RoutingFees) -> RustBuffer {
    return FfiConverterTypeRoutingFees.lower(value)
}

public struct RuntimeSyncIntervals {
    public var onchainWalletSyncIntervalSecs: UInt64
    public var lightningWalletSyncIntervalSecs: UInt64
    public var feeRateCacheUpdateIntervalSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(onchainWalletSyncIntervalSecs: UInt64, lightningWalletSyncIntervalSecs: UInt64, feeRateCacheUpdateIntervalSecs: UInt64) {
        self.onchainWalletSyncIntervalSecs = onchainWalletSyncIntervalSecs
        self.lightningWalletSyncIntervalSecs = lightningWalletSyncIntervalSecs
        self.feeRateCacheUpdateIntervalSecs = feeRateCacheUpdateIntervalSecs
    }
}

extension RuntimeSyncIntervals: Equatable, Hashable {
    public static func == (lhs: RuntimeSyncIntervals, rhs: RuntimeSyncIntervals) -> Bool {
        if lhs.onchainWalletSyncIntervalSecs != rhs.onchainWalletSyncIntervalSecs {
            return false
        }
        if lhs.lightningWalletSyncIntervalSecs != rhs.lightningWalletSyncIntervalSecs {
            return false
        }
        if lhs.feeRateCacheUpdateIntervalSecs != rhs.feeRateCacheUpdateIntervalSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onchainWalletSyncIntervalSecs)
        hasher.combine(lightningWalletSyncIntervalSecs)
        hasher.combine(feeRateCacheUpdateIntervalSecs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRuntimeSyncIntervals: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuntimeSyncIntervals {
        return
            try RuntimeSyncIntervals(
                onchainWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                lightningWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                feeRateCacheUpdateIntervalSecs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: RuntimeSyncIntervals, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.onchainWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.lightningWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.feeRateCacheUpdateIntervalSecs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRuntimeSyncIntervals_lift(_ buf: RustBuffer) throws -> RuntimeSyncIntervals {
    return try FfiConverterTypeRuntimeSyncIntervals.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeRuntimeSyncIntervals_lower(_ value: RuntimeSyncIntervals) -> RustBuffer {
    return FfiConverterTypeRuntimeSyncIntervals.lower(value)
}

public struct SpendableUtxo {
    public var outpoint: OutPoint
    public var valueSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(outpoint: OutPoint, valueSats: UInt64) {
        self.outpoint = outpoint
        self.valueSats = valueSats
    }
}

extension SpendableUtxo: Equatable, Hashable {
    public static func == (lhs: SpendableUtxo, rhs: SpendableUtxo) -> Bool {
        if lhs.outpoint != rhs.outpoint {
            return false
        }
        if lhs.valueSats != rhs.valueSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(outpoint)
        hasher.combine(valueSats)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpendableUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpendableUtxo {
        return
            try SpendableUtxo(
                outpoint: FfiConverterTypeOutPoint.read(from: &buf),
                valueSats: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: SpendableUtxo, into buf: inout [UInt8]) {
        FfiConverterTypeOutPoint.write(value.outpoint, into: &buf)
        FfiConverterUInt64.write(value.valueSats, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendableUtxo_lift(_ buf: RustBuffer) throws -> SpendableUtxo {
    return try FfiConverterTypeSpendableUtxo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSpendableUtxo_lower(_ value: SpendableUtxo) -> RustBuffer {
    return FfiConverterTypeSpendableUtxo.lower(value)
}

public struct TransactionDetails {
    public var amountSats: Int64
    public var inputs: [TxInput]
    public var outputs: [TxOutput]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amountSats: Int64, inputs: [TxInput], outputs: [TxOutput]) {
        self.amountSats = amountSats
        self.inputs = inputs
        self.outputs = outputs
    }
}

extension TransactionDetails: Equatable, Hashable {
    public static func == (lhs: TransactionDetails, rhs: TransactionDetails) -> Bool {
        if lhs.amountSats != rhs.amountSats {
            return false
        }
        if lhs.inputs != rhs.inputs {
            return false
        }
        if lhs.outputs != rhs.outputs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amountSats)
        hasher.combine(inputs)
        hasher.combine(outputs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionDetails {
        return
            try TransactionDetails(
                amountSats: FfiConverterInt64.read(from: &buf),
                inputs: FfiConverterSequenceTypeTxInput.read(from: &buf),
                outputs: FfiConverterSequenceTypeTxOutput.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionDetails, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.amountSats, into: &buf)
        FfiConverterSequenceTypeTxInput.write(value.inputs, into: &buf)
        FfiConverterSequenceTypeTxOutput.write(value.outputs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lift(_ buf: RustBuffer) throws -> TransactionDetails {
    return try FfiConverterTypeTransactionDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionDetails_lower(_ value: TransactionDetails) -> RustBuffer {
    return FfiConverterTypeTransactionDetails.lower(value)
}

public struct TxInput {
    public var txid: Txid
    public var vout: UInt32
    public var scriptsig: String
    public var witness: [String]
    public var sequence: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: Txid, vout: UInt32, scriptsig: String, witness: [String], sequence: UInt32) {
        self.txid = txid
        self.vout = vout
        self.scriptsig = scriptsig
        self.witness = witness
        self.sequence = sequence
    }
}

extension TxInput: Equatable, Hashable {
    public static func == (lhs: TxInput, rhs: TxInput) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        if lhs.scriptsig != rhs.scriptsig {
            return false
        }
        if lhs.witness != rhs.witness {
            return false
        }
        if lhs.sequence != rhs.sequence {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
        hasher.combine(scriptsig)
        hasher.combine(witness)
        hasher.combine(sequence)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxInput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxInput {
        return
            try TxInput(
                txid: FfiConverterTypeTxid.read(from: &buf),
                vout: FfiConverterUInt32.read(from: &buf),
                scriptsig: FfiConverterString.read(from: &buf),
                witness: FfiConverterSequenceString.read(from: &buf),
                sequence: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: TxInput, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
        FfiConverterString.write(value.scriptsig, into: &buf)
        FfiConverterSequenceString.write(value.witness, into: &buf)
        FfiConverterUInt32.write(value.sequence, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxInput_lift(_ buf: RustBuffer) throws -> TxInput {
    return try FfiConverterTypeTxInput.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxInput_lower(_ value: TxInput) -> RustBuffer {
    return FfiConverterTypeTxInput.lower(value)
}

public struct TxOutput {
    public var scriptpubkey: String
    public var scriptpubkeyType: String?
    public var scriptpubkeyAddress: String?
    public var value: Int64
    public var n: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(scriptpubkey: String, scriptpubkeyType: String?, scriptpubkeyAddress: String?, value: Int64, n: UInt32) {
        self.scriptpubkey = scriptpubkey
        self.scriptpubkeyType = scriptpubkeyType
        self.scriptpubkeyAddress = scriptpubkeyAddress
        self.value = value
        self.n = n
    }
}

extension TxOutput: Equatable, Hashable {
    public static func == (lhs: TxOutput, rhs: TxOutput) -> Bool {
        if lhs.scriptpubkey != rhs.scriptpubkey {
            return false
        }
        if lhs.scriptpubkeyType != rhs.scriptpubkeyType {
            return false
        }
        if lhs.scriptpubkeyAddress != rhs.scriptpubkeyAddress {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.n != rhs.n {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(scriptpubkey)
        hasher.combine(scriptpubkeyType)
        hasher.combine(scriptpubkeyAddress)
        hasher.combine(value)
        hasher.combine(n)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxOutput {
        return
            try TxOutput(
                scriptpubkey: FfiConverterString.read(from: &buf),
                scriptpubkeyType: FfiConverterOptionString.read(from: &buf),
                scriptpubkeyAddress: FfiConverterOptionString.read(from: &buf),
                value: FfiConverterInt64.read(from: &buf),
                n: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: TxOutput, into buf: inout [UInt8]) {
        FfiConverterString.write(value.scriptpubkey, into: &buf)
        FfiConverterOptionString.write(value.scriptpubkeyType, into: &buf)
        FfiConverterOptionString.write(value.scriptpubkeyAddress, into: &buf)
        FfiConverterInt64.write(value.value, into: &buf)
        FfiConverterUInt32.write(value.n, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOutput_lift(_ buf: RustBuffer) throws -> TxOutput {
    return try FfiConverterTypeTxOutput.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxOutput_lower(_ value: TxOutput) -> RustBuffer {
    return FfiConverterTypeTxOutput.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AsyncPaymentsRole {
    case client
    case server
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAsyncPaymentsRole: FfiConverterRustBuffer {
    typealias SwiftType = AsyncPaymentsRole

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AsyncPaymentsRole {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .client

        case 2: return .server

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AsyncPaymentsRole, into buf: inout [UInt8]) {
        switch value {
        case .client:
            writeInt(&buf, Int32(1))

        case .server:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAsyncPaymentsRole_lift(_ buf: RustBuffer) throws -> AsyncPaymentsRole {
    return try FfiConverterTypeAsyncPaymentsRole.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAsyncPaymentsRole_lower(_ value: AsyncPaymentsRole) -> RustBuffer {
    return FfiConverterTypeAsyncPaymentsRole.lower(value)
}

extension AsyncPaymentsRole: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BalanceSource {
    case holderForceClosed
    case counterpartyForceClosed
    case coopClose
    case htlc
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalanceSource: FfiConverterRustBuffer {
    typealias SwiftType = BalanceSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .holderForceClosed

        case 2: return .counterpartyForceClosed

        case 3: return .coopClose

        case 4: return .htlc

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BalanceSource, into buf: inout [UInt8]) {
        switch value {
        case .holderForceClosed:
            writeInt(&buf, Int32(1))

        case .counterpartyForceClosed:
            writeInt(&buf, Int32(2))

        case .coopClose:
            writeInt(&buf, Int32(3))

        case .htlc:
            writeInt(&buf, Int32(4))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBalanceSource_lift(_ buf: RustBuffer) throws -> BalanceSource {
    return try FfiConverterTypeBalanceSource.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBalanceSource_lower(_ value: BalanceSource) -> RustBuffer {
    return FfiConverterTypeBalanceSource.lower(value)
}

extension BalanceSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Bolt11InvoiceDescription {
    case hash(hash: String
    )
    case direct(description: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBolt11InvoiceDescription: FfiConverterRustBuffer {
    typealias SwiftType = Bolt11InvoiceDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11InvoiceDescription {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hash(hash: FfiConverterString.read(from: &buf)
            )

        case 2: return try .direct(description: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bolt11InvoiceDescription, into buf: inout [UInt8]) {
        switch value {
        case let .hash(hash):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(hash, into: &buf)

        case let .direct(description):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(description, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDescription_lift(_ buf: RustBuffer) throws -> Bolt11InvoiceDescription {
    return try FfiConverterTypeBolt11InvoiceDescription.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBolt11InvoiceDescription_lower(_ value: Bolt11InvoiceDescription) -> RustBuffer {
    return FfiConverterTypeBolt11InvoiceDescription.lower(value)
}

extension Bolt11InvoiceDescription: Equatable, Hashable {}

public enum BuildError {
    case InvalidSeedBytes(message: String)

    case InvalidSeedFile(message: String)

    case InvalidSystemTime(message: String)

    case InvalidChannelMonitor(message: String)

    case InvalidListeningAddresses(message: String)

    case InvalidAnnouncementAddresses(message: String)

    case InvalidNodeAlias(message: String)

    case RuntimeSetupFailed(message: String)

    case ReadFailed(message: String)

    case WriteFailed(message: String)

    case StoragePathAccessFailed(message: String)

    case KvStoreSetupFailed(message: String)

    case WalletSetupFailed(message: String)

    case LoggerSetupFailed(message: String)

    case NetworkMismatch(message: String)

    case AsyncPaymentsConfigMismatch(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBuildError: FfiConverterRustBuffer {
    typealias SwiftType = BuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .InvalidSeedBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .InvalidSeedFile(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .InvalidSystemTime(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InvalidChannelMonitor(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvalidListeningAddresses(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .InvalidAnnouncementAddresses(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .InvalidNodeAlias(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .RuntimeSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .ReadFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .WriteFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .StoragePathAccessFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .KvStoreSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .WalletSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .LoggerSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .NetworkMismatch(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .AsyncPaymentsConfigMismatch(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuildError, into buf: inout [UInt8]) {
        switch value {
        case .InvalidSeedBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .InvalidSeedFile(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .InvalidSystemTime(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .InvalidChannelMonitor(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvalidListeningAddresses(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .InvalidAnnouncementAddresses(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .InvalidNodeAlias(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .RuntimeSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .ReadFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .WriteFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .StoragePathAccessFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .KvStoreSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        case .WalletSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(13))
        case .LoggerSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(14))
        case .NetworkMismatch(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(15))
        case .AsyncPaymentsConfigMismatch(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(16))
        }
    }
}

extension BuildError: Equatable, Hashable {}

extension BuildError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ClosureReason {
    case counterpartyForceClosed(peerMsg: UntrustedString
    )
    case holderForceClosed(broadcastedLatestTxn: Bool?, message: String)
    case legacyCooperativeClosure
    case counterpartyInitiatedCooperativeClosure
    case locallyInitiatedCooperativeClosure
    case commitmentTxConfirmed
    case fundingTimedOut
    case processingError(err: String
    )
    case disconnectedPeer
    case outdatedChannelManager
    case counterpartyCoopClosedUnfundedChannel
    case locallyCoopClosedUnfundedChannel
    case fundingBatchClosure
    case htlCsTimedOut(paymentHash: PaymentHash?
    )
    case peerFeerateTooLow(peerFeerateSatPerKw: UInt32, requiredFeerateSatPerKw: UInt32)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .counterpartyForceClosed(peerMsg: FfiConverterTypeUntrustedString.read(from: &buf)
            )

        case 2: return try .holderForceClosed(broadcastedLatestTxn: FfiConverterOptionBool.read(from: &buf), message: FfiConverterString.read(from: &buf))

        case 3: return .legacyCooperativeClosure

        case 4: return .counterpartyInitiatedCooperativeClosure

        case 5: return .locallyInitiatedCooperativeClosure

        case 6: return .commitmentTxConfirmed

        case 7: return .fundingTimedOut

        case 8: return try .processingError(err: FfiConverterString.read(from: &buf)
            )

        case 9: return .disconnectedPeer

        case 10: return .outdatedChannelManager

        case 11: return .counterpartyCoopClosedUnfundedChannel

        case 12: return .locallyCoopClosedUnfundedChannel

        case 13: return .fundingBatchClosure

        case 14: return try .htlCsTimedOut(paymentHash: FfiConverterOptionTypePaymentHash.read(from: &buf)
            )

        case 15: return try .peerFeerateTooLow(peerFeerateSatPerKw: FfiConverterUInt32.read(from: &buf), requiredFeerateSatPerKw: FfiConverterUInt32.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClosureReason, into buf: inout [UInt8]) {
        switch value {
        case let .counterpartyForceClosed(peerMsg):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUntrustedString.write(peerMsg, into: &buf)

        case let .holderForceClosed(broadcastedLatestTxn, message):
            writeInt(&buf, Int32(2))
            FfiConverterOptionBool.write(broadcastedLatestTxn, into: &buf)
            FfiConverterString.write(message, into: &buf)

        case .legacyCooperativeClosure:
            writeInt(&buf, Int32(3))

        case .counterpartyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(4))

        case .locallyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(5))

        case .commitmentTxConfirmed:
            writeInt(&buf, Int32(6))

        case .fundingTimedOut:
            writeInt(&buf, Int32(7))

        case let .processingError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)

        case .disconnectedPeer:
            writeInt(&buf, Int32(9))

        case .outdatedChannelManager:
            writeInt(&buf, Int32(10))

        case .counterpartyCoopClosedUnfundedChannel:
            writeInt(&buf, Int32(11))

        case .locallyCoopClosedUnfundedChannel:
            writeInt(&buf, Int32(12))

        case .fundingBatchClosure:
            writeInt(&buf, Int32(13))

        case let .htlCsTimedOut(paymentHash):
            writeInt(&buf, Int32(14))
            FfiConverterOptionTypePaymentHash.write(paymentHash, into: &buf)

        case let .peerFeerateTooLow(peerFeerateSatPerKw, requiredFeerateSatPerKw):
            writeInt(&buf, Int32(15))
            FfiConverterUInt32.write(peerFeerateSatPerKw, into: &buf)
            FfiConverterUInt32.write(requiredFeerateSatPerKw, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClosureReason_lift(_ buf: RustBuffer) throws -> ClosureReason {
    return try FfiConverterTypeClosureReason.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClosureReason_lower(_ value: ClosureReason) -> RustBuffer {
    return FfiConverterTypeClosureReason.lower(value)
}

extension ClosureReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CoinSelectionAlgorithm {
    case branchAndBound
    case largestFirst
    case oldestFirst
    case singleRandomDraw
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCoinSelectionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = CoinSelectionAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoinSelectionAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .branchAndBound

        case 2: return .largestFirst

        case 3: return .oldestFirst

        case 4: return .singleRandomDraw

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoinSelectionAlgorithm, into buf: inout [UInt8]) {
        switch value {
        case .branchAndBound:
            writeInt(&buf, Int32(1))

        case .largestFirst:
            writeInt(&buf, Int32(2))

        case .oldestFirst:
            writeInt(&buf, Int32(3))

        case .singleRandomDraw:
            writeInt(&buf, Int32(4))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinSelectionAlgorithm_lift(_ buf: RustBuffer) throws -> CoinSelectionAlgorithm {
    return try FfiConverterTypeCoinSelectionAlgorithm.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCoinSelectionAlgorithm_lower(_ value: CoinSelectionAlgorithm) -> RustBuffer {
    return FfiConverterTypeCoinSelectionAlgorithm.lower(value)
}

extension CoinSelectionAlgorithm: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConfirmationStatus {
    case confirmed(blockHash: BlockHash, height: UInt32, timestamp: UInt64)
    case unconfirmed
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationStatus: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .confirmed(blockHash: FfiConverterTypeBlockHash.read(from: &buf), height: FfiConverterUInt32.read(from: &buf), timestamp: FfiConverterUInt64.read(from: &buf))

        case 2: return .unconfirmed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfirmationStatus, into buf: inout [UInt8]) {
        switch value {
        case let .confirmed(blockHash, height, timestamp):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBlockHash.write(blockHash, into: &buf)
            FfiConverterUInt32.write(height, into: &buf)
            FfiConverterUInt64.write(timestamp, into: &buf)

        case .unconfirmed:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationStatus_lift(_ buf: RustBuffer) throws -> ConfirmationStatus {
    return try FfiConverterTypeConfirmationStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationStatus_lower(_ value: ConfirmationStatus) -> RustBuffer {
    return FfiConverterTypeConfirmationStatus.lower(value)
}

extension ConfirmationStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Currency {
    case bitcoin
    case bitcoinTestnet
    case regtest
    case simnet
    case signet
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCurrency: FfiConverterRustBuffer {
    typealias SwiftType = Currency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Currency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .bitcoinTestnet

        case 3: return .regtest

        case 4: return .simnet

        case 5: return .signet

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Currency, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .bitcoinTestnet:
            writeInt(&buf, Int32(2))

        case .regtest:
            writeInt(&buf, Int32(3))

        case .simnet:
            writeInt(&buf, Int32(4))

        case .signet:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrency_lift(_ buf: RustBuffer) throws -> Currency {
    return try FfiConverterTypeCurrency.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCurrency_lower(_ value: Currency) -> RustBuffer {
    return FfiConverterTypeCurrency.lower(value)
}

extension Currency: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Event {
    case paymentSuccessful(paymentId: PaymentId?, paymentHash: PaymentHash, paymentPreimage: PaymentPreimage?, feePaidMsat: UInt64?)
    case paymentFailed(paymentId: PaymentId?, paymentHash: PaymentHash?, reason: PaymentFailureReason?)
    case paymentReceived(paymentId: PaymentId?, paymentHash: PaymentHash, amountMsat: UInt64, customRecords: [CustomTlvRecord])
    case paymentClaimable(paymentId: PaymentId, paymentHash: PaymentHash, claimableAmountMsat: UInt64, claimDeadline: UInt32?, customRecords: [CustomTlvRecord])
    case paymentForwarded(prevChannelId: ChannelId, nextChannelId: ChannelId, prevUserChannelId: UserChannelId?, nextUserChannelId: UserChannelId?, prevNodeId: PublicKey?, nextNodeId: PublicKey?, totalFeeEarnedMsat: UInt64?, skimmedFeeMsat: UInt64?, claimFromOnchainTx: Bool, outboundAmountForwardedMsat: UInt64?)
    case channelPending(channelId: ChannelId, userChannelId: UserChannelId, formerTemporaryChannelId: ChannelId, counterpartyNodeId: PublicKey, fundingTxo: OutPoint)
    case channelReady(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey?, fundingTxo: OutPoint?)
    case channelClosed(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey?, reason: ClosureReason?)
    case splicePending(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey, newFundingTxo: OutPoint)
    case spliceFailed(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey, abandonedFundingTxo: OutPoint?)
    case onchainTransactionConfirmed(txid: Txid, blockHash: BlockHash, blockHeight: UInt32, confirmationTime: UInt64, details: TransactionDetails)
    case onchainTransactionReceived(txid: Txid, details: TransactionDetails)
    case onchainTransactionReplaced(txid: Txid, conflicts: [Txid])
    case onchainTransactionReorged(txid: Txid
    )
    case onchainTransactionEvicted(txid: Txid
    )
    case syncProgress(syncType: SyncType, progressPercent: UInt8, currentBlockHeight: UInt32, targetBlockHeight: UInt32)
    case syncCompleted(syncType: SyncType, syncedBlockHeight: UInt32)
    case balanceChanged(oldSpendableOnchainBalanceSats: UInt64, newSpendableOnchainBalanceSats: UInt64, oldTotalOnchainBalanceSats: UInt64, newTotalOnchainBalanceSats: UInt64, oldTotalLightningBalanceSats: UInt64, newTotalLightningBalanceSats: UInt64)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .paymentSuccessful(paymentId: FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf), paymentPreimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf), feePaidMsat: FfiConverterOptionUInt64.read(from: &buf))

        case 2: return try .paymentFailed(paymentId: FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: FfiConverterOptionTypePaymentHash.read(from: &buf), reason: FfiConverterOptionTypePaymentFailureReason.read(from: &buf))

        case 3: return try .paymentReceived(paymentId: FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf), amountMsat: FfiConverterUInt64.read(from: &buf), customRecords: FfiConverterSequenceTypeCustomTlvRecord.read(from: &buf))

        case 4: return try .paymentClaimable(paymentId: FfiConverterTypePaymentId.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf), claimableAmountMsat: FfiConverterUInt64.read(from: &buf), claimDeadline: FfiConverterOptionUInt32.read(from: &buf), customRecords: FfiConverterSequenceTypeCustomTlvRecord.read(from: &buf))

        case 5: return try .paymentForwarded(prevChannelId: FfiConverterTypeChannelId.read(from: &buf), nextChannelId: FfiConverterTypeChannelId.read(from: &buf), prevUserChannelId: FfiConverterOptionTypeUserChannelId.read(from: &buf), nextUserChannelId: FfiConverterOptionTypeUserChannelId.read(from: &buf), prevNodeId: FfiConverterOptionTypePublicKey.read(from: &buf), nextNodeId: FfiConverterOptionTypePublicKey.read(from: &buf), totalFeeEarnedMsat: FfiConverterOptionUInt64.read(from: &buf), skimmedFeeMsat: FfiConverterOptionUInt64.read(from: &buf), claimFromOnchainTx: FfiConverterBool.read(from: &buf), outboundAmountForwardedMsat: FfiConverterOptionUInt64.read(from: &buf))

        case 6: return try .channelPending(channelId: FfiConverterTypeChannelId.read(from: &buf), userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), formerTemporaryChannelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), fundingTxo: FfiConverterTypeOutPoint.read(from: &buf))

        case 7: return try .channelReady(channelId: FfiConverterTypeChannelId.read(from: &buf), userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: FfiConverterOptionTypePublicKey.read(from: &buf), fundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf))

        case 8: return try .channelClosed(channelId: FfiConverterTypeChannelId.read(from: &buf), userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: FfiConverterOptionTypePublicKey.read(from: &buf), reason: FfiConverterOptionTypeClosureReason.read(from: &buf))

        case 9: return try .splicePending(channelId: FfiConverterTypeChannelId.read(from: &buf), userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), newFundingTxo: FfiConverterTypeOutPoint.read(from: &buf))

        case 10: return try .spliceFailed(channelId: FfiConverterTypeChannelId.read(from: &buf), userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), abandonedFundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf))

        case 11: return try .onchainTransactionConfirmed(txid: FfiConverterTypeTxid.read(from: &buf), blockHash: FfiConverterTypeBlockHash.read(from: &buf), blockHeight: FfiConverterUInt32.read(from: &buf), confirmationTime: FfiConverterUInt64.read(from: &buf), details: FfiConverterTypeTransactionDetails.read(from: &buf))

        case 12: return try .onchainTransactionReceived(txid: FfiConverterTypeTxid.read(from: &buf), details: FfiConverterTypeTransactionDetails.read(from: &buf))

        case 13: return try .onchainTransactionReplaced(txid: FfiConverterTypeTxid.read(from: &buf), conflicts: FfiConverterSequenceTypeTxid.read(from: &buf))

        case 14: return try .onchainTransactionReorged(txid: FfiConverterTypeTxid.read(from: &buf)
            )

        case 15: return try .onchainTransactionEvicted(txid: FfiConverterTypeTxid.read(from: &buf)
            )

        case 16: return try .syncProgress(syncType: FfiConverterTypeSyncType.read(from: &buf), progressPercent: FfiConverterUInt8.read(from: &buf), currentBlockHeight: FfiConverterUInt32.read(from: &buf), targetBlockHeight: FfiConverterUInt32.read(from: &buf))

        case 17: return try .syncCompleted(syncType: FfiConverterTypeSyncType.read(from: &buf), syncedBlockHeight: FfiConverterUInt32.read(from: &buf))

        case 18: return try .balanceChanged(oldSpendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), newSpendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), oldTotalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), newTotalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), oldTotalLightningBalanceSats: FfiConverterUInt64.read(from: &buf), newTotalLightningBalanceSats: FfiConverterUInt64.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        case let .paymentSuccessful(paymentId, paymentHash, paymentPreimage, feePaidMsat):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(paymentPreimage, into: &buf)
            FfiConverterOptionUInt64.write(feePaidMsat, into: &buf)

        case let .paymentFailed(paymentId, paymentHash, reason):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterOptionTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentFailureReason.write(reason, into: &buf)

        case let .paymentReceived(paymentId, paymentHash, amountMsat, customRecords):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(amountMsat, into: &buf)
            FfiConverterSequenceTypeCustomTlvRecord.write(customRecords, into: &buf)

        case let .paymentClaimable(paymentId, paymentHash, claimableAmountMsat, claimDeadline, customRecords):
            writeInt(&buf, Int32(4))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(claimableAmountMsat, into: &buf)
            FfiConverterOptionUInt32.write(claimDeadline, into: &buf)
            FfiConverterSequenceTypeCustomTlvRecord.write(customRecords, into: &buf)

        case let .paymentForwarded(prevChannelId, nextChannelId, prevUserChannelId, nextUserChannelId, prevNodeId, nextNodeId, totalFeeEarnedMsat, skimmedFeeMsat, claimFromOnchainTx, outboundAmountForwardedMsat):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(prevChannelId, into: &buf)
            FfiConverterTypeChannelId.write(nextChannelId, into: &buf)
            FfiConverterOptionTypeUserChannelId.write(prevUserChannelId, into: &buf)
            FfiConverterOptionTypeUserChannelId.write(nextUserChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(prevNodeId, into: &buf)
            FfiConverterOptionTypePublicKey.write(nextNodeId, into: &buf)
            FfiConverterOptionUInt64.write(totalFeeEarnedMsat, into: &buf)
            FfiConverterOptionUInt64.write(skimmedFeeMsat, into: &buf)
            FfiConverterBool.write(claimFromOnchainTx, into: &buf)
            FfiConverterOptionUInt64.write(outboundAmountForwardedMsat, into: &buf)

        case let .channelPending(channelId, userChannelId, formerTemporaryChannelId, counterpartyNodeId, fundingTxo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypeChannelId.write(formerTemporaryChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterTypeOutPoint.write(fundingTxo, into: &buf)

        case let .channelReady(channelId, userChannelId, counterpartyNodeId, fundingTxo):
            writeInt(&buf, Int32(7))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeOutPoint.write(fundingTxo, into: &buf)

        case let .channelClosed(channelId, userChannelId, counterpartyNodeId, reason):
            writeInt(&buf, Int32(8))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeClosureReason.write(reason, into: &buf)

        case let .splicePending(channelId, userChannelId, counterpartyNodeId, newFundingTxo):
            writeInt(&buf, Int32(9))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterTypeOutPoint.write(newFundingTxo, into: &buf)

        case let .spliceFailed(channelId, userChannelId, counterpartyNodeId, abandonedFundingTxo):
            writeInt(&buf, Int32(10))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeOutPoint.write(abandonedFundingTxo, into: &buf)

        case let .onchainTransactionConfirmed(txid, blockHash, blockHeight, confirmationTime, details):
            writeInt(&buf, Int32(11))
            FfiConverterTypeTxid.write(txid, into: &buf)
            FfiConverterTypeBlockHash.write(blockHash, into: &buf)
            FfiConverterUInt32.write(blockHeight, into: &buf)
            FfiConverterUInt64.write(confirmationTime, into: &buf)
            FfiConverterTypeTransactionDetails.write(details, into: &buf)

        case let .onchainTransactionReceived(txid, details):
            writeInt(&buf, Int32(12))
            FfiConverterTypeTxid.write(txid, into: &buf)
            FfiConverterTypeTransactionDetails.write(details, into: &buf)

        case let .onchainTransactionReplaced(txid, conflicts):
            writeInt(&buf, Int32(13))
            FfiConverterTypeTxid.write(txid, into: &buf)
            FfiConverterSequenceTypeTxid.write(conflicts, into: &buf)

        case let .onchainTransactionReorged(txid):
            writeInt(&buf, Int32(14))
            FfiConverterTypeTxid.write(txid, into: &buf)

        case let .onchainTransactionEvicted(txid):
            writeInt(&buf, Int32(15))
            FfiConverterTypeTxid.write(txid, into: &buf)

        case let .syncProgress(syncType, progressPercent, currentBlockHeight, targetBlockHeight):
            writeInt(&buf, Int32(16))
            FfiConverterTypeSyncType.write(syncType, into: &buf)
            FfiConverterUInt8.write(progressPercent, into: &buf)
            FfiConverterUInt32.write(currentBlockHeight, into: &buf)
            FfiConverterUInt32.write(targetBlockHeight, into: &buf)

        case let .syncCompleted(syncType, syncedBlockHeight):
            writeInt(&buf, Int32(17))
            FfiConverterTypeSyncType.write(syncType, into: &buf)
            FfiConverterUInt32.write(syncedBlockHeight, into: &buf)

        case let .balanceChanged(oldSpendableOnchainBalanceSats, newSpendableOnchainBalanceSats, oldTotalOnchainBalanceSats, newTotalOnchainBalanceSats, oldTotalLightningBalanceSats, newTotalLightningBalanceSats):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(oldSpendableOnchainBalanceSats, into: &buf)
            FfiConverterUInt64.write(newSpendableOnchainBalanceSats, into: &buf)
            FfiConverterUInt64.write(oldTotalOnchainBalanceSats, into: &buf)
            FfiConverterUInt64.write(newTotalOnchainBalanceSats, into: &buf)
            FfiConverterUInt64.write(oldTotalLightningBalanceSats, into: &buf)
            FfiConverterUInt64.write(newTotalLightningBalanceSats, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}

extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Lsps1PaymentState {
    case expectPayment
    case paid
    case refunded
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1PaymentState: FfiConverterRustBuffer {
    typealias SwiftType = Lsps1PaymentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1PaymentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .expectPayment

        case 2: return .paid

        case 3: return .refunded

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Lsps1PaymentState, into buf: inout [UInt8]) {
        switch value {
        case .expectPayment:
            writeInt(&buf, Int32(1))

        case .paid:
            writeInt(&buf, Int32(2))

        case .refunded:
            writeInt(&buf, Int32(3))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1PaymentState_lift(_ buf: RustBuffer) throws -> Lsps1PaymentState {
    return try FfiConverterTypeLSPS1PaymentState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1PaymentState_lower(_ value: Lsps1PaymentState) -> RustBuffer {
    return FfiConverterTypeLSPS1PaymentState.lower(value)
}

extension Lsps1PaymentState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LightningBalance {
    case claimableOnChannelClose(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, transactionFeeSatoshis: UInt64, outboundPaymentHtlcRoundedMsat: UInt64, outboundForwardedHtlcRoundedMsat: UInt64, inboundClaimingHtlcRoundedMsat: UInt64, inboundHtlcRoundedMsat: UInt64)
    case claimableAwaitingConfirmations(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, confirmationHeight: UInt32, source: BalanceSource)
    case contentiousClaimable(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, timeoutHeight: UInt32, paymentHash: PaymentHash, paymentPreimage: PaymentPreimage)
    case maybeTimeoutClaimableHtlc(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, claimableHeight: UInt32, paymentHash: PaymentHash, outboundPayment: Bool)
    case maybePreimageClaimableHtlc(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, expiryHeight: UInt32, paymentHash: PaymentHash)
    case counterpartyRevokedOutputClaimable(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = LightningBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .claimableOnChannelClose(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf), transactionFeeSatoshis: FfiConverterUInt64.read(from: &buf), outboundPaymentHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf), outboundForwardedHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf), inboundClaimingHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf), inboundHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf))

        case 2: return try .claimableAwaitingConfirmations(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf), confirmationHeight: FfiConverterUInt32.read(from: &buf), source: FfiConverterTypeBalanceSource.read(from: &buf))

        case 3: return try .contentiousClaimable(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf), timeoutHeight: FfiConverterUInt32.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf), paymentPreimage: FfiConverterTypePaymentPreimage.read(from: &buf))

        case 4: return try .maybeTimeoutClaimableHtlc(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf), claimableHeight: FfiConverterUInt32.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf), outboundPayment: FfiConverterBool.read(from: &buf))

        case 5: return try .maybePreimageClaimableHtlc(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf), expiryHeight: FfiConverterUInt32.read(from: &buf), paymentHash: FfiConverterTypePaymentHash.read(from: &buf))

        case 6: return try .counterpartyRevokedOutputClaimable(channelId: FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningBalance, into buf: inout [UInt8]) {
        switch value {
        case let .claimableOnChannelClose(channelId, counterpartyNodeId, amountSatoshis, transactionFeeSatoshis, outboundPaymentHtlcRoundedMsat, outboundForwardedHtlcRoundedMsat, inboundClaimingHtlcRoundedMsat, inboundHtlcRoundedMsat):
            writeInt(&buf, Int32(1))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt64.write(transactionFeeSatoshis, into: &buf)
            FfiConverterUInt64.write(outboundPaymentHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(outboundForwardedHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundClaimingHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundHtlcRoundedMsat, into: &buf)

        case let .claimableAwaitingConfirmations(channelId, counterpartyNodeId, amountSatoshis, confirmationHeight, source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterTypeBalanceSource.write(source, into: &buf)

        case let .contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis, timeoutHeight, paymentHash, paymentPreimage):
            writeInt(&buf, Int32(3))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(timeoutHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterTypePaymentPreimage.write(paymentPreimage, into: &buf)

        case let .maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId, amountSatoshis, claimableHeight, paymentHash, outboundPayment):
            writeInt(&buf, Int32(4))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(claimableHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterBool.write(outboundPayment, into: &buf)

        case let .maybePreimageClaimableHtlc(channelId, counterpartyNodeId, amountSatoshis, expiryHeight, paymentHash):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(expiryHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)

        case let .counterpartyRevokedOutputClaimable(channelId, counterpartyNodeId, amountSatoshis):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningBalance_lift(_ buf: RustBuffer) throws -> LightningBalance {
    return try FfiConverterTypeLightningBalance.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningBalance_lower(_ value: LightningBalance) -> RustBuffer {
    return FfiConverterTypeLightningBalance.lower(value)
}

extension LightningBalance: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    case gossip
    case trace
    case debug
    case info
    case warn
    case error
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .gossip

        case 2: return .trace

        case 3: return .debug

        case 4: return .info

        case 5: return .warn

        case 6: return .error

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .gossip:
            writeInt(&buf, Int32(1))

        case .trace:
            writeInt(&buf, Int32(2))

        case .debug:
            writeInt(&buf, Int32(3))

        case .info:
            writeInt(&buf, Int32(4))

        case .warn:
            writeInt(&buf, Int32(5))

        case .error:
            writeInt(&buf, Int32(6))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MaxDustHtlcExposure {
    case fixedLimit(limitMsat: UInt64
    )
    case feeRateMultiplier(multiplier: UInt64
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMaxDustHTLCExposure: FfiConverterRustBuffer {
    typealias SwiftType = MaxDustHtlcExposure

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxDustHtlcExposure {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fixedLimit(limitMsat: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .feeRateMultiplier(multiplier: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxDustHtlcExposure, into buf: inout [UInt8]) {
        switch value {
        case let .fixedLimit(limitMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(limitMsat, into: &buf)

        case let .feeRateMultiplier(multiplier):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(multiplier, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxDustHTLCExposure_lift(_ buf: RustBuffer) throws -> MaxDustHtlcExposure {
    return try FfiConverterTypeMaxDustHTLCExposure.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMaxDustHTLCExposure_lower(_ value: MaxDustHtlcExposure) -> RustBuffer {
    return FfiConverterTypeMaxDustHTLCExposure.lower(value)
}

extension MaxDustHtlcExposure: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    case bitcoin
    case testnet
    case signet
    case regtest
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .testnet

        case 3: return .signet

        case 4: return .regtest

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .testnet:
            writeInt(&buf, Int32(2))

        case .signet:
            writeInt(&buf, Int32(3))

        case .regtest:
            writeInt(&buf, Int32(4))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}

extension Network: Equatable, Hashable {}

public enum NodeError {
    case AlreadyRunning(message: String)

    case NotRunning(message: String)

    case OnchainTxCreationFailed(message: String)

    case ConnectionFailed(message: String)

    case InvoiceCreationFailed(message: String)

    case InvoiceRequestCreationFailed(message: String)

    case OfferCreationFailed(message: String)

    case RefundCreationFailed(message: String)

    case PaymentSendingFailed(message: String)

    case InvalidCustomTlvs(message: String)

    case ProbeSendingFailed(message: String)

    case RouteNotFound(message: String)

    case ChannelCreationFailed(message: String)

    case ChannelClosingFailed(message: String)

    case ChannelSplicingFailed(message: String)

    case ChannelConfigUpdateFailed(message: String)

    case PersistenceFailed(message: String)

    case FeerateEstimationUpdateFailed(message: String)

    case FeerateEstimationUpdateTimeout(message: String)

    case WalletOperationFailed(message: String)

    case WalletOperationTimeout(message: String)

    case OnchainTxSigningFailed(message: String)

    case TxSyncFailed(message: String)

    case TxSyncTimeout(message: String)

    case GossipUpdateFailed(message: String)

    case GossipUpdateTimeout(message: String)

    case LiquidityRequestFailed(message: String)

    case UriParameterParsingFailed(message: String)

    case InvalidAddress(message: String)

    case InvalidSocketAddress(message: String)

    case InvalidPublicKey(message: String)

    case InvalidSecretKey(message: String)

    case InvalidOfferId(message: String)

    case InvalidNodeId(message: String)

    case InvalidPaymentId(message: String)

    case InvalidPaymentHash(message: String)

    case InvalidPaymentPreimage(message: String)

    case InvalidPaymentSecret(message: String)

    case InvalidAmount(message: String)

    case InvalidInvoice(message: String)

    case InvalidOffer(message: String)

    case InvalidRefund(message: String)

    case InvalidChannelId(message: String)

    case InvalidNetwork(message: String)

    case InvalidUri(message: String)

    case InvalidQuantity(message: String)

    case InvalidNodeAlias(message: String)

    case InvalidDateTime(message: String)

    case InvalidFeeRate(message: String)

    case DuplicatePayment(message: String)

    case UnsupportedCurrency(message: String)

    case InsufficientFunds(message: String)

    case LiquiditySourceUnavailable(message: String)

    case LiquidityFeeTooHigh(message: String)

    case InvalidBlindedPaths(message: String)

    case AsyncPaymentServicesDisabled(message: String)

    case CannotRbfFundingTransaction(message: String)

    case TransactionNotFound(message: String)

    case TransactionAlreadyConfirmed(message: String)

    case NoSpendableOutputs(message: String)

    case CoinSelectionFailed(message: String)

    case InvalidMnemonic(message: String)

    case BackgroundSyncNotEnabled(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeError: FfiConverterRustBuffer {
    typealias SwiftType = NodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .AlreadyRunning(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .NotRunning(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .OnchainTxCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .ConnectionFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvoiceCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .InvoiceRequestCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .OfferCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .RefundCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .PaymentSendingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .InvalidCustomTlvs(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .ProbeSendingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .RouteNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .ChannelCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .ChannelClosingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .ChannelSplicingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .ChannelConfigUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 17: return try .PersistenceFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 18: return try .FeerateEstimationUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 19: return try .FeerateEstimationUpdateTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 20: return try .WalletOperationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 21: return try .WalletOperationTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 22: return try .OnchainTxSigningFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 23: return try .TxSyncFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 24: return try .TxSyncTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 25: return try .GossipUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 26: return try .GossipUpdateTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 27: return try .LiquidityRequestFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 28: return try .UriParameterParsingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 29: return try .InvalidAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 30: return try .InvalidSocketAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 31: return try .InvalidPublicKey(
                message: FfiConverterString.read(from: &buf)
            )

        case 32: return try .InvalidSecretKey(
                message: FfiConverterString.read(from: &buf)
            )

        case 33: return try .InvalidOfferId(
                message: FfiConverterString.read(from: &buf)
            )

        case 34: return try .InvalidNodeId(
                message: FfiConverterString.read(from: &buf)
            )

        case 35: return try .InvalidPaymentId(
                message: FfiConverterString.read(from: &buf)
            )

        case 36: return try .InvalidPaymentHash(
                message: FfiConverterString.read(from: &buf)
            )

        case 37: return try .InvalidPaymentPreimage(
                message: FfiConverterString.read(from: &buf)
            )

        case 38: return try .InvalidPaymentSecret(
                message: FfiConverterString.read(from: &buf)
            )

        case 39: return try .InvalidAmount(
                message: FfiConverterString.read(from: &buf)
            )

        case 40: return try .InvalidInvoice(
                message: FfiConverterString.read(from: &buf)
            )

        case 41: return try .InvalidOffer(
                message: FfiConverterString.read(from: &buf)
            )

        case 42: return try .InvalidRefund(
                message: FfiConverterString.read(from: &buf)
            )

        case 43: return try .InvalidChannelId(
                message: FfiConverterString.read(from: &buf)
            )

        case 44: return try .InvalidNetwork(
                message: FfiConverterString.read(from: &buf)
            )

        case 45: return try .InvalidUri(
                message: FfiConverterString.read(from: &buf)
            )

        case 46: return try .InvalidQuantity(
                message: FfiConverterString.read(from: &buf)
            )

        case 47: return try .InvalidNodeAlias(
                message: FfiConverterString.read(from: &buf)
            )

        case 48: return try .InvalidDateTime(
                message: FfiConverterString.read(from: &buf)
            )

        case 49: return try .InvalidFeeRate(
                message: FfiConverterString.read(from: &buf)
            )

        case 50: return try .DuplicatePayment(
                message: FfiConverterString.read(from: &buf)
            )

        case 51: return try .UnsupportedCurrency(
                message: FfiConverterString.read(from: &buf)
            )

        case 52: return try .InsufficientFunds(
                message: FfiConverterString.read(from: &buf)
            )

        case 53: return try .LiquiditySourceUnavailable(
                message: FfiConverterString.read(from: &buf)
            )

        case 54: return try .LiquidityFeeTooHigh(
                message: FfiConverterString.read(from: &buf)
            )

        case 55: return try .InvalidBlindedPaths(
                message: FfiConverterString.read(from: &buf)
            )

        case 56: return try .AsyncPaymentServicesDisabled(
                message: FfiConverterString.read(from: &buf)
            )

        case 57: return try .CannotRbfFundingTransaction(
                message: FfiConverterString.read(from: &buf)
            )

        case 58: return try .TransactionNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 59: return try .TransactionAlreadyConfirmed(
                message: FfiConverterString.read(from: &buf)
            )

        case 60: return try .NoSpendableOutputs(
                message: FfiConverterString.read(from: &buf)
            )

        case 61: return try .CoinSelectionFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 62: return try .InvalidMnemonic(
                message: FfiConverterString.read(from: &buf)
            )

        case 63: return try .BackgroundSyncNotEnabled(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeError, into buf: inout [UInt8]) {
        switch value {
        case .AlreadyRunning(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .NotRunning(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .OnchainTxCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .ConnectionFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvoiceCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .InvoiceRequestCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .OfferCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .RefundCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .PaymentSendingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .InvalidCustomTlvs(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .ProbeSendingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .RouteNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        case .ChannelCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(13))
        case .ChannelClosingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(14))
        case .ChannelSplicingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(15))
        case .ChannelConfigUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(16))
        case .PersistenceFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(17))
        case .FeerateEstimationUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(18))
        case .FeerateEstimationUpdateTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(19))
        case .WalletOperationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(20))
        case .WalletOperationTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(21))
        case .OnchainTxSigningFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(22))
        case .TxSyncFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(23))
        case .TxSyncTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(24))
        case .GossipUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(25))
        case .GossipUpdateTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(26))
        case .LiquidityRequestFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(27))
        case .UriParameterParsingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(28))
        case .InvalidAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(29))
        case .InvalidSocketAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(30))
        case .InvalidPublicKey(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(31))
        case .InvalidSecretKey(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(32))
        case .InvalidOfferId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(33))
        case .InvalidNodeId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(34))
        case .InvalidPaymentId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(35))
        case .InvalidPaymentHash(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(36))
        case .InvalidPaymentPreimage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(37))
        case .InvalidPaymentSecret(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(38))
        case .InvalidAmount(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(39))
        case .InvalidInvoice(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(40))
        case .InvalidOffer(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(41))
        case .InvalidRefund(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(42))
        case .InvalidChannelId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(43))
        case .InvalidNetwork(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(44))
        case .InvalidUri(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(45))
        case .InvalidQuantity(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(46))
        case .InvalidNodeAlias(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(47))
        case .InvalidDateTime(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(48))
        case .InvalidFeeRate(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(49))
        case .DuplicatePayment(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(50))
        case .UnsupportedCurrency(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(51))
        case .InsufficientFunds(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(52))
        case .LiquiditySourceUnavailable(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(53))
        case .LiquidityFeeTooHigh(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(54))
        case .InvalidBlindedPaths(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(55))
        case .AsyncPaymentServicesDisabled(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(56))
        case .CannotRbfFundingTransaction(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(57))
        case .TransactionNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(58))
        case .TransactionAlreadyConfirmed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(59))
        case .NoSpendableOutputs(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(60))
        case .CoinSelectionFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(61))
        case .InvalidMnemonic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(62))
        case .BackgroundSyncNotEnabled(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(63))
        }
    }
}

extension NodeError: Equatable, Hashable {}

extension NodeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OfferAmount {
    case bitcoin(amountMsats: UInt64
    )
    case currency(iso4217Code: String, amount: UInt64)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOfferAmount: FfiConverterRustBuffer {
    typealias SwiftType = OfferAmount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferAmount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .bitcoin(amountMsats: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .currency(iso4217Code: FfiConverterString.read(from: &buf), amount: FfiConverterUInt64.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OfferAmount, into buf: inout [UInt8]) {
        switch value {
        case let .bitcoin(amountMsats):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(amountMsats, into: &buf)

        case let .currency(iso4217Code, amount):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(iso4217Code, into: &buf)
            FfiConverterUInt64.write(amount, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferAmount_lift(_ buf: RustBuffer) throws -> OfferAmount {
    return try FfiConverterTypeOfferAmount.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferAmount_lower(_ value: OfferAmount) -> RustBuffer {
    return FfiConverterTypeOfferAmount.lower(value)
}

extension OfferAmount: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDirection {
    case inbound
    case outbound
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .inbound

        case 2: return .outbound

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDirection, into buf: inout [UInt8]) {
        switch value {
        case .inbound:
            writeInt(&buf, Int32(1))

        case .outbound:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDirection_lift(_ buf: RustBuffer) throws -> PaymentDirection {
    return try FfiConverterTypePaymentDirection.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentDirection_lower(_ value: PaymentDirection) -> RustBuffer {
    return FfiConverterTypePaymentDirection.lower(value)
}

extension PaymentDirection: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentFailureReason {
    case recipientRejected
    case userAbandoned
    case retriesExhausted
    case paymentExpired
    case routeNotFound
    case unexpectedError
    case unknownRequiredFeatures
    case invoiceRequestExpired
    case invoiceRequestRejected
    case blindedPathCreationFailed
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .recipientRejected

        case 2: return .userAbandoned

        case 3: return .retriesExhausted

        case 4: return .paymentExpired

        case 5: return .routeNotFound

        case 6: return .unexpectedError

        case 7: return .unknownRequiredFeatures

        case 8: return .invoiceRequestExpired

        case 9: return .invoiceRequestRejected

        case 10: return .blindedPathCreationFailed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFailureReason, into buf: inout [UInt8]) {
        switch value {
        case .recipientRejected:
            writeInt(&buf, Int32(1))

        case .userAbandoned:
            writeInt(&buf, Int32(2))

        case .retriesExhausted:
            writeInt(&buf, Int32(3))

        case .paymentExpired:
            writeInt(&buf, Int32(4))

        case .routeNotFound:
            writeInt(&buf, Int32(5))

        case .unexpectedError:
            writeInt(&buf, Int32(6))

        case .unknownRequiredFeatures:
            writeInt(&buf, Int32(7))

        case .invoiceRequestExpired:
            writeInt(&buf, Int32(8))

        case .invoiceRequestRejected:
            writeInt(&buf, Int32(9))

        case .blindedPathCreationFailed:
            writeInt(&buf, Int32(10))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFailureReason_lift(_ buf: RustBuffer) throws -> PaymentFailureReason {
    return try FfiConverterTypePaymentFailureReason.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFailureReason_lower(_ value: PaymentFailureReason) -> RustBuffer {
    return FfiConverterTypePaymentFailureReason.lower(value)
}

extension PaymentFailureReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentKind {
    case onchain(txid: Txid, status: ConfirmationStatus)
    case bolt11(hash: PaymentHash, preimage: PaymentPreimage?, secret: PaymentSecret?, description: String?, bolt11: String?)
    case bolt11Jit(hash: PaymentHash, preimage: PaymentPreimage?, secret: PaymentSecret?, counterpartySkimmedFeeMsat: UInt64?, lspFeeLimits: LspFeeLimits, description: String?, bolt11: String?)
    case bolt12Offer(hash: PaymentHash?, preimage: PaymentPreimage?, secret: PaymentSecret?, offerId: OfferId, payerNote: UntrustedString?, quantity: UInt64?)
    case bolt12Refund(hash: PaymentHash?, preimage: PaymentPreimage?, secret: PaymentSecret?, payerNote: UntrustedString?, quantity: UInt64?)
    case spontaneous(hash: PaymentHash, preimage: PaymentPreimage?)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentKind: FfiConverterRustBuffer {
    typealias SwiftType = PaymentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .onchain(txid: FfiConverterTypeTxid.read(from: &buf), status: FfiConverterTypeConfirmationStatus.read(from: &buf))

        case 2: return try .bolt11(hash: FfiConverterTypePaymentHash.read(from: &buf), preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: FfiConverterOptionTypePaymentSecret.read(from: &buf), description: FfiConverterOptionString.read(from: &buf), bolt11: FfiConverterOptionString.read(from: &buf))

        case 3: return try .bolt11Jit(hash: FfiConverterTypePaymentHash.read(from: &buf), preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: FfiConverterOptionTypePaymentSecret.read(from: &buf), counterpartySkimmedFeeMsat: FfiConverterOptionUInt64.read(from: &buf), lspFeeLimits: FfiConverterTypeLSPFeeLimits.read(from: &buf), description: FfiConverterOptionString.read(from: &buf), bolt11: FfiConverterOptionString.read(from: &buf))

        case 4: return try .bolt12Offer(hash: FfiConverterOptionTypePaymentHash.read(from: &buf), preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: FfiConverterOptionTypePaymentSecret.read(from: &buf), offerId: FfiConverterTypeOfferId.read(from: &buf), payerNote: FfiConverterOptionTypeUntrustedString.read(from: &buf), quantity: FfiConverterOptionUInt64.read(from: &buf))

        case 5: return try .bolt12Refund(hash: FfiConverterOptionTypePaymentHash.read(from: &buf), preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: FfiConverterOptionTypePaymentSecret.read(from: &buf), payerNote: FfiConverterOptionTypeUntrustedString.read(from: &buf), quantity: FfiConverterOptionUInt64.read(from: &buf))

        case 6: return try .spontaneous(hash: FfiConverterTypePaymentHash.read(from: &buf), preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentKind, into buf: inout [UInt8]) {
        switch value {
        case let .onchain(txid, status):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTxid.write(txid, into: &buf)
            FfiConverterTypeConfirmationStatus.write(status, into: &buf)

        case let .bolt11(hash, preimage, secret, description, bolt11):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(bolt11, into: &buf)

        case let .bolt11Jit(hash, preimage, secret, counterpartySkimmedFeeMsat, lspFeeLimits, description, bolt11):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionUInt64.write(counterpartySkimmedFeeMsat, into: &buf)
            FfiConverterTypeLSPFeeLimits.write(lspFeeLimits, into: &buf)
            FfiConverterOptionString.write(description, into: &buf)
            FfiConverterOptionString.write(bolt11, into: &buf)

        case let .bolt12Offer(hash, preimage, secret, offerId, payerNote, quantity):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeOfferId.write(offerId, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)

        case let .bolt12Refund(hash, preimage, secret, payerNote, quantity):
            writeInt(&buf, Int32(5))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)

        case let .spontaneous(hash, preimage):
            writeInt(&buf, Int32(6))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentKind_lift(_ buf: RustBuffer) throws -> PaymentKind {
    return try FfiConverterTypePaymentKind.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentKind_lower(_ value: PaymentKind) -> RustBuffer {
    return FfiConverterTypePaymentKind.lower(value)
}

extension PaymentKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentStatus {
    case pending
    case succeeded
    case failed
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .pending

        case 2: return .succeeded

        case 3: return .failed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        case .pending:
            writeInt(&buf, Int32(1))

        case .succeeded:
            writeInt(&buf, Int32(2))

        case .failed:
            writeInt(&buf, Int32(3))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}

extension PaymentStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingSweepBalance {
    case pendingBroadcast(channelId: ChannelId?, amountSatoshis: UInt64)
    case broadcastAwaitingConfirmation(channelId: ChannelId?, latestBroadcastHeight: UInt32, latestSpendingTxid: Txid, amountSatoshis: UInt64)
    case awaitingThresholdConfirmations(channelId: ChannelId?, latestSpendingTxid: Txid, confirmationHash: BlockHash, confirmationHeight: UInt32, amountSatoshis: UInt64)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = PendingSweepBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingSweepBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .pendingBroadcast(channelId: FfiConverterOptionTypeChannelId.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf))

        case 2: return try .broadcastAwaitingConfirmation(channelId: FfiConverterOptionTypeChannelId.read(from: &buf), latestBroadcastHeight: FfiConverterUInt32.read(from: &buf), latestSpendingTxid: FfiConverterTypeTxid.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf))

        case 3: return try .awaitingThresholdConfirmations(channelId: FfiConverterOptionTypeChannelId.read(from: &buf), latestSpendingTxid: FfiConverterTypeTxid.read(from: &buf), confirmationHash: FfiConverterTypeBlockHash.read(from: &buf), confirmationHeight: FfiConverterUInt32.read(from: &buf), amountSatoshis: FfiConverterUInt64.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingSweepBalance, into buf: inout [UInt8]) {
        switch value {
        case let .pendingBroadcast(channelId, amountSatoshis):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)

        case let .broadcastAwaitingConfirmation(channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt32.write(latestBroadcastHeight, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)

        case let .awaitingThresholdConfirmations(channelId, latestSpendingTxid, confirmationHash, confirmationHeight, amountSatoshis):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterTypeBlockHash.write(confirmationHash, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePendingSweepBalance_lift(_ buf: RustBuffer) throws -> PendingSweepBalance {
    return try FfiConverterTypePendingSweepBalance.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePendingSweepBalance_lower(_ value: PendingSweepBalance) -> RustBuffer {
    return FfiConverterTypePendingSweepBalance.lower(value)
}

extension PendingSweepBalance: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum QrPaymentResult {
    case onchain(txid: Txid
    )
    case bolt11(paymentId: PaymentId
    )
    case bolt12(paymentId: PaymentId
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeQrPaymentResult: FfiConverterRustBuffer {
    typealias SwiftType = QrPaymentResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrPaymentResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .onchain(txid: FfiConverterTypeTxid.read(from: &buf)
            )

        case 2: return try .bolt11(paymentId: FfiConverterTypePaymentId.read(from: &buf)
            )

        case 3: return try .bolt12(paymentId: FfiConverterTypePaymentId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrPaymentResult, into buf: inout [UInt8]) {
        switch value {
        case let .onchain(txid):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTxid.write(txid, into: &buf)

        case let .bolt11(paymentId):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)

        case let .bolt12(paymentId):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeQrPaymentResult_lift(_ buf: RustBuffer) throws -> QrPaymentResult {
    return try FfiConverterTypeQrPaymentResult.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeQrPaymentResult_lower(_ value: QrPaymentResult) -> RustBuffer {
    return FfiConverterTypeQrPaymentResult.lower(value)
}

extension QrPaymentResult: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SyncType {
    case onchainWallet
    case lightningWallet
    case feeRateCache
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncType: FfiConverterRustBuffer {
    typealias SwiftType = SyncType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .onchainWallet

        case 2: return .lightningWallet

        case 3: return .feeRateCache

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncType, into buf: inout [UInt8]) {
        switch value {
        case .onchainWallet:
            writeInt(&buf, Int32(1))

        case .lightningWallet:
            writeInt(&buf, Int32(2))

        case .feeRateCache:
            writeInt(&buf, Int32(3))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncType_lift(_ buf: RustBuffer) throws -> SyncType {
    return try FfiConverterTypeSyncType.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncType_lower(_ value: SyncType) -> RustBuffer {
    return FfiConverterTypeSyncType.lower(value)
}

extension SyncType: Equatable, Hashable {}

public enum VssHeaderProviderError {
    case InvalidData(message: String)

    case RequestError(message: String)

    case AuthorizationError(message: String)

    case InternalError(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeVssHeaderProviderError: FfiConverterRustBuffer {
    typealias SwiftType = VssHeaderProviderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VssHeaderProviderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .InvalidData(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .RequestError(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .AuthorizationError(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InternalError(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VssHeaderProviderError, into buf: inout [UInt8]) {
        switch value {
        case .InvalidData(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .RequestError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .AuthorizationError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .InternalError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        }
    }
}

extension VssHeaderProviderError: Equatable, Hashable {}

extension VssHeaderProviderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WordCount {
    case words12
    case words15
    case words18
    case words21
    case words24
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .words12

        case 2: return .words15

        case 3: return .words18

        case 4: return .words21

        case 5: return .words24

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WordCount, into buf: inout [UInt8]) {
        switch value {
        case .words12:
            writeInt(&buf, Int32(1))

        case .words15:
            writeInt(&buf, Int32(2))

        case .words18:
            writeInt(&buf, Int32(3))

        case .words21:
            writeInt(&buf, Int32(4))

        case .words24:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lift(_ buf: RustBuffer) throws -> WordCount {
    return try FfiConverterTypeWordCount.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeWordCount_lower(_ value: WordCount) -> RustBuffer {
    return FfiConverterTypeWordCount.lower(value)
}

extension WordCount: Equatable, Hashable {}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeFeeRate: FfiConverterRustBuffer {
    typealias SwiftType = FeeRate?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRate.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    typealias SwiftType = AnchorChannelsConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAnchorChannelsConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAnchorChannelsConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeBackgroundSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = BackgroundSyncConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackgroundSyncConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackgroundSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeChannelConfig: FfiConverterRustBuffer {
    typealias SwiftType = ChannelConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeChannelInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeChannelUpdateInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelUpdateInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelUpdateInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelUpdateInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeElectrumSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = ElectrumSyncConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeElectrumSyncConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeElectrumSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeEsploraSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = EsploraSyncConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEsploraSyncConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEsploraSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLSPS1Bolt11PaymentInfo: FfiConverterRustBuffer {
    typealias SwiftType = Lsps1Bolt11PaymentInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLSPS1Bolt11PaymentInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLSPS1Bolt11PaymentInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLSPS1ChannelInfo: FfiConverterRustBuffer {
    typealias SwiftType = Lsps1ChannelInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLSPS1ChannelInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLSPS1ChannelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLSPS1OnchainPaymentInfo: FfiConverterRustBuffer {
    typealias SwiftType = Lsps1OnchainPaymentInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLSPS1OnchainPaymentInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLSPS1OnchainPaymentInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeAnnouncementInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAnnouncementInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAnnouncementInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNodeInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeInfo?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeInfo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = OutPoint?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutPoint.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutPoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeRouteParametersConfig: FfiConverterRustBuffer {
    typealias SwiftType = RouteParametersConfig?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRouteParametersConfig.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRouteParametersConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeTransactionDetails: FfiConverterRustBuffer {
    typealias SwiftType = TransactionDetails?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionDetails.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeAsyncPaymentsRole: FfiConverterRustBuffer {
    typealias SwiftType = AsyncPaymentsRole?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAsyncPaymentsRole.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAsyncPaymentsRole.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClosureReason.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClosureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLogLevel.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLogLevel.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNetwork.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNetwork.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeOfferAmount: FfiConverterRustBuffer {
    typealias SwiftType = OfferAmount?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOfferAmount.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOfferAmount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentFailureReason.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentFailureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeWordCount: FfiConverterRustBuffer {
    typealias SwiftType = WordCount?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWordCount.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWordCount.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionSequenceTypeSpendableUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [SpendableUtxo]?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSpendableUtxo.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSpendableUtxo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceUInt8.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSocketAddress.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeChannelId: FfiConverterRustBuffer {
    typealias SwiftType = ChannelId?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelId.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNodeAlias: FfiConverterRustBuffer {
    typealias SwiftType = NodeAlias?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAlias.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentHash: FfiConverterRustBuffer {
    typealias SwiftType = PaymentHash?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentHash.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentId: FfiConverterRustBuffer {
    typealias SwiftType = PaymentId?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentId.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentPreimage: FfiConverterRustBuffer {
    typealias SwiftType = PaymentPreimage?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentPreimage.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentPreimage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePaymentSecret: FfiConverterRustBuffer {
    typealias SwiftType = PaymentSecret?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentSecret.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentSecret.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeUntrustedString: FfiConverterRustBuffer {
    typealias SwiftType = UntrustedString?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUntrustedString.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUntrustedString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeUserChannelId: FfiConverterRustBuffer {
    typealias SwiftType = UserChannelId?

    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserChannelId.write(value, into: &buf)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeChannelDetails: FfiConverterRustBuffer {
    typealias SwiftType = [ChannelDetails]

    static func write(_ value: [ChannelDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChannelDetails.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChannelDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChannelDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeChannelDetails.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeCustomTlvRecord: FfiConverterRustBuffer {
    typealias SwiftType = [CustomTlvRecord]

    static func write(_ value: [CustomTlvRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCustomTlvRecord.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CustomTlvRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [CustomTlvRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeCustomTlvRecord.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetails]

    static func write(_ value: [PaymentDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentDetails.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePaymentDetails.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePeerDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PeerDetails]

    static func write(_ value: [PeerDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeerDetails.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PeerDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PeerDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePeerDetails.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHintHop]

    static func write(_ value: [RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHintHop.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeSpendableUtxo: FfiConverterRustBuffer {
    typealias SwiftType = [SpendableUtxo]

    static func write(_ value: [SpendableUtxo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSpendableUtxo.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SpendableUtxo] {
        let len: Int32 = try readInt(&buf)
        var seq = [SpendableUtxo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSpendableUtxo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeTxInput: FfiConverterRustBuffer {
    typealias SwiftType = [TxInput]

    static func write(_ value: [TxInput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxInput.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxInput] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxInput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTxInput.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeTxOutput: FfiConverterRustBuffer {
    typealias SwiftType = [TxOutput]

    static func write(_ value: [TxOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxOutput.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TxOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [TxOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTxOutput.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = [LightningBalance]

    static func write(_ value: [LightningBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLightningBalance.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LightningBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [LightningBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLightningBalance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = [PendingSweepBalance]

    static func write(_ value: [PendingSweepBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePendingSweepBalance.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PendingSweepBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [PendingSweepBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePendingSweepBalance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [[UInt8]]

    static func write(_ value: [[UInt8]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceUInt8.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[UInt8]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[UInt8]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceUInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [[RouteHintHop]]

    static func write(_ value: [[RouteHintHop]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeRouteHintHop.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[RouteHintHop]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[RouteHintHop]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeNodeId: FfiConverterRustBuffer {
    typealias SwiftType = [NodeId]

    static func write(_ value: [NodeId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeId.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNodeId.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]

    static func write(_ value: [SocketAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSocketAddress.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SocketAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [SocketAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSocketAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeTxid: FfiConverterRustBuffer {
    typealias SwiftType = [Txid]

    static func write(_ value: [Txid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTxid.write(item, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Txid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Txid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTxid.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Address = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Address {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Address) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ value: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BlockHash = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlockHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BlockHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BlockHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BlockHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHash_lift(_ value: RustBuffer) throws -> BlockHash {
    return try FfiConverterTypeBlockHash.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeBlockHash_lower(_ value: BlockHash) -> RustBuffer {
    return FfiConverterTypeBlockHash.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ChannelId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelId_lift(_ value: RustBuffer) throws -> ChannelId {
    return try FfiConverterTypeChannelId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChannelId_lower(_ value: ChannelId) -> RustBuffer {
    return FfiConverterTypeChannelId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Lsps1OrderId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPS1OrderId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1OrderId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Lsps1OrderId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Lsps1OrderId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Lsps1OrderId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderId_lift(_ value: RustBuffer) throws -> Lsps1OrderId {
    return try FfiConverterTypeLSPS1OrderId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPS1OrderId_lower(_ value: Lsps1OrderId) -> RustBuffer {
    return FfiConverterTypeLSPS1OrderId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LspsDateTime = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLSPSDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspsDateTime {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: LspsDateTime, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LspsDateTime {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: LspsDateTime) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPSDateTime_lift(_ value: RustBuffer) throws -> LspsDateTime {
    return try FfiConverterTypeLSPSDateTime.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLSPSDateTime_lower(_ value: LspsDateTime) -> RustBuffer {
    return FfiConverterTypeLSPSDateTime.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Mnemonic = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Mnemonic {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Mnemonic) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ value: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeAlias = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeAlias_lift(_ value: RustBuffer) throws -> NodeAlias {
    return try FfiConverterTypeNodeAlias.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeAlias_lower(_ value: NodeAlias) -> RustBuffer {
    return FfiConverterTypeNodeAlias.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeId_lift(_ value: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OfferId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeOfferId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OfferId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OfferId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OfferId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferId_lift(_ value: RustBuffer) throws -> OfferId {
    return try FfiConverterTypeOfferId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeOfferId_lower(_ value: OfferId) -> RustBuffer {
    return FfiConverterTypeOfferId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentHash = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentHash_lift(_ value: RustBuffer) throws -> PaymentHash {
    return try FfiConverterTypePaymentHash.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentHash_lower(_ value: PaymentHash) -> RustBuffer {
    return FfiConverterTypePaymentHash.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentId_lift(_ value: RustBuffer) throws -> PaymentId {
    return try FfiConverterTypePaymentId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentId_lower(_ value: PaymentId) -> RustBuffer {
    return FfiConverterTypePaymentId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentPreimage = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentPreimage: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentPreimage {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentPreimage, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentPreimage {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentPreimage) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentPreimage_lift(_ value: RustBuffer) throws -> PaymentPreimage {
    return try FfiConverterTypePaymentPreimage.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentPreimage_lower(_ value: PaymentPreimage) -> RustBuffer {
    return FfiConverterTypePaymentPreimage.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentSecret = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentSecret: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentSecret {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentSecret, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentSecret {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentSecret) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentSecret_lift(_ value: RustBuffer) throws -> PaymentSecret {
    return try FfiConverterTypePaymentSecret.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentSecret_lower(_ value: PaymentSecret) -> RustBuffer {
    return FfiConverterTypePaymentSecret.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PublicKey = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PublicKey {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PublicKey) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lift(_ value: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SocketAddress = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSocketAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SocketAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: SocketAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SocketAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: SocketAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSocketAddress_lift(_ value: RustBuffer) throws -> SocketAddress {
    return try FfiConverterTypeSocketAddress.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSocketAddress_lower(_ value: SocketAddress) -> RustBuffer {
    return FfiConverterTypeSocketAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Txid = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTxid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Txid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Txid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Txid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Txid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxid_lift(_ value: RustBuffer) throws -> Txid {
    return try FfiConverterTypeTxid.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTxid_lower(_ value: Txid) -> RustBuffer {
    return FfiConverterTypeTxid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UntrustedString = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeUntrustedString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UntrustedString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UntrustedString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UntrustedString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UntrustedString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUntrustedString_lift(_ value: RustBuffer) throws -> UntrustedString {
    return try FfiConverterTypeUntrustedString.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUntrustedString_lower(_ value: UntrustedString) -> RustBuffer {
    return FfiConverterTypeUntrustedString.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserChannelId = String

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UserChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UserChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UserChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUserChannelId_lift(_ value: RustBuffer) throws -> UserChannelId {
    return try FfiConverterTypeUserChannelId.lift(value)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeUserChannelId_lower(_ value: UserChannelId) -> RustBuffer {
    return FfiConverterTypeUserChannelId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

public func batterySavingSyncIntervals() -> RuntimeSyncIntervals {
    return try! FfiConverterTypeRuntimeSyncIntervals.lift(try! rustCall {
        uniffi_ldk_node_fn_func_battery_saving_sync_intervals($0
        )
    })
}

public func defaultConfig() -> Config {
    return try! FfiConverterTypeConfig.lift(try! rustCall {
        uniffi_ldk_node_fn_func_default_config($0
        )
    })
}

public func deriveNodeSecretFromMnemonic(mnemonic: String, passphrase: String?) throws -> [UInt8] {
    return try FfiConverterSequenceUInt8.lift(rustCallWithError(FfiConverterTypeNodeError.lift) {
        uniffi_ldk_node_fn_func_derive_node_secret_from_mnemonic(
            FfiConverterString.lower(mnemonic),
            FfiConverterOptionString.lower(passphrase), $0
        )
    })
}

public func generateEntropyMnemonic(wordCount: WordCount?) -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_ldk_node_fn_func_generate_entropy_mnemonic(
            FfiConverterOptionTypeWordCount.lower(wordCount), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ldk_node_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_ldk_node_checksum_func_battery_saving_sync_intervals() != 25473 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_func_default_config() != 55381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_func_derive_node_secret_from_mnemonic() != 15067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_func_generate_entropy_mnemonic() != 48014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_amount_milli_satoshis() != 50823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_currency() != 32179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_expiry_time_seconds() != 23625 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_fallback_addresses() != 55276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_invoice_description() != 395 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_is_expired() != 15932 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_min_final_cltv_expiry_delta() != 8855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_network() != 10420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_payment_hash() != 42571 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_payment_secret() != 26081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_recover_payee_pub_key() != 18874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_route_hints() != 63051 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_seconds_since_epoch() != 53979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_seconds_until_expiry() != 64193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_signable_hash() != 30910 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11invoice_would_expire() != 30331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash() != 52848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees() != 5123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees_using_amount() != 46411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash() != 24516 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive() != 6073 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash() != 27050 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount() != 4893 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash() != 1402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel() != 24506 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash() != 38025 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel() != 16532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel_for_hash() != 1143 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send() != 12953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_probes() != 19286 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount() != 5976 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount() != 42793 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_absolute_expiry_seconds() != 28589 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_amount() != 5213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_amount_msats() != 9297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_chain() != 3308 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_created_at() != 56866 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_encode() != 13200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_fallback_addresses() != 7925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_invoice_description() != 1713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_is_expired() != 39560 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_issuer() != 65270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_issuer_signing_pubkey() != 55411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_metadata() != 37374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_offer_chains() != 39622 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_payer_note() != 28018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_payer_signing_pubkey() != 12798 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_payment_hash() != 63778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_quantity() != 43105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_relative_expiry() != 14024 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_signable_hash() != 39303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12invoice_signing_pubkey() != 35202 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_blinded_paths_for_async_recipient() != 14695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund() != 15019 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_receive() != 59252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_receive_async() != 23867 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount() != 35484 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment() != 43248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_send() != 27679 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount() != 33255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_set_paths_to_static_invoice_server() != 20921 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build() != 785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build_with_fs_store() != 61304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build_with_vss_store() != 2871 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_fixed_headers() != 24910 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_header_provider() != 9090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_announcement_addresses() != 39271 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_async_payments_role() != 16463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rest() != 37382 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rpc() != 2111 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_chain_source_electrum() != 55552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora() != 1781 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_channel_data_migration() != 58453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_custom_logger() != 51232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic() != 827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes() != 44799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path() != 64056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_filesystem_logger() != 10249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p() != 9279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs() != 64312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps1() != 51527 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2() != 14430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_listening_addresses() != 14051 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_log_facade_logger() != 58410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_network() != 27539 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_node_alias() != 18342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_pathfinding_scores_source() != 63501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_storage_dir_path() != 59019 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_feerate_to_sat_per_kwu() != 58911 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_ceil() != 58575 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_floor() != 59617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_lsps1liquidity_check_order_status() != 57147 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_lsps1liquidity_request_channel() != 18153 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_logwriter_log() != 3299 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_channel() != 38070 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_list_channels() != 4693 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_list_nodes() != 36715 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_node() != 48925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_announcement_addresses() != 61426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_bolt11_payment() != 41402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_bolt12_payment() != 49254 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_close_channel() != 62479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_config() != 7511 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_connect() != 34120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_current_sync_intervals() != 51918 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_disconnect() != 43538 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_event_handled() != 38712 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_export_pathfinding_scores() != 62331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_force_close_channel() != 48831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_get_address_balance() != 45284 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_get_transaction_details() != 65000 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_balances() != 57528 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_channels() != 7954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_payments() != 35002 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_peers() != 14889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_listening_addresses() != 2665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_lsps1_liquidity() != 38201 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_network_graph() != 2695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_next_event() != 7682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_next_event_async() != 25426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_node_alias() != 29526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_node_id() != 51489 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_onchain_payment() != 6092 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_open_announced_channel() != 36623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_open_channel() != 40283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_payment() != 60296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_remove_payment() != 47952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_sign_message() != 49319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_splice_in() != 46431 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_splice_out() != 22115 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_spontaneous_payment() != 37403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_start() != 58480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_status() != 55952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_stop() != 42188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_sync_wallets() != 32474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_unified_qr_payment() != 9837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_update_channel_config() != 37852 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_update_sync_intervals() != 42322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_verify_signature() != 20486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_wait_next_event() != 55101 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_absolute_expiry_seconds() != 22836 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_amount() != 59890 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_chains() != 59522 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_expects_quantity() != 58457 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_id() != 8391 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_is_expired() != 22651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_is_valid_quantity() != 58469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_issuer() != 41632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_issuer_signing_pubkey() != 38162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_metadata() != 18979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_offer_description() != 11122 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_offer_supports_chain() != 2135 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_accelerate_by_cpfp() != 31954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_bump_fee_by_rbf() != 53877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_calculate_cpfp_fee_rate() != 32879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_calculate_total_fee() != 57218 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_list_spendable_outputs() != 19144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_new_address() != 37251 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_select_utxos_with_algorithm() != 14084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address() != 37748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_send_to_address() != 28826 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_absolute_expiry_seconds() != 43722 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_amount_msats() != 26467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_chain() != 36565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_is_expired() != 10232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_issuer() != 40306 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_payer_metadata() != 23501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_payer_note() != 47799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_payer_signing_pubkey() != 40880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_quantity() != 15192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_refund_refund_description() != 39295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send() != 27905 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes() != 25937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_custom_tlvs() != 17876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage() != 30854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage_and_custom_tlvs() != 12104 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_unifiedqrpayment_receive() != 913 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_unifiedqrpayment_send() != 28285 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_vssheaderprovider_get_headers() != 7788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_bolt11invoice_from_str() != 349 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_bolt12invoice_from_str() != 22276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_builder_from_config() != 994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_builder_new() != 40499 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_kwu() != 50548 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_vb_unchecked() != 41808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_offer_from_str() != 37070 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_refund_from_str() != 64884 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLogWriter()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
