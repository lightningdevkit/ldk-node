// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

import SystemConfiguration
// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(LDKNodeFFI)
import LDKNodeFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ldk_node_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ldk_node_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol Bolt11InvoiceProtocol : AnyObject {
    
    func amountMilliSatoshis()  -> UInt64?
    
    func currency()  -> Currency
    
    func description()  -> Bolt11InvoiceDescription
    
    func expiryTimeSeconds()  -> UInt64
    
    func fallbackAddresses()  -> [Address]
    
    func isExpired()  -> Bool
    
    func minFinalCltvExpiryDelta()  -> UInt64
    
    func network()  -> Network
    
    func paymentHash()  -> PaymentHash
    
    func paymentSecret()  -> PaymentSecret
    
    func recoverPayeePubKey()  -> PublicKey
    
    func routeHints()  -> [[RouteHintHop]]
    
    func secondsSinceEpoch()  -> UInt64
    
    func secondsUntilExpiry()  -> UInt64
    
    func signableHash()  -> [UInt8]
    
    func wouldExpire(atTimeSeconds: UInt64)  -> Bool
    
}

open class Bolt11Invoice:
    Bolt11InvoiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11invoice(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt11invoice(pointer, $0) }
    }

    
public static func fromStr(invoiceStr: String)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_constructor_bolt11invoice_from_str(
        FfiConverterString.lower(invoiceStr),$0
    )
})
}
    

    
open func amountMilliSatoshis() -> UInt64? {
    return try!  FfiConverterOptionUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_amount_milli_satoshis(self.uniffiClonePointer(),$0
    )
})
}
    
open func currency() -> Currency {
    return try!  FfiConverterTypeCurrency.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_currency(self.uniffiClonePointer(),$0
    )
})
}
    
open func description() -> Bolt11InvoiceDescription {
    return try!  FfiConverterTypeBolt11InvoiceDescription.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_description(self.uniffiClonePointer(),$0
    )
})
}
    
open func expiryTimeSeconds() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_expiry_time_seconds(self.uniffiClonePointer(),$0
    )
})
}
    
open func fallbackAddresses() -> [Address] {
    return try!  FfiConverterSequenceTypeAddress.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_fallback_addresses(self.uniffiClonePointer(),$0
    )
})
}
    
open func isExpired() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_is_expired(self.uniffiClonePointer(),$0
    )
})
}
    
open func minFinalCltvExpiryDelta() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_min_final_cltv_expiry_delta(self.uniffiClonePointer(),$0
    )
})
}
    
open func network() -> Network {
    return try!  FfiConverterTypeNetwork.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_network(self.uniffiClonePointer(),$0
    )
})
}
    
open func paymentHash() -> PaymentHash {
    return try!  FfiConverterTypePaymentHash.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_payment_hash(self.uniffiClonePointer(),$0
    )
})
}
    
open func paymentSecret() -> PaymentSecret {
    return try!  FfiConverterTypePaymentSecret.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_payment_secret(self.uniffiClonePointer(),$0
    )
})
}
    
open func recoverPayeePubKey() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_recover_payee_pub_key(self.uniffiClonePointer(),$0
    )
})
}
    
open func routeHints() -> [[RouteHintHop]] {
    return try!  FfiConverterSequenceSequenceTypeRouteHintHop.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_route_hints(self.uniffiClonePointer(),$0
    )
})
}
    
open func secondsSinceEpoch() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_seconds_since_epoch(self.uniffiClonePointer(),$0
    )
})
}
    
open func secondsUntilExpiry() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_seconds_until_expiry(self.uniffiClonePointer(),$0
    )
})
}
    
open func signableHash() -> [UInt8] {
    return try!  FfiConverterSequenceUInt8.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_signable_hash(self.uniffiClonePointer(),$0
    )
})
}
    
open func wouldExpire(atTimeSeconds: UInt64) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_bolt11invoice_would_expire(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(atTimeSeconds),$0
    )
})
}
    

}

public struct FfiConverterTypeBolt11Invoice: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Invoice

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Invoice {
        return Bolt11Invoice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Invoice) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBolt11Invoice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(pointer)
}

public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}




public protocol Bolt11PaymentProtocol : AnyObject {
    
    func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws 
    
    func failForHash(paymentHash: PaymentHash) throws 
    
    func receive(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32) throws  -> Bolt11Invoice
    
    func receiveForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice
    
    func receiveVariableAmount(description: Bolt11InvoiceDescription, expirySecs: UInt32) throws  -> Bolt11Invoice
    
    func receiveVariableAmountForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash) throws  -> Bolt11Invoice
    
    func receiveVariableAmountViaJitChannel(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws  -> Bolt11Invoice
    
    func receiveViaJitChannel(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws  -> Bolt11Invoice
    
    func send(invoice: Bolt11Invoice, sendingParameters: SendingParameters?) throws  -> PaymentId
    
    func sendProbes(invoice: Bolt11Invoice) throws 
    
    func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws 
    
    func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, sendingParameters: SendingParameters?) throws  -> PaymentId
    
}

open class Bolt11Payment:
    Bolt11PaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11payment(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt11payment(pointer, $0) }
    }

    

    
open func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash(self.uniffiClonePointer(),
        FfiConverterTypePaymentHash.lower(paymentHash),
        FfiConverterUInt64.lower(claimableAmountMsat),
        FfiConverterTypePaymentPreimage.lower(preimage),$0
    )
}
}
    
open func failForHash(paymentHash: PaymentHash)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash(self.uniffiClonePointer(),
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
}
}
    
open func receive(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),$0
    )
})
}
    
open func receiveForHash(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
})
}
    
open func receiveVariableAmount(description: Bolt11InvoiceDescription, expirySecs: UInt32)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount(self.uniffiClonePointer(),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),$0
    )
})
}
    
open func receiveVariableAmountForHash(description: Bolt11InvoiceDescription, expirySecs: UInt32, paymentHash: PaymentHash)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash(self.uniffiClonePointer(),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterTypePaymentHash.lower(paymentHash),$0
    )
})
}
    
open func receiveVariableAmountViaJitChannel(description: Bolt11InvoiceDescription, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel(self.uniffiClonePointer(),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(maxProportionalLspFeeLimitPpmMsat),$0
    )
})
}
    
open func receiveViaJitChannel(amountMsat: UInt64, description: Bolt11InvoiceDescription, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?)throws  -> Bolt11Invoice {
    return try  FfiConverterTypeBolt11Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypeBolt11InvoiceDescription.lower(description),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(maxLspFeeLimitMsat),$0
    )
})
}
    
open func send(invoice: Bolt11Invoice, sendingParameters: SendingParameters?)throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send(self.uniffiClonePointer(),
        FfiConverterTypeBolt11Invoice.lower(invoice),
        FfiConverterOptionTypeSendingParameters.lower(sendingParameters),$0
    )
})
}
    
open func sendProbes(invoice: Bolt11Invoice)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_probes(self.uniffiClonePointer(),
        FfiConverterTypeBolt11Invoice.lower(invoice),$0
    )
}
}
    
open func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount(self.uniffiClonePointer(),
        FfiConverterTypeBolt11Invoice.lower(invoice),
        FfiConverterUInt64.lower(amountMsat),$0
    )
}
}
    
open func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, sendingParameters: SendingParameters?)throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt11payment_send_using_amount(self.uniffiClonePointer(),
        FfiConverterTypeBolt11Invoice.lower(invoice),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterOptionTypeSendingParameters.lower(sendingParameters),$0
    )
})
}
    

}

public struct FfiConverterTypeBolt11Payment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
        return Bolt11Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBolt11Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
    return try FfiConverterTypeBolt11Payment.lift(pointer)
}

public func FfiConverterTypeBolt11Payment_lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Payment.lower(value)
}




public protocol Bolt12PaymentProtocol : AnyObject {
    
    func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?) throws  -> Refund
    
    func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?) throws  -> Offer
    
    func receiveVariableAmount(description: String, expirySecs: UInt32?) throws  -> Offer
    
    func requestRefundPayment(refund: Refund) throws  -> Bolt12Invoice
    
    func send(offer: Offer, quantity: UInt64?, payerNote: String?) throws  -> PaymentId
    
    func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?) throws  -> PaymentId
    
}

open class Bolt12Payment:
    Bolt12PaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt12payment(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_bolt12payment(pointer, $0) }
    }

    

    
open func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?)throws  -> Refund {
    return try  FfiConverterTypeRefund.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_initiate_refund(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(quantity),
        FfiConverterOptionString.lower(payerNote),$0
    )
})
}
    
open func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?)throws  -> Offer {
    return try  FfiConverterTypeOffer.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_receive(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterString.lower(description),
        FfiConverterOptionUInt32.lower(expirySecs),
        FfiConverterOptionUInt64.lower(quantity),$0
    )
})
}
    
open func receiveVariableAmount(description: String, expirySecs: UInt32?)throws  -> Offer {
    return try  FfiConverterTypeOffer.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount(self.uniffiClonePointer(),
        FfiConverterString.lower(description),
        FfiConverterOptionUInt32.lower(expirySecs),$0
    )
})
}
    
open func requestRefundPayment(refund: Refund)throws  -> Bolt12Invoice {
    return try  FfiConverterTypeBolt12Invoice.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment(self.uniffiClonePointer(),
        FfiConverterTypeRefund.lower(refund),$0
    )
})
}
    
open func send(offer: Offer, quantity: UInt64?, payerNote: String?)throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_send(self.uniffiClonePointer(),
        FfiConverterTypeOffer.lower(offer),
        FfiConverterOptionUInt64.lower(quantity),
        FfiConverterOptionString.lower(payerNote),$0
    )
})
}
    
open func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?)throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_bolt12payment_send_using_amount(self.uniffiClonePointer(),
        FfiConverterTypeOffer.lower(offer),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterOptionUInt64.lower(quantity),
        FfiConverterOptionString.lower(payerNote),$0
    )
})
}
    

}

public struct FfiConverterTypeBolt12Payment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt12Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
        return Bolt12Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt12Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBolt12Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
    return try FfiConverterTypeBolt12Payment.lift(pointer)
}

public func FfiConverterTypeBolt12Payment_lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt12Payment.lower(value)
}




public protocol BuilderProtocol : AnyObject {
    
    func build() throws  -> Node
    
    func buildWithFsStore() throws  -> Node
    
    func buildWithVssStore(vssUrl: String, storeId: String, lnurlAuthServerUrl: String, fixedHeaders: [String: String]) throws  -> Node
    
    func buildWithVssStoreAndFixedHeaders(vssUrl: String, storeId: String, fixedHeaders: [String: String]) throws  -> Node
    
    func buildWithVssStoreAndHeaderProvider(vssUrl: String, storeId: String, headerProvider: VssHeaderProvider) throws  -> Node
    
    func setAnnouncementAddresses(announcementAddresses: [SocketAddress]) throws 
    
    func setChainSourceBitcoindRpc(rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String) 
    
    func setChainSourceElectrum(serverUrl: String, config: ElectrumSyncConfig?) 
    
    func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?) 
    
    func setCustomLogger(logWriter: LogWriter) 
    
    func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?) 
    
    func setEntropySeedBytes(seedBytes: [UInt8]) throws 
    
    func setEntropySeedPath(seedPath: String) 
    
    func setFilesystemLogger(logFilePath: String?, maxLogLevel: LogLevel?) 
    
    func setGossipSourceP2p() 
    
    func setGossipSourceRgs(rgsServerUrl: String) 
    
    func setLiquiditySourceLsps1(nodeId: PublicKey, address: SocketAddress, token: String?) 
    
    func setLiquiditySourceLsps2(nodeId: PublicKey, address: SocketAddress, token: String?) 
    
    func setListeningAddresses(listeningAddresses: [SocketAddress]) throws 
    
    func setLogFacadeLogger() 
    
    func setNetwork(network: Network) 
    
    func setNodeAlias(nodeAlias: String) throws 
    
    func setStorageDirPath(storageDirPath: String) 
    
}

open class Builder:
    BuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_builder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_ldk_node_fn_constructor_builder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_builder(pointer, $0) }
    }

    
public static func fromConfig(config: Config) -> Builder {
    return try!  FfiConverterTypeBuilder.lift(try! rustCall() {
    uniffi_ldk_node_fn_constructor_builder_from_config(
        FfiConverterTypeConfig.lower(config),$0
    )
})
}
    

    
open func build()throws  -> Node {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build(self.uniffiClonePointer(),$0
    )
})
}
    
open func buildWithFsStore()throws  -> Node {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build_with_fs_store(self.uniffiClonePointer(),$0
    )
})
}
    
open func buildWithVssStore(vssUrl: String, storeId: String, lnurlAuthServerUrl: String, fixedHeaders: [String: String])throws  -> Node {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build_with_vss_store(self.uniffiClonePointer(),
        FfiConverterString.lower(vssUrl),
        FfiConverterString.lower(storeId),
        FfiConverterString.lower(lnurlAuthServerUrl),
        FfiConverterDictionaryStringString.lower(fixedHeaders),$0
    )
})
}
    
open func buildWithVssStoreAndFixedHeaders(vssUrl: String, storeId: String, fixedHeaders: [String: String])throws  -> Node {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_fixed_headers(self.uniffiClonePointer(),
        FfiConverterString.lower(vssUrl),
        FfiConverterString.lower(storeId),
        FfiConverterDictionaryStringString.lower(fixedHeaders),$0
    )
})
}
    
open func buildWithVssStoreAndHeaderProvider(vssUrl: String, storeId: String, headerProvider: VssHeaderProvider)throws  -> Node {
    return try  FfiConverterTypeNode.lift(try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_header_provider(self.uniffiClonePointer(),
        FfiConverterString.lower(vssUrl),
        FfiConverterString.lower(storeId),
        FfiConverterTypeVssHeaderProvider.lower(headerProvider),$0
    )
})
}
    
open func setAnnouncementAddresses(announcementAddresses: [SocketAddress])throws  {try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_announcement_addresses(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSocketAddress.lower(announcementAddresses),$0
    )
}
}
    
open func setChainSourceBitcoindRpc(rpcHost: String, rpcPort: UInt16, rpcUser: String, rpcPassword: String) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rpc(self.uniffiClonePointer(),
        FfiConverterString.lower(rpcHost),
        FfiConverterUInt16.lower(rpcPort),
        FfiConverterString.lower(rpcUser),
        FfiConverterString.lower(rpcPassword),$0
    )
}
}
    
open func setChainSourceElectrum(serverUrl: String, config: ElectrumSyncConfig?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_chain_source_electrum(self.uniffiClonePointer(),
        FfiConverterString.lower(serverUrl),
        FfiConverterOptionTypeElectrumSyncConfig.lower(config),$0
    )
}
}
    
open func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_chain_source_esplora(self.uniffiClonePointer(),
        FfiConverterString.lower(serverUrl),
        FfiConverterOptionTypeEsploraSyncConfig.lower(config),$0
    )
}
}
    
open func setCustomLogger(logWriter: LogWriter) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_custom_logger(self.uniffiClonePointer(),
        FfiConverterTypeLogWriter.lower(logWriter),$0
    )
}
}
    
open func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic(self.uniffiClonePointer(),
        FfiConverterTypeMnemonic.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),$0
    )
}
}
    
open func setEntropySeedBytes(seedBytes: [UInt8])throws  {try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes(self.uniffiClonePointer(),
        FfiConverterSequenceUInt8.lower(seedBytes),$0
    )
}
}
    
open func setEntropySeedPath(seedPath: String) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_entropy_seed_path(self.uniffiClonePointer(),
        FfiConverterString.lower(seedPath),$0
    )
}
}
    
open func setFilesystemLogger(logFilePath: String?, maxLogLevel: LogLevel?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_filesystem_logger(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(logFilePath),
        FfiConverterOptionTypeLogLevel.lower(maxLogLevel),$0
    )
}
}
    
open func setGossipSourceP2p() {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p(self.uniffiClonePointer(),$0
    )
}
}
    
open func setGossipSourceRgs(rgsServerUrl: String) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs(self.uniffiClonePointer(),
        FfiConverterString.lower(rgsServerUrl),$0
    )
}
}
    
open func setLiquiditySourceLsps1(nodeId: PublicKey, address: SocketAddress, token: String?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps1(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterOptionString.lower(token),$0
    )
}
}
    
open func setLiquiditySourceLsps2(nodeId: PublicKey, address: SocketAddress, token: String?) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterOptionString.lower(token),$0
    )
}
}
    
open func setListeningAddresses(listeningAddresses: [SocketAddress])throws  {try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_listening_addresses(self.uniffiClonePointer(),
        FfiConverterSequenceTypeSocketAddress.lower(listeningAddresses),$0
    )
}
}
    
open func setLogFacadeLogger() {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_log_facade_logger(self.uniffiClonePointer(),$0
    )
}
}
    
open func setNetwork(network: Network) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_network(self.uniffiClonePointer(),
        FfiConverterTypeNetwork.lower(network),$0
    )
}
}
    
open func setNodeAlias(nodeAlias: String)throws  {try rustCallWithError(FfiConverterTypeBuildError.lift) {
    uniffi_ldk_node_fn_method_builder_set_node_alias(self.uniffiClonePointer(),
        FfiConverterString.lower(nodeAlias),$0
    )
}
}
    
open func setStorageDirPath(storageDirPath: String) {try! rustCall() {
    uniffi_ldk_node_fn_method_builder_set_storage_dir_path(self.uniffiClonePointer(),
        FfiConverterString.lower(storageDirPath),$0
    )
}
}
    

}

public struct FfiConverterTypeBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Builder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
        return Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Builder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
    return try FfiConverterTypeBuilder.lift(pointer)
}

public func FfiConverterTypeBuilder_lower(_ value: Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBuilder.lower(value)
}




public protocol FeeRateProtocol : AnyObject {
    
    func toSatPerKwu()  -> UInt64
    
    func toSatPerVbCeil()  -> UInt64
    
    func toSatPerVbFloor()  -> UInt64
    
}

open class FeeRate:
    FeeRateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_feerate(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_feerate(pointer, $0) }
    }

    
public static func fromSatPerKwu(satKwu: UInt64) -> FeeRate {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_ldk_node_fn_constructor_feerate_from_sat_per_kwu(
        FfiConverterUInt64.lower(satKwu),$0
    )
})
}
    
public static func fromSatPerVbUnchecked(satVb: UInt64) -> FeeRate {
    return try!  FfiConverterTypeFeeRate.lift(try! rustCall() {
    uniffi_ldk_node_fn_constructor_feerate_from_sat_per_vb_unchecked(
        FfiConverterUInt64.lower(satVb),$0
    )
})
}
    

    
open func toSatPerKwu() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_feerate_to_sat_per_kwu(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbCeil() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_ceil(self.uniffiClonePointer(),$0
    )
})
}
    
open func toSatPerVbFloor() -> UInt64 {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_floor(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeFeeRate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FeeRate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
        return FeeRate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeRate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FeeRate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeFeeRate_lift(_ pointer: UnsafeMutableRawPointer) throws -> FeeRate {
    return try FfiConverterTypeFeeRate.lift(pointer)
}

public func FfiConverterTypeFeeRate_lower(_ value: FeeRate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFeeRate.lower(value)
}




public protocol Lsps1LiquidityProtocol : AnyObject {
    
    func checkOrderStatus(orderId: OrderId) throws  -> Lsps1OrderStatus
    
    func requestChannel(lspBalanceSat: UInt64, clientBalanceSat: UInt64, channelExpiryBlocks: UInt32, announceChannel: Bool) throws  -> Lsps1OrderStatus
    
}

open class Lsps1Liquidity:
    Lsps1LiquidityProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_lsps1liquidity(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_lsps1liquidity(pointer, $0) }
    }

    

    
open func checkOrderStatus(orderId: OrderId)throws  -> Lsps1OrderStatus {
    return try  FfiConverterTypeLSPS1OrderStatus.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_lsps1liquidity_check_order_status(self.uniffiClonePointer(),
        FfiConverterTypeOrderId.lower(orderId),$0
    )
})
}
    
open func requestChannel(lspBalanceSat: UInt64, clientBalanceSat: UInt64, channelExpiryBlocks: UInt32, announceChannel: Bool)throws  -> Lsps1OrderStatus {
    return try  FfiConverterTypeLSPS1OrderStatus.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_lsps1liquidity_request_channel(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(lspBalanceSat),
        FfiConverterUInt64.lower(clientBalanceSat),
        FfiConverterUInt32.lower(channelExpiryBlocks),
        FfiConverterBool.lower(announceChannel),$0
    )
})
}
    

}

public struct FfiConverterTypeLSPS1Liquidity: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Lsps1Liquidity

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Lsps1Liquidity {
        return Lsps1Liquidity(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Lsps1Liquidity) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1Liquidity {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Lsps1Liquidity, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLSPS1Liquidity_lift(_ pointer: UnsafeMutableRawPointer) throws -> Lsps1Liquidity {
    return try FfiConverterTypeLSPS1Liquidity.lift(pointer)
}

public func FfiConverterTypeLSPS1Liquidity_lower(_ value: Lsps1Liquidity) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLSPS1Liquidity.lower(value)
}




public protocol LogWriter : AnyObject {
    
    func log(record: LogRecord) 
    
}

open class LogWriterImpl:
    LogWriter {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_logwriter(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_logwriter(pointer, $0) }
    }

    

    
open func log(record: LogRecord) {try! rustCall() {
    uniffi_ldk_node_fn_method_logwriter_log(self.uniffiClonePointer(),
        FfiConverterTypeLogRecord.lower(record),$0
    )
}
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogWriter {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLogWriter = UniffiVTableCallbackInterfaceLogWriter(
        log: { (
            uniffiHandle: UInt64,
            record: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogWriter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     record: try FfiConverterTypeLogRecord.lift(record)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLogWriter.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LogWriter: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLogWriter() {
    uniffi_ldk_node_fn_init_callback_vtable_logwriter(&UniffiCallbackInterfaceLogWriter.vtable)
}

public struct FfiConverterTypeLogWriter: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<LogWriter>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LogWriter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
        return LogWriterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogWriter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LogWriter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeLogWriter_lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
    return try FfiConverterTypeLogWriter.lift(pointer)
}

public func FfiConverterTypeLogWriter_lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogWriter.lower(value)
}




public protocol NetworkGraphProtocol : AnyObject {
    
    func channel(shortChannelId: UInt64)  -> ChannelInfo?
    
    func listChannels()  -> [UInt64]
    
    func listNodes()  -> [NodeId]
    
    func node(nodeId: NodeId)  -> NodeInfo?
    
}

open class NetworkGraph:
    NetworkGraphProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_networkgraph(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_networkgraph(pointer, $0) }
    }

    

    
open func channel(shortChannelId: UInt64) -> ChannelInfo? {
    return try!  FfiConverterOptionTypeChannelInfo.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_networkgraph_channel(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(shortChannelId),$0
    )
})
}
    
open func listChannels() -> [UInt64] {
    return try!  FfiConverterSequenceUInt64.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_networkgraph_list_channels(self.uniffiClonePointer(),$0
    )
})
}
    
open func listNodes() -> [NodeId] {
    return try!  FfiConverterSequenceTypeNodeId.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_networkgraph_list_nodes(self.uniffiClonePointer(),$0
    )
})
}
    
open func node(nodeId: NodeId) -> NodeInfo? {
    return try!  FfiConverterOptionTypeNodeInfo.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_networkgraph_node(self.uniffiClonePointer(),
        FfiConverterTypeNodeId.lower(nodeId),$0
    )
})
}
    

}

public struct FfiConverterTypeNetworkGraph: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkGraph

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
        return NetworkGraph(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkGraph {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkGraph, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNetworkGraph_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
    return try FfiConverterTypeNetworkGraph.lift(pointer)
}

public func FfiConverterTypeNetworkGraph_lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkGraph.lower(value)
}




public protocol NodeProtocol : AnyObject {
    
    func announcementAddresses()  -> [SocketAddress]?
    
    func bolt11Payment()  -> Bolt11Payment
    
    func bolt12Payment()  -> Bolt12Payment
    
    func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws 
    
    func config()  -> Config
    
    func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws 
    
    func disconnect(nodeId: PublicKey) throws 
    
    func eventHandled() throws 
    
    func exportPathfindingScores() throws  -> Data
    
    func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?) throws 
    
    func listBalances()  -> BalanceDetails
    
    func listChannels()  -> [ChannelDetails]
    
    func listPayments()  -> [PaymentDetails]
    
    func listPeers()  -> [PeerDetails]
    
    func listeningAddresses()  -> [SocketAddress]?
    
    func lsps1Liquidity()  -> Lsps1Liquidity
    
    func networkGraph()  -> NetworkGraph
    
    func nextEvent()  -> Event?
    
    func nextEventAsync() async  -> Event
    
    func nodeAlias()  -> NodeAlias?
    
    func nodeId()  -> PublicKey
    
    func onchainPayment()  -> OnchainPayment
    
    func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws  -> UserChannelId
    
    func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws  -> UserChannelId
    
    func payment(paymentId: PaymentId)  -> PaymentDetails?
    
    func removePayment(paymentId: PaymentId) throws 
    
    func signMessage(msg: [UInt8])  -> String
    
    func spontaneousPayment()  -> SpontaneousPayment
    
    func start() throws 
    
    func status()  -> NodeStatus
    
    func stop() throws 
    
    func syncWallets() throws 
    
    func unifiedQrPayment()  -> UnifiedQrPayment
    
    func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws 
    
    func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey)  -> Bool
    
    func waitNextEvent()  -> Event
    
}

open class Node:
    NodeProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_node(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_node(pointer, $0) }
    }

    

    
open func announcementAddresses() -> [SocketAddress]? {
    return try!  FfiConverterOptionSequenceTypeSocketAddress.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_announcement_addresses(self.uniffiClonePointer(),$0
    )
})
}
    
open func bolt11Payment() -> Bolt11Payment {
    return try!  FfiConverterTypeBolt11Payment.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_bolt11_payment(self.uniffiClonePointer(),$0
    )
})
}
    
open func bolt12Payment() -> Bolt12Payment {
    return try!  FfiConverterTypeBolt12Payment.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_bolt12_payment(self.uniffiClonePointer(),$0
    )
})
}
    
open func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_close_channel(self.uniffiClonePointer(),
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),$0
    )
}
}
    
open func config() -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_config(self.uniffiClonePointer(),$0
    )
})
}
    
open func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_connect(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterBool.lower(persist),$0
    )
}
}
    
open func disconnect(nodeId: PublicKey)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_disconnect(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),$0
    )
}
}
    
open func eventHandled()throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_event_handled(self.uniffiClonePointer(),$0
    )
}
}
    
open func exportPathfindingScores()throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_export_pathfinding_scores(self.uniffiClonePointer(),$0
    )
})
}
    
open func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_force_close_channel(self.uniffiClonePointer(),
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),
        FfiConverterOptionString.lower(reason),$0
    )
}
}
    
open func listBalances() -> BalanceDetails {
    return try!  FfiConverterTypeBalanceDetails.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_list_balances(self.uniffiClonePointer(),$0
    )
})
}
    
open func listChannels() -> [ChannelDetails] {
    return try!  FfiConverterSequenceTypeChannelDetails.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_list_channels(self.uniffiClonePointer(),$0
    )
})
}
    
open func listPayments() -> [PaymentDetails] {
    return try!  FfiConverterSequenceTypePaymentDetails.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_list_payments(self.uniffiClonePointer(),$0
    )
})
}
    
open func listPeers() -> [PeerDetails] {
    return try!  FfiConverterSequenceTypePeerDetails.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_list_peers(self.uniffiClonePointer(),$0
    )
})
}
    
open func listeningAddresses() -> [SocketAddress]? {
    return try!  FfiConverterOptionSequenceTypeSocketAddress.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_listening_addresses(self.uniffiClonePointer(),$0
    )
})
}
    
open func lsps1Liquidity() -> Lsps1Liquidity {
    return try!  FfiConverterTypeLSPS1Liquidity.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_lsps1_liquidity(self.uniffiClonePointer(),$0
    )
})
}
    
open func networkGraph() -> NetworkGraph {
    return try!  FfiConverterTypeNetworkGraph.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_network_graph(self.uniffiClonePointer(),$0
    )
})
}
    
open func nextEvent() -> Event? {
    return try!  FfiConverterOptionTypeEvent.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_next_event(self.uniffiClonePointer(),$0
    )
})
}
    
open func nextEventAsync()async  -> Event {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_ldk_node_fn_method_node_next_event_async(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
            completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
            freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEvent.lift,
            errorHandler: nil
            
        )
}
    
open func nodeAlias() -> NodeAlias? {
    return try!  FfiConverterOptionTypeNodeAlias.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_node_alias(self.uniffiClonePointer(),$0
    )
})
}
    
open func nodeId() -> PublicKey {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_node_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func onchainPayment() -> OnchainPayment {
    return try!  FfiConverterTypeOnchainPayment.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_onchain_payment(self.uniffiClonePointer(),$0
    )
})
}
    
open func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?)throws  -> UserChannelId {
    return try  FfiConverterTypeUserChannelId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_open_announced_channel(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterUInt64.lower(channelAmountSats),
        FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
        FfiConverterOptionTypeChannelConfig.lower(channelConfig),$0
    )
})
}
    
open func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?)throws  -> UserChannelId {
    return try  FfiConverterTypeUserChannelId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_open_channel(self.uniffiClonePointer(),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterTypeSocketAddress.lower(address),
        FfiConverterUInt64.lower(channelAmountSats),
        FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
        FfiConverterOptionTypeChannelConfig.lower(channelConfig),$0
    )
})
}
    
open func payment(paymentId: PaymentId) -> PaymentDetails? {
    return try!  FfiConverterOptionTypePaymentDetails.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_payment(self.uniffiClonePointer(),
        FfiConverterTypePaymentId.lower(paymentId),$0
    )
})
}
    
open func removePayment(paymentId: PaymentId)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_remove_payment(self.uniffiClonePointer(),
        FfiConverterTypePaymentId.lower(paymentId),$0
    )
}
}
    
open func signMessage(msg: [UInt8]) -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_sign_message(self.uniffiClonePointer(),
        FfiConverterSequenceUInt8.lower(msg),$0
    )
})
}
    
open func spontaneousPayment() -> SpontaneousPayment {
    return try!  FfiConverterTypeSpontaneousPayment.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_spontaneous_payment(self.uniffiClonePointer(),$0
    )
})
}
    
open func start()throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_start(self.uniffiClonePointer(),$0
    )
}
}
    
open func status() -> NodeStatus {
    return try!  FfiConverterTypeNodeStatus.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func stop()throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_stop(self.uniffiClonePointer(),$0
    )
}
}
    
open func syncWallets()throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_sync_wallets(self.uniffiClonePointer(),$0
    )
}
}
    
open func unifiedQrPayment() -> UnifiedQrPayment {
    return try!  FfiConverterTypeUnifiedQrPayment.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_unified_qr_payment(self.uniffiClonePointer(),$0
    )
})
}
    
open func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_node_update_channel_config(self.uniffiClonePointer(),
        FfiConverterTypeUserChannelId.lower(userChannelId),
        FfiConverterTypePublicKey.lower(counterpartyNodeId),
        FfiConverterTypeChannelConfig.lower(channelConfig),$0
    )
}
}
    
open func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_verify_signature(self.uniffiClonePointer(),
        FfiConverterSequenceUInt8.lower(msg),
        FfiConverterString.lower(sig),
        FfiConverterTypePublicKey.lower(pkey),$0
    )
})
}
    
open func waitNextEvent() -> Event {
    return try!  FfiConverterTypeEvent.lift(try! rustCall() {
    uniffi_ldk_node_fn_method_node_wait_next_event(self.uniffiClonePointer(),$0
    )
})
}
    

}

public struct FfiConverterTypeNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Node

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
        return Node(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Node) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
    return try FfiConverterTypeNode.lift(pointer)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNode.lower(value)
}




public protocol OnchainPaymentProtocol : AnyObject {
    
    func newAddress() throws  -> Address
    
    func sendAllToAddress(address: Address, retainReserve: Bool, feeRate: FeeRate?) throws  -> Txid
    
    func sendToAddress(address: Address, amountSats: UInt64, feeRate: FeeRate?) throws  -> Txid
    
}

open class OnchainPayment:
    OnchainPaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_onchainpayment(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_onchainpayment(pointer, $0) }
    }

    

    
open func newAddress()throws  -> Address {
    return try  FfiConverterTypeAddress.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_new_address(self.uniffiClonePointer(),$0
    )
})
}
    
open func sendAllToAddress(address: Address, retainReserve: Bool, feeRate: FeeRate?)throws  -> Txid {
    return try  FfiConverterTypeTxid.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address(self.uniffiClonePointer(),
        FfiConverterTypeAddress.lower(address),
        FfiConverterBool.lower(retainReserve),
        FfiConverterOptionTypeFeeRate.lower(feeRate),$0
    )
})
}
    
open func sendToAddress(address: Address, amountSats: UInt64, feeRate: FeeRate?)throws  -> Txid {
    return try  FfiConverterTypeTxid.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_onchainpayment_send_to_address(self.uniffiClonePointer(),
        FfiConverterTypeAddress.lower(address),
        FfiConverterUInt64.lower(amountSats),
        FfiConverterOptionTypeFeeRate.lower(feeRate),$0
    )
})
}
    

}

public struct FfiConverterTypeOnchainPayment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OnchainPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
        return OnchainPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OnchainPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeOnchainPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
    return try FfiConverterTypeOnchainPayment.lift(pointer)
}

public func FfiConverterTypeOnchainPayment_lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnchainPayment.lower(value)
}




public protocol SpontaneousPaymentProtocol : AnyObject {
    
    func send(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?) throws  -> PaymentId
    
    func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws 
    
    func sendWithCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?, customTlvs: [CustomTlvRecord]) throws  -> PaymentId
    
}

open class SpontaneousPayment:
    SpontaneousPaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_spontaneouspayment(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_spontaneouspayment(pointer, $0) }
    }

    

    
open func send(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?)throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_spontaneouspayment_send(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterOptionTypeSendingParameters.lower(sendingParameters),$0
    )
})
}
    
open func sendProbes(amountMsat: UInt64, nodeId: PublicKey)throws  {try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_spontaneouspayment_send_probes(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypePublicKey.lower(nodeId),$0
    )
}
}
    
open func sendWithCustomTlvs(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?, customTlvs: [CustomTlvRecord])throws  -> PaymentId {
    return try  FfiConverterTypePaymentId.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_spontaneouspayment_send_with_custom_tlvs(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountMsat),
        FfiConverterTypePublicKey.lower(nodeId),
        FfiConverterOptionTypeSendingParameters.lower(sendingParameters),
        FfiConverterSequenceTypeCustomTlvRecord.lower(customTlvs),$0
    )
})
}
    

}

public struct FfiConverterTypeSpontaneousPayment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpontaneousPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
        return SpontaneousPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpontaneousPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpontaneousPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeSpontaneousPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
    return try FfiConverterTypeSpontaneousPayment.lift(pointer)
}

public func FfiConverterTypeSpontaneousPayment_lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpontaneousPayment.lower(value)
}




public protocol UnifiedQrPaymentProtocol : AnyObject {
    
    func receive(amountSats: UInt64, message: String, expirySec: UInt32) throws  -> String
    
    func send(uriStr: String) throws  -> QrPaymentResult
    
}

open class UnifiedQrPayment:
    UnifiedQrPaymentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_unifiedqrpayment(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_unifiedqrpayment(pointer, $0) }
    }

    

    
open func receive(amountSats: UInt64, message: String, expirySec: UInt32)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_unifiedqrpayment_receive(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(amountSats),
        FfiConverterString.lower(message),
        FfiConverterUInt32.lower(expirySec),$0
    )
})
}
    
open func send(uriStr: String)throws  -> QrPaymentResult {
    return try  FfiConverterTypeQrPaymentResult.lift(try rustCallWithError(FfiConverterTypeNodeError.lift) {
    uniffi_ldk_node_fn_method_unifiedqrpayment_send(self.uniffiClonePointer(),
        FfiConverterString.lower(uriStr),$0
    )
})
}
    

}

public struct FfiConverterTypeUnifiedQrPayment: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnifiedQrPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
        return UnifiedQrPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnifiedQrPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnifiedQrPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeUnifiedQrPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
    return try FfiConverterTypeUnifiedQrPayment.lift(pointer)
}

public func FfiConverterTypeUnifiedQrPayment_lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnifiedQrPayment.lower(value)
}




public protocol VssHeaderProviderProtocol : AnyObject {
    
    func getHeaders(request: [UInt8]) async throws  -> [String: String]
    
}

open class VssHeaderProvider:
    VssHeaderProviderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_vssheaderprovider(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ldk_node_fn_free_vssheaderprovider(pointer, $0) }
    }

    

    
open func getHeaders(request: [UInt8])async throws  -> [String: String] {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_ldk_node_fn_method_vssheaderprovider_get_headers(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceUInt8.lower(request)
                )
            },
            pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
            completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
            freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringString.lift,
            errorHandler: FfiConverterTypeVssHeaderProviderError.lift
        )
}
    

}

public struct FfiConverterTypeVssHeaderProvider: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VssHeaderProvider

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VssHeaderProvider {
        return VssHeaderProvider(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VssHeaderProvider) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VssHeaderProvider {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VssHeaderProvider, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




public func FfiConverterTypeVssHeaderProvider_lift(_ pointer: UnsafeMutableRawPointer) throws -> VssHeaderProvider {
    return try FfiConverterTypeVssHeaderProvider.lift(pointer)
}

public func FfiConverterTypeVssHeaderProvider_lower(_ value: VssHeaderProvider) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVssHeaderProvider.lower(value)
}


public struct AnchorChannelsConfig {
    public var trustedPeersNoReserve: [PublicKey]
    public var perChannelReserveSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(trustedPeersNoReserve: [PublicKey], perChannelReserveSats: UInt64) {
        self.trustedPeersNoReserve = trustedPeersNoReserve
        self.perChannelReserveSats = perChannelReserveSats
    }
}



extension AnchorChannelsConfig: Equatable, Hashable {
    public static func ==(lhs: AnchorChannelsConfig, rhs: AnchorChannelsConfig) -> Bool {
        if lhs.trustedPeersNoReserve != rhs.trustedPeersNoReserve {
            return false
        }
        if lhs.perChannelReserveSats != rhs.perChannelReserveSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustedPeersNoReserve)
        hasher.combine(perChannelReserveSats)
    }
}


public struct FfiConverterTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnchorChannelsConfig {
        return
            try AnchorChannelsConfig(
                trustedPeersNoReserve: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                perChannelReserveSats: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AnchorChannelsConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.trustedPeersNoReserve, into: &buf)
        FfiConverterUInt64.write(value.perChannelReserveSats, into: &buf)
    }
}


public func FfiConverterTypeAnchorChannelsConfig_lift(_ buf: RustBuffer) throws -> AnchorChannelsConfig {
    return try FfiConverterTypeAnchorChannelsConfig.lift(buf)
}

public func FfiConverterTypeAnchorChannelsConfig_lower(_ value: AnchorChannelsConfig) -> RustBuffer {
    return FfiConverterTypeAnchorChannelsConfig.lower(value)
}


public struct BackgroundSyncConfig {
    public var onchainWalletSyncIntervalSecs: UInt64
    public var lightningWalletSyncIntervalSecs: UInt64
    public var feeRateCacheUpdateIntervalSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(onchainWalletSyncIntervalSecs: UInt64, lightningWalletSyncIntervalSecs: UInt64, feeRateCacheUpdateIntervalSecs: UInt64) {
        self.onchainWalletSyncIntervalSecs = onchainWalletSyncIntervalSecs
        self.lightningWalletSyncIntervalSecs = lightningWalletSyncIntervalSecs
        self.feeRateCacheUpdateIntervalSecs = feeRateCacheUpdateIntervalSecs
    }
}



extension BackgroundSyncConfig: Equatable, Hashable {
    public static func ==(lhs: BackgroundSyncConfig, rhs: BackgroundSyncConfig) -> Bool {
        if lhs.onchainWalletSyncIntervalSecs != rhs.onchainWalletSyncIntervalSecs {
            return false
        }
        if lhs.lightningWalletSyncIntervalSecs != rhs.lightningWalletSyncIntervalSecs {
            return false
        }
        if lhs.feeRateCacheUpdateIntervalSecs != rhs.feeRateCacheUpdateIntervalSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onchainWalletSyncIntervalSecs)
        hasher.combine(lightningWalletSyncIntervalSecs)
        hasher.combine(feeRateCacheUpdateIntervalSecs)
    }
}


public struct FfiConverterTypeBackgroundSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackgroundSyncConfig {
        return
            try BackgroundSyncConfig(
                onchainWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf), 
                lightningWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf), 
                feeRateCacheUpdateIntervalSecs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BackgroundSyncConfig, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.onchainWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.lightningWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.feeRateCacheUpdateIntervalSecs, into: &buf)
    }
}


public func FfiConverterTypeBackgroundSyncConfig_lift(_ buf: RustBuffer) throws -> BackgroundSyncConfig {
    return try FfiConverterTypeBackgroundSyncConfig.lift(buf)
}

public func FfiConverterTypeBackgroundSyncConfig_lower(_ value: BackgroundSyncConfig) -> RustBuffer {
    return FfiConverterTypeBackgroundSyncConfig.lower(value)
}


public struct BalanceDetails {
    public var totalOnchainBalanceSats: UInt64
    public var spendableOnchainBalanceSats: UInt64
    public var totalAnchorChannelsReserveSats: UInt64
    public var totalLightningBalanceSats: UInt64
    public var lightningBalances: [LightningBalance]
    public var pendingBalancesFromChannelClosures: [PendingSweepBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalOnchainBalanceSats: UInt64, spendableOnchainBalanceSats: UInt64, totalAnchorChannelsReserveSats: UInt64, totalLightningBalanceSats: UInt64, lightningBalances: [LightningBalance], pendingBalancesFromChannelClosures: [PendingSweepBalance]) {
        self.totalOnchainBalanceSats = totalOnchainBalanceSats
        self.spendableOnchainBalanceSats = spendableOnchainBalanceSats
        self.totalAnchorChannelsReserveSats = totalAnchorChannelsReserveSats
        self.totalLightningBalanceSats = totalLightningBalanceSats
        self.lightningBalances = lightningBalances
        self.pendingBalancesFromChannelClosures = pendingBalancesFromChannelClosures
    }
}



extension BalanceDetails: Equatable, Hashable {
    public static func ==(lhs: BalanceDetails, rhs: BalanceDetails) -> Bool {
        if lhs.totalOnchainBalanceSats != rhs.totalOnchainBalanceSats {
            return false
        }
        if lhs.spendableOnchainBalanceSats != rhs.spendableOnchainBalanceSats {
            return false
        }
        if lhs.totalAnchorChannelsReserveSats != rhs.totalAnchorChannelsReserveSats {
            return false
        }
        if lhs.totalLightningBalanceSats != rhs.totalLightningBalanceSats {
            return false
        }
        if lhs.lightningBalances != rhs.lightningBalances {
            return false
        }
        if lhs.pendingBalancesFromChannelClosures != rhs.pendingBalancesFromChannelClosures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalOnchainBalanceSats)
        hasher.combine(spendableOnchainBalanceSats)
        hasher.combine(totalAnchorChannelsReserveSats)
        hasher.combine(totalLightningBalanceSats)
        hasher.combine(lightningBalances)
        hasher.combine(pendingBalancesFromChannelClosures)
    }
}


public struct FfiConverterTypeBalanceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceDetails {
        return
            try BalanceDetails(
                totalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), 
                spendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf), 
                totalAnchorChannelsReserveSats: FfiConverterUInt64.read(from: &buf), 
                totalLightningBalanceSats: FfiConverterUInt64.read(from: &buf), 
                lightningBalances: FfiConverterSequenceTypeLightningBalance.read(from: &buf), 
                pendingBalancesFromChannelClosures: FfiConverterSequenceTypePendingSweepBalance.read(from: &buf)
        )
    }

    public static func write(_ value: BalanceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.totalOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.spendableOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.totalAnchorChannelsReserveSats, into: &buf)
        FfiConverterUInt64.write(value.totalLightningBalanceSats, into: &buf)
        FfiConverterSequenceTypeLightningBalance.write(value.lightningBalances, into: &buf)
        FfiConverterSequenceTypePendingSweepBalance.write(value.pendingBalancesFromChannelClosures, into: &buf)
    }
}


public func FfiConverterTypeBalanceDetails_lift(_ buf: RustBuffer) throws -> BalanceDetails {
    return try FfiConverterTypeBalanceDetails.lift(buf)
}

public func FfiConverterTypeBalanceDetails_lower(_ value: BalanceDetails) -> RustBuffer {
    return FfiConverterTypeBalanceDetails.lower(value)
}


public struct BestBlock {
    public var blockHash: BlockHash
    public var height: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(blockHash: BlockHash, height: UInt32) {
        self.blockHash = blockHash
        self.height = height
    }
}



extension BestBlock: Equatable, Hashable {
    public static func ==(lhs: BestBlock, rhs: BestBlock) -> Bool {
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHash)
        hasher.combine(height)
    }
}


public struct FfiConverterTypeBestBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BestBlock {
        return
            try BestBlock(
                blockHash: FfiConverterTypeBlockHash.read(from: &buf), 
                height: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: BestBlock, into buf: inout [UInt8]) {
        FfiConverterTypeBlockHash.write(value.blockHash, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
    }
}


public func FfiConverterTypeBestBlock_lift(_ buf: RustBuffer) throws -> BestBlock {
    return try FfiConverterTypeBestBlock.lift(buf)
}

public func FfiConverterTypeBestBlock_lower(_ value: BestBlock) -> RustBuffer {
    return FfiConverterTypeBestBlock.lower(value)
}


public struct Bolt11PaymentInfo {
    public var state: PaymentState
    public var expiresAt: DateTime
    public var feeTotalSat: UInt64
    public var orderTotalSat: UInt64
    public var invoice: Bolt11Invoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: PaymentState, expiresAt: DateTime, feeTotalSat: UInt64, orderTotalSat: UInt64, invoice: Bolt11Invoice) {
        self.state = state
        self.expiresAt = expiresAt
        self.feeTotalSat = feeTotalSat
        self.orderTotalSat = orderTotalSat
        self.invoice = invoice
    }
}



public struct FfiConverterTypeBolt11PaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11PaymentInfo {
        return
            try Bolt11PaymentInfo(
                state: FfiConverterTypePaymentState.read(from: &buf), 
                expiresAt: FfiConverterTypeDateTime.read(from: &buf), 
                feeTotalSat: FfiConverterUInt64.read(from: &buf), 
                orderTotalSat: FfiConverterUInt64.read(from: &buf), 
                invoice: FfiConverterTypeBolt11Invoice.read(from: &buf)
        )
    }

    public static func write(_ value: Bolt11PaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentState.write(value.state, into: &buf)
        FfiConverterTypeDateTime.write(value.expiresAt, into: &buf)
        FfiConverterUInt64.write(value.feeTotalSat, into: &buf)
        FfiConverterUInt64.write(value.orderTotalSat, into: &buf)
        FfiConverterTypeBolt11Invoice.write(value.invoice, into: &buf)
    }
}


public func FfiConverterTypeBolt11PaymentInfo_lift(_ buf: RustBuffer) throws -> Bolt11PaymentInfo {
    return try FfiConverterTypeBolt11PaymentInfo.lift(buf)
}

public func FfiConverterTypeBolt11PaymentInfo_lower(_ value: Bolt11PaymentInfo) -> RustBuffer {
    return FfiConverterTypeBolt11PaymentInfo.lower(value)
}


public struct ChannelConfig {
    public var forwardingFeeProportionalMillionths: UInt32
    public var forwardingFeeBaseMsat: UInt32
    public var cltvExpiryDelta: UInt16
    public var maxDustHtlcExposure: MaxDustHtlcExposure
    public var forceCloseAvoidanceMaxFeeSatoshis: UInt64
    public var acceptUnderpayingHtlcs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(forwardingFeeProportionalMillionths: UInt32, forwardingFeeBaseMsat: UInt32, cltvExpiryDelta: UInt16, maxDustHtlcExposure: MaxDustHtlcExposure, forceCloseAvoidanceMaxFeeSatoshis: UInt64, acceptUnderpayingHtlcs: Bool) {
        self.forwardingFeeProportionalMillionths = forwardingFeeProportionalMillionths
        self.forwardingFeeBaseMsat = forwardingFeeBaseMsat
        self.cltvExpiryDelta = cltvExpiryDelta
        self.maxDustHtlcExposure = maxDustHtlcExposure
        self.forceCloseAvoidanceMaxFeeSatoshis = forceCloseAvoidanceMaxFeeSatoshis
        self.acceptUnderpayingHtlcs = acceptUnderpayingHtlcs
    }
}



extension ChannelConfig: Equatable, Hashable {
    public static func ==(lhs: ChannelConfig, rhs: ChannelConfig) -> Bool {
        if lhs.forwardingFeeProportionalMillionths != rhs.forwardingFeeProportionalMillionths {
            return false
        }
        if lhs.forwardingFeeBaseMsat != rhs.forwardingFeeBaseMsat {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.maxDustHtlcExposure != rhs.maxDustHtlcExposure {
            return false
        }
        if lhs.forceCloseAvoidanceMaxFeeSatoshis != rhs.forceCloseAvoidanceMaxFeeSatoshis {
            return false
        }
        if lhs.acceptUnderpayingHtlcs != rhs.acceptUnderpayingHtlcs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(forwardingFeeProportionalMillionths)
        hasher.combine(forwardingFeeBaseMsat)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(maxDustHtlcExposure)
        hasher.combine(forceCloseAvoidanceMaxFeeSatoshis)
        hasher.combine(acceptUnderpayingHtlcs)
    }
}


public struct FfiConverterTypeChannelConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelConfig {
        return
            try ChannelConfig(
                forwardingFeeProportionalMillionths: FfiConverterUInt32.read(from: &buf), 
                forwardingFeeBaseMsat: FfiConverterUInt32.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                maxDustHtlcExposure: FfiConverterTypeMaxDustHTLCExposure.read(from: &buf), 
                forceCloseAvoidanceMaxFeeSatoshis: FfiConverterUInt64.read(from: &buf), 
                acceptUnderpayingHtlcs: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.forwardingFeeProportionalMillionths, into: &buf)
        FfiConverterUInt32.write(value.forwardingFeeBaseMsat, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterTypeMaxDustHTLCExposure.write(value.maxDustHtlcExposure, into: &buf)
        FfiConverterUInt64.write(value.forceCloseAvoidanceMaxFeeSatoshis, into: &buf)
        FfiConverterBool.write(value.acceptUnderpayingHtlcs, into: &buf)
    }
}


public func FfiConverterTypeChannelConfig_lift(_ buf: RustBuffer) throws -> ChannelConfig {
    return try FfiConverterTypeChannelConfig.lift(buf)
}

public func FfiConverterTypeChannelConfig_lower(_ value: ChannelConfig) -> RustBuffer {
    return FfiConverterTypeChannelConfig.lower(value)
}


public struct ChannelDetails {
    public var channelId: ChannelId
    public var counterpartyNodeId: PublicKey
    public var fundingTxo: OutPoint?
    public var shortChannelId: UInt64?
    public var outboundScidAlias: UInt64?
    public var inboundScidAlias: UInt64?
    public var channelValueSats: UInt64
    public var unspendablePunishmentReserve: UInt64?
    public var userChannelId: UserChannelId
    public var feerateSatPer1000Weight: UInt32
    public var outboundCapacityMsat: UInt64
    public var inboundCapacityMsat: UInt64
    public var confirmationsRequired: UInt32?
    public var confirmations: UInt32?
    public var isOutbound: Bool
    public var isChannelReady: Bool
    public var isUsable: Bool
    public var isAnnounced: Bool
    public var cltvExpiryDelta: UInt16?
    public var counterpartyUnspendablePunishmentReserve: UInt64
    public var counterpartyOutboundHtlcMinimumMsat: UInt64?
    public var counterpartyOutboundHtlcMaximumMsat: UInt64?
    public var counterpartyForwardingInfoFeeBaseMsat: UInt32?
    public var counterpartyForwardingInfoFeeProportionalMillionths: UInt32?
    public var counterpartyForwardingInfoCltvExpiryDelta: UInt16?
    public var nextOutboundHtlcLimitMsat: UInt64
    public var nextOutboundHtlcMinimumMsat: UInt64
    public var forceCloseSpendDelay: UInt16?
    public var inboundHtlcMinimumMsat: UInt64
    public var inboundHtlcMaximumMsat: UInt64?
    public var config: ChannelConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelId: ChannelId, counterpartyNodeId: PublicKey, fundingTxo: OutPoint?, shortChannelId: UInt64?, outboundScidAlias: UInt64?, inboundScidAlias: UInt64?, channelValueSats: UInt64, unspendablePunishmentReserve: UInt64?, userChannelId: UserChannelId, feerateSatPer1000Weight: UInt32, outboundCapacityMsat: UInt64, inboundCapacityMsat: UInt64, confirmationsRequired: UInt32?, confirmations: UInt32?, isOutbound: Bool, isChannelReady: Bool, isUsable: Bool, isAnnounced: Bool, cltvExpiryDelta: UInt16?, counterpartyUnspendablePunishmentReserve: UInt64, counterpartyOutboundHtlcMinimumMsat: UInt64?, counterpartyOutboundHtlcMaximumMsat: UInt64?, counterpartyForwardingInfoFeeBaseMsat: UInt32?, counterpartyForwardingInfoFeeProportionalMillionths: UInt32?, counterpartyForwardingInfoCltvExpiryDelta: UInt16?, nextOutboundHtlcLimitMsat: UInt64, nextOutboundHtlcMinimumMsat: UInt64, forceCloseSpendDelay: UInt16?, inboundHtlcMinimumMsat: UInt64, inboundHtlcMaximumMsat: UInt64?, config: ChannelConfig) {
        self.channelId = channelId
        self.counterpartyNodeId = counterpartyNodeId
        self.fundingTxo = fundingTxo
        self.shortChannelId = shortChannelId
        self.outboundScidAlias = outboundScidAlias
        self.inboundScidAlias = inboundScidAlias
        self.channelValueSats = channelValueSats
        self.unspendablePunishmentReserve = unspendablePunishmentReserve
        self.userChannelId = userChannelId
        self.feerateSatPer1000Weight = feerateSatPer1000Weight
        self.outboundCapacityMsat = outboundCapacityMsat
        self.inboundCapacityMsat = inboundCapacityMsat
        self.confirmationsRequired = confirmationsRequired
        self.confirmations = confirmations
        self.isOutbound = isOutbound
        self.isChannelReady = isChannelReady
        self.isUsable = isUsable
        self.isAnnounced = isAnnounced
        self.cltvExpiryDelta = cltvExpiryDelta
        self.counterpartyUnspendablePunishmentReserve = counterpartyUnspendablePunishmentReserve
        self.counterpartyOutboundHtlcMinimumMsat = counterpartyOutboundHtlcMinimumMsat
        self.counterpartyOutboundHtlcMaximumMsat = counterpartyOutboundHtlcMaximumMsat
        self.counterpartyForwardingInfoFeeBaseMsat = counterpartyForwardingInfoFeeBaseMsat
        self.counterpartyForwardingInfoFeeProportionalMillionths = counterpartyForwardingInfoFeeProportionalMillionths
        self.counterpartyForwardingInfoCltvExpiryDelta = counterpartyForwardingInfoCltvExpiryDelta
        self.nextOutboundHtlcLimitMsat = nextOutboundHtlcLimitMsat
        self.nextOutboundHtlcMinimumMsat = nextOutboundHtlcMinimumMsat
        self.forceCloseSpendDelay = forceCloseSpendDelay
        self.inboundHtlcMinimumMsat = inboundHtlcMinimumMsat
        self.inboundHtlcMaximumMsat = inboundHtlcMaximumMsat
        self.config = config
    }
}



extension ChannelDetails: Equatable, Hashable {
    public static func ==(lhs: ChannelDetails, rhs: ChannelDetails) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.counterpartyNodeId != rhs.counterpartyNodeId {
            return false
        }
        if lhs.fundingTxo != rhs.fundingTxo {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.outboundScidAlias != rhs.outboundScidAlias {
            return false
        }
        if lhs.inboundScidAlias != rhs.inboundScidAlias {
            return false
        }
        if lhs.channelValueSats != rhs.channelValueSats {
            return false
        }
        if lhs.unspendablePunishmentReserve != rhs.unspendablePunishmentReserve {
            return false
        }
        if lhs.userChannelId != rhs.userChannelId {
            return false
        }
        if lhs.feerateSatPer1000Weight != rhs.feerateSatPer1000Weight {
            return false
        }
        if lhs.outboundCapacityMsat != rhs.outboundCapacityMsat {
            return false
        }
        if lhs.inboundCapacityMsat != rhs.inboundCapacityMsat {
            return false
        }
        if lhs.confirmationsRequired != rhs.confirmationsRequired {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.isOutbound != rhs.isOutbound {
            return false
        }
        if lhs.isChannelReady != rhs.isChannelReady {
            return false
        }
        if lhs.isUsable != rhs.isUsable {
            return false
        }
        if lhs.isAnnounced != rhs.isAnnounced {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.counterpartyUnspendablePunishmentReserve != rhs.counterpartyUnspendablePunishmentReserve {
            return false
        }
        if lhs.counterpartyOutboundHtlcMinimumMsat != rhs.counterpartyOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.counterpartyOutboundHtlcMaximumMsat != rhs.counterpartyOutboundHtlcMaximumMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeBaseMsat != rhs.counterpartyForwardingInfoFeeBaseMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeProportionalMillionths != rhs.counterpartyForwardingInfoFeeProportionalMillionths {
            return false
        }
        if lhs.counterpartyForwardingInfoCltvExpiryDelta != rhs.counterpartyForwardingInfoCltvExpiryDelta {
            return false
        }
        if lhs.nextOutboundHtlcLimitMsat != rhs.nextOutboundHtlcLimitMsat {
            return false
        }
        if lhs.nextOutboundHtlcMinimumMsat != rhs.nextOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.forceCloseSpendDelay != rhs.forceCloseSpendDelay {
            return false
        }
        if lhs.inboundHtlcMinimumMsat != rhs.inboundHtlcMinimumMsat {
            return false
        }
        if lhs.inboundHtlcMaximumMsat != rhs.inboundHtlcMaximumMsat {
            return false
        }
        if lhs.config != rhs.config {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(counterpartyNodeId)
        hasher.combine(fundingTxo)
        hasher.combine(shortChannelId)
        hasher.combine(outboundScidAlias)
        hasher.combine(inboundScidAlias)
        hasher.combine(channelValueSats)
        hasher.combine(unspendablePunishmentReserve)
        hasher.combine(userChannelId)
        hasher.combine(feerateSatPer1000Weight)
        hasher.combine(outboundCapacityMsat)
        hasher.combine(inboundCapacityMsat)
        hasher.combine(confirmationsRequired)
        hasher.combine(confirmations)
        hasher.combine(isOutbound)
        hasher.combine(isChannelReady)
        hasher.combine(isUsable)
        hasher.combine(isAnnounced)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(counterpartyUnspendablePunishmentReserve)
        hasher.combine(counterpartyOutboundHtlcMinimumMsat)
        hasher.combine(counterpartyOutboundHtlcMaximumMsat)
        hasher.combine(counterpartyForwardingInfoFeeBaseMsat)
        hasher.combine(counterpartyForwardingInfoFeeProportionalMillionths)
        hasher.combine(counterpartyForwardingInfoCltvExpiryDelta)
        hasher.combine(nextOutboundHtlcLimitMsat)
        hasher.combine(nextOutboundHtlcMinimumMsat)
        hasher.combine(forceCloseSpendDelay)
        hasher.combine(inboundHtlcMinimumMsat)
        hasher.combine(inboundHtlcMaximumMsat)
        hasher.combine(config)
    }
}


public struct FfiConverterTypeChannelDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelDetails {
        return
            try ChannelDetails(
                channelId: FfiConverterTypeChannelId.read(from: &buf), 
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf), 
                fundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf), 
                shortChannelId: FfiConverterOptionUInt64.read(from: &buf), 
                outboundScidAlias: FfiConverterOptionUInt64.read(from: &buf), 
                inboundScidAlias: FfiConverterOptionUInt64.read(from: &buf), 
                channelValueSats: FfiConverterUInt64.read(from: &buf), 
                unspendablePunishmentReserve: FfiConverterOptionUInt64.read(from: &buf), 
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf), 
                feerateSatPer1000Weight: FfiConverterUInt32.read(from: &buf), 
                outboundCapacityMsat: FfiConverterUInt64.read(from: &buf), 
                inboundCapacityMsat: FfiConverterUInt64.read(from: &buf), 
                confirmationsRequired: FfiConverterOptionUInt32.read(from: &buf), 
                confirmations: FfiConverterOptionUInt32.read(from: &buf), 
                isOutbound: FfiConverterBool.read(from: &buf), 
                isChannelReady: FfiConverterBool.read(from: &buf), 
                isUsable: FfiConverterBool.read(from: &buf), 
                isAnnounced: FfiConverterBool.read(from: &buf), 
                cltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf), 
                counterpartyUnspendablePunishmentReserve: FfiConverterUInt64.read(from: &buf), 
                counterpartyOutboundHtlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                counterpartyOutboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                counterpartyForwardingInfoFeeBaseMsat: FfiConverterOptionUInt32.read(from: &buf), 
                counterpartyForwardingInfoFeeProportionalMillionths: FfiConverterOptionUInt32.read(from: &buf), 
                counterpartyForwardingInfoCltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf), 
                nextOutboundHtlcLimitMsat: FfiConverterUInt64.read(from: &buf), 
                nextOutboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                forceCloseSpendDelay: FfiConverterOptionUInt16.read(from: &buf), 
                inboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                inboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                config: FfiConverterTypeChannelConfig.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelDetails, into buf: inout [UInt8]) {
        FfiConverterTypeChannelId.write(value.channelId, into: &buf)
        FfiConverterTypePublicKey.write(value.counterpartyNodeId, into: &buf)
        FfiConverterOptionTypeOutPoint.write(value.fundingTxo, into: &buf)
        FfiConverterOptionUInt64.write(value.shortChannelId, into: &buf)
        FfiConverterOptionUInt64.write(value.outboundScidAlias, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundScidAlias, into: &buf)
        FfiConverterUInt64.write(value.channelValueSats, into: &buf)
        FfiConverterOptionUInt64.write(value.unspendablePunishmentReserve, into: &buf)
        FfiConverterTypeUserChannelId.write(value.userChannelId, into: &buf)
        FfiConverterUInt32.write(value.feerateSatPer1000Weight, into: &buf)
        FfiConverterUInt64.write(value.outboundCapacityMsat, into: &buf)
        FfiConverterUInt64.write(value.inboundCapacityMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmationsRequired, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmations, into: &buf)
        FfiConverterBool.write(value.isOutbound, into: &buf)
        FfiConverterBool.write(value.isChannelReady, into: &buf)
        FfiConverterBool.write(value.isUsable, into: &buf)
        FfiConverterBool.write(value.isAnnounced, into: &buf)
        FfiConverterOptionUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.counterpartyUnspendablePunishmentReserve, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMaximumMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeBaseMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeProportionalMillionths, into: &buf)
        FfiConverterOptionUInt16.write(value.counterpartyForwardingInfoCltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcLimitMsat, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt16.write(value.forceCloseSpendDelay, into: &buf)
        FfiConverterUInt64.write(value.inboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundHtlcMaximumMsat, into: &buf)
        FfiConverterTypeChannelConfig.write(value.config, into: &buf)
    }
}


public func FfiConverterTypeChannelDetails_lift(_ buf: RustBuffer) throws -> ChannelDetails {
    return try FfiConverterTypeChannelDetails.lift(buf)
}

public func FfiConverterTypeChannelDetails_lower(_ value: ChannelDetails) -> RustBuffer {
    return FfiConverterTypeChannelDetails.lower(value)
}


public struct ChannelInfo {
    public var nodeOne: NodeId
    public var oneToTwo: ChannelUpdateInfo?
    public var nodeTwo: NodeId
    public var twoToOne: ChannelUpdateInfo?
    public var capacitySats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeOne: NodeId, oneToTwo: ChannelUpdateInfo?, nodeTwo: NodeId, twoToOne: ChannelUpdateInfo?, capacitySats: UInt64?) {
        self.nodeOne = nodeOne
        self.oneToTwo = oneToTwo
        self.nodeTwo = nodeTwo
        self.twoToOne = twoToOne
        self.capacitySats = capacitySats
    }
}



extension ChannelInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelInfo, rhs: ChannelInfo) -> Bool {
        if lhs.nodeOne != rhs.nodeOne {
            return false
        }
        if lhs.oneToTwo != rhs.oneToTwo {
            return false
        }
        if lhs.nodeTwo != rhs.nodeTwo {
            return false
        }
        if lhs.twoToOne != rhs.twoToOne {
            return false
        }
        if lhs.capacitySats != rhs.capacitySats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeOne)
        hasher.combine(oneToTwo)
        hasher.combine(nodeTwo)
        hasher.combine(twoToOne)
        hasher.combine(capacitySats)
    }
}


public struct FfiConverterTypeChannelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelInfo {
        return
            try ChannelInfo(
                nodeOne: FfiConverterTypeNodeId.read(from: &buf), 
                oneToTwo: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf), 
                nodeTwo: FfiConverterTypeNodeId.read(from: &buf), 
                twoToOne: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf), 
                capacitySats: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.nodeOne, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.oneToTwo, into: &buf)
        FfiConverterTypeNodeId.write(value.nodeTwo, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.twoToOne, into: &buf)
        FfiConverterOptionUInt64.write(value.capacitySats, into: &buf)
    }
}


public func FfiConverterTypeChannelInfo_lift(_ buf: RustBuffer) throws -> ChannelInfo {
    return try FfiConverterTypeChannelInfo.lift(buf)
}

public func FfiConverterTypeChannelInfo_lower(_ value: ChannelInfo) -> RustBuffer {
    return FfiConverterTypeChannelInfo.lower(value)
}


public struct ChannelOrderInfo {
    public var fundedAt: DateTime
    public var fundingOutpoint: OutPoint
    public var expiresAt: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fundedAt: DateTime, fundingOutpoint: OutPoint, expiresAt: DateTime) {
        self.fundedAt = fundedAt
        self.fundingOutpoint = fundingOutpoint
        self.expiresAt = expiresAt
    }
}



extension ChannelOrderInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelOrderInfo, rhs: ChannelOrderInfo) -> Bool {
        if lhs.fundedAt != rhs.fundedAt {
            return false
        }
        if lhs.fundingOutpoint != rhs.fundingOutpoint {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fundedAt)
        hasher.combine(fundingOutpoint)
        hasher.combine(expiresAt)
    }
}


public struct FfiConverterTypeChannelOrderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelOrderInfo {
        return
            try ChannelOrderInfo(
                fundedAt: FfiConverterTypeDateTime.read(from: &buf), 
                fundingOutpoint: FfiConverterTypeOutPoint.read(from: &buf), 
                expiresAt: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelOrderInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDateTime.write(value.fundedAt, into: &buf)
        FfiConverterTypeOutPoint.write(value.fundingOutpoint, into: &buf)
        FfiConverterTypeDateTime.write(value.expiresAt, into: &buf)
    }
}


public func FfiConverterTypeChannelOrderInfo_lift(_ buf: RustBuffer) throws -> ChannelOrderInfo {
    return try FfiConverterTypeChannelOrderInfo.lift(buf)
}

public func FfiConverterTypeChannelOrderInfo_lower(_ value: ChannelOrderInfo) -> RustBuffer {
    return FfiConverterTypeChannelOrderInfo.lower(value)
}


public struct ChannelUpdateInfo {
    public var lastUpdate: UInt32
    public var enabled: Bool
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64
    public var htlcMaximumMsat: UInt64
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUpdate: UInt32, enabled: Bool, cltvExpiryDelta: UInt16, htlcMinimumMsat: UInt64, htlcMaximumMsat: UInt64, fees: RoutingFees) {
        self.lastUpdate = lastUpdate
        self.enabled = enabled
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}



extension ChannelUpdateInfo: Equatable, Hashable {
    public static func ==(lhs: ChannelUpdateInfo, rhs: ChannelUpdateInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(enabled)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}


public struct FfiConverterTypeChannelUpdateInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelUpdateInfo {
        return
            try ChannelUpdateInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf), 
                enabled: FfiConverterBool.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterUInt64.read(from: &buf), 
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
        )
    }

    public static func write(_ value: ChannelUpdateInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}


public func FfiConverterTypeChannelUpdateInfo_lift(_ buf: RustBuffer) throws -> ChannelUpdateInfo {
    return try FfiConverterTypeChannelUpdateInfo.lift(buf)
}

public func FfiConverterTypeChannelUpdateInfo_lower(_ value: ChannelUpdateInfo) -> RustBuffer {
    return FfiConverterTypeChannelUpdateInfo.lower(value)
}


public struct Config {
    public var storageDirPath: String
    public var network: Network
    public var listeningAddresses: [SocketAddress]?
    public var announcementAddresses: [SocketAddress]?
    public var nodeAlias: NodeAlias?
    public var trustedPeers0conf: [PublicKey]
    public var probingLiquidityLimitMultiplier: UInt64
    public var anchorChannelsConfig: AnchorChannelsConfig?
    public var sendingParameters: SendingParameters?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(storageDirPath: String, network: Network, listeningAddresses: [SocketAddress]?, announcementAddresses: [SocketAddress]?, nodeAlias: NodeAlias?, trustedPeers0conf: [PublicKey], probingLiquidityLimitMultiplier: UInt64, anchorChannelsConfig: AnchorChannelsConfig?, sendingParameters: SendingParameters?) {
        self.storageDirPath = storageDirPath
        self.network = network
        self.listeningAddresses = listeningAddresses
        self.announcementAddresses = announcementAddresses
        self.nodeAlias = nodeAlias
        self.trustedPeers0conf = trustedPeers0conf
        self.probingLiquidityLimitMultiplier = probingLiquidityLimitMultiplier
        self.anchorChannelsConfig = anchorChannelsConfig
        self.sendingParameters = sendingParameters
    }
}



extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.storageDirPath != rhs.storageDirPath {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.listeningAddresses != rhs.listeningAddresses {
            return false
        }
        if lhs.announcementAddresses != rhs.announcementAddresses {
            return false
        }
        if lhs.nodeAlias != rhs.nodeAlias {
            return false
        }
        if lhs.trustedPeers0conf != rhs.trustedPeers0conf {
            return false
        }
        if lhs.probingLiquidityLimitMultiplier != rhs.probingLiquidityLimitMultiplier {
            return false
        }
        if lhs.anchorChannelsConfig != rhs.anchorChannelsConfig {
            return false
        }
        if lhs.sendingParameters != rhs.sendingParameters {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(storageDirPath)
        hasher.combine(network)
        hasher.combine(listeningAddresses)
        hasher.combine(announcementAddresses)
        hasher.combine(nodeAlias)
        hasher.combine(trustedPeers0conf)
        hasher.combine(probingLiquidityLimitMultiplier)
        hasher.combine(anchorChannelsConfig)
        hasher.combine(sendingParameters)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                storageDirPath: FfiConverterString.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf), 
                listeningAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf), 
                announcementAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf), 
                nodeAlias: FfiConverterOptionTypeNodeAlias.read(from: &buf), 
                trustedPeers0conf: FfiConverterSequenceTypePublicKey.read(from: &buf), 
                probingLiquidityLimitMultiplier: FfiConverterUInt64.read(from: &buf), 
                anchorChannelsConfig: FfiConverterOptionTypeAnchorChannelsConfig.read(from: &buf), 
                sendingParameters: FfiConverterOptionTypeSendingParameters.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.storageDirPath, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.listeningAddresses, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.announcementAddresses, into: &buf)
        FfiConverterOptionTypeNodeAlias.write(value.nodeAlias, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.trustedPeers0conf, into: &buf)
        FfiConverterUInt64.write(value.probingLiquidityLimitMultiplier, into: &buf)
        FfiConverterOptionTypeAnchorChannelsConfig.write(value.anchorChannelsConfig, into: &buf)
        FfiConverterOptionTypeSendingParameters.write(value.sendingParameters, into: &buf)
    }
}


public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct CustomTlvRecord {
    public var typeNum: UInt64
    public var value: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typeNum: UInt64, value: [UInt8]) {
        self.typeNum = typeNum
        self.value = value
    }
}



extension CustomTlvRecord: Equatable, Hashable {
    public static func ==(lhs: CustomTlvRecord, rhs: CustomTlvRecord) -> Bool {
        if lhs.typeNum != rhs.typeNum {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typeNum)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeCustomTlvRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CustomTlvRecord {
        return
            try CustomTlvRecord(
                typeNum: FfiConverterUInt64.read(from: &buf), 
                value: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: CustomTlvRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.typeNum, into: &buf)
        FfiConverterSequenceUInt8.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeCustomTlvRecord_lift(_ buf: RustBuffer) throws -> CustomTlvRecord {
    return try FfiConverterTypeCustomTlvRecord.lift(buf)
}

public func FfiConverterTypeCustomTlvRecord_lower(_ value: CustomTlvRecord) -> RustBuffer {
    return FfiConverterTypeCustomTlvRecord.lower(value)
}


public struct ElectrumSyncConfig {
    public var backgroundSyncConfig: BackgroundSyncConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backgroundSyncConfig: BackgroundSyncConfig?) {
        self.backgroundSyncConfig = backgroundSyncConfig
    }
}



extension ElectrumSyncConfig: Equatable, Hashable {
    public static func ==(lhs: ElectrumSyncConfig, rhs: ElectrumSyncConfig) -> Bool {
        if lhs.backgroundSyncConfig != rhs.backgroundSyncConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backgroundSyncConfig)
    }
}


public struct FfiConverterTypeElectrumSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElectrumSyncConfig {
        return
            try ElectrumSyncConfig(
                backgroundSyncConfig: FfiConverterOptionTypeBackgroundSyncConfig.read(from: &buf)
        )
    }

    public static func write(_ value: ElectrumSyncConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeBackgroundSyncConfig.write(value.backgroundSyncConfig, into: &buf)
    }
}


public func FfiConverterTypeElectrumSyncConfig_lift(_ buf: RustBuffer) throws -> ElectrumSyncConfig {
    return try FfiConverterTypeElectrumSyncConfig.lift(buf)
}

public func FfiConverterTypeElectrumSyncConfig_lower(_ value: ElectrumSyncConfig) -> RustBuffer {
    return FfiConverterTypeElectrumSyncConfig.lower(value)
}


public struct EsploraSyncConfig {
    public var backgroundSyncConfig: BackgroundSyncConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(backgroundSyncConfig: BackgroundSyncConfig?) {
        self.backgroundSyncConfig = backgroundSyncConfig
    }
}



extension EsploraSyncConfig: Equatable, Hashable {
    public static func ==(lhs: EsploraSyncConfig, rhs: EsploraSyncConfig) -> Bool {
        if lhs.backgroundSyncConfig != rhs.backgroundSyncConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(backgroundSyncConfig)
    }
}


public struct FfiConverterTypeEsploraSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraSyncConfig {
        return
            try EsploraSyncConfig(
                backgroundSyncConfig: FfiConverterOptionTypeBackgroundSyncConfig.read(from: &buf)
        )
    }

    public static func write(_ value: EsploraSyncConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeBackgroundSyncConfig.write(value.backgroundSyncConfig, into: &buf)
    }
}


public func FfiConverterTypeEsploraSyncConfig_lift(_ buf: RustBuffer) throws -> EsploraSyncConfig {
    return try FfiConverterTypeEsploraSyncConfig.lift(buf)
}

public func FfiConverterTypeEsploraSyncConfig_lower(_ value: EsploraSyncConfig) -> RustBuffer {
    return FfiConverterTypeEsploraSyncConfig.lower(value)
}


public struct LspFeeLimits {
    public var maxTotalOpeningFeeMsat: UInt64?
    public var maxProportionalOpeningFeePpmMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxTotalOpeningFeeMsat: UInt64?, maxProportionalOpeningFeePpmMsat: UInt64?) {
        self.maxTotalOpeningFeeMsat = maxTotalOpeningFeeMsat
        self.maxProportionalOpeningFeePpmMsat = maxProportionalOpeningFeePpmMsat
    }
}



extension LspFeeLimits: Equatable, Hashable {
    public static func ==(lhs: LspFeeLimits, rhs: LspFeeLimits) -> Bool {
        if lhs.maxTotalOpeningFeeMsat != rhs.maxTotalOpeningFeeMsat {
            return false
        }
        if lhs.maxProportionalOpeningFeePpmMsat != rhs.maxProportionalOpeningFeePpmMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalOpeningFeeMsat)
        hasher.combine(maxProportionalOpeningFeePpmMsat)
    }
}


public struct FfiConverterTypeLSPFeeLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFeeLimits {
        return
            try LspFeeLimits(
                maxTotalOpeningFeeMsat: FfiConverterOptionUInt64.read(from: &buf), 
                maxProportionalOpeningFeePpmMsat: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LspFeeLimits, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxTotalOpeningFeeMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.maxProportionalOpeningFeePpmMsat, into: &buf)
    }
}


public func FfiConverterTypeLSPFeeLimits_lift(_ buf: RustBuffer) throws -> LspFeeLimits {
    return try FfiConverterTypeLSPFeeLimits.lift(buf)
}

public func FfiConverterTypeLSPFeeLimits_lower(_ value: LspFeeLimits) -> RustBuffer {
    return FfiConverterTypeLSPFeeLimits.lower(value)
}


public struct Lsps1OrderStatus {
    public var orderId: OrderId
    public var orderParams: OrderParameters
    public var paymentOptions: PaymentInfo
    public var channelState: ChannelOrderInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(orderId: OrderId, orderParams: OrderParameters, paymentOptions: PaymentInfo, channelState: ChannelOrderInfo?) {
        self.orderId = orderId
        self.orderParams = orderParams
        self.paymentOptions = paymentOptions
        self.channelState = channelState
    }
}



public struct FfiConverterTypeLSPS1OrderStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps1OrderStatus {
        return
            try Lsps1OrderStatus(
                orderId: FfiConverterTypeOrderId.read(from: &buf), 
                orderParams: FfiConverterTypeOrderParameters.read(from: &buf), 
                paymentOptions: FfiConverterTypePaymentInfo.read(from: &buf), 
                channelState: FfiConverterOptionTypeChannelOrderInfo.read(from: &buf)
        )
    }

    public static func write(_ value: Lsps1OrderStatus, into buf: inout [UInt8]) {
        FfiConverterTypeOrderId.write(value.orderId, into: &buf)
        FfiConverterTypeOrderParameters.write(value.orderParams, into: &buf)
        FfiConverterTypePaymentInfo.write(value.paymentOptions, into: &buf)
        FfiConverterOptionTypeChannelOrderInfo.write(value.channelState, into: &buf)
    }
}


public func FfiConverterTypeLSPS1OrderStatus_lift(_ buf: RustBuffer) throws -> Lsps1OrderStatus {
    return try FfiConverterTypeLSPS1OrderStatus.lift(buf)
}

public func FfiConverterTypeLSPS1OrderStatus_lower(_ value: Lsps1OrderStatus) -> RustBuffer {
    return FfiConverterTypeLSPS1OrderStatus.lower(value)
}


public struct Lsps2ServiceConfig {
    public var requireToken: String?
    public var advertiseService: Bool
    public var channelOpeningFeePpm: UInt32
    public var channelOverProvisioningPpm: UInt32
    public var minChannelOpeningFeeMsat: UInt64
    public var minChannelLifetime: UInt32
    public var maxClientToSelfDelay: UInt32
    public var minPaymentSizeMsat: UInt64
    public var maxPaymentSizeMsat: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(requireToken: String?, advertiseService: Bool, channelOpeningFeePpm: UInt32, channelOverProvisioningPpm: UInt32, minChannelOpeningFeeMsat: UInt64, minChannelLifetime: UInt32, maxClientToSelfDelay: UInt32, minPaymentSizeMsat: UInt64, maxPaymentSizeMsat: UInt64) {
        self.requireToken = requireToken
        self.advertiseService = advertiseService
        self.channelOpeningFeePpm = channelOpeningFeePpm
        self.channelOverProvisioningPpm = channelOverProvisioningPpm
        self.minChannelOpeningFeeMsat = minChannelOpeningFeeMsat
        self.minChannelLifetime = minChannelLifetime
        self.maxClientToSelfDelay = maxClientToSelfDelay
        self.minPaymentSizeMsat = minPaymentSizeMsat
        self.maxPaymentSizeMsat = maxPaymentSizeMsat
    }
}



extension Lsps2ServiceConfig: Equatable, Hashable {
    public static func ==(lhs: Lsps2ServiceConfig, rhs: Lsps2ServiceConfig) -> Bool {
        if lhs.requireToken != rhs.requireToken {
            return false
        }
        if lhs.advertiseService != rhs.advertiseService {
            return false
        }
        if lhs.channelOpeningFeePpm != rhs.channelOpeningFeePpm {
            return false
        }
        if lhs.channelOverProvisioningPpm != rhs.channelOverProvisioningPpm {
            return false
        }
        if lhs.minChannelOpeningFeeMsat != rhs.minChannelOpeningFeeMsat {
            return false
        }
        if lhs.minChannelLifetime != rhs.minChannelLifetime {
            return false
        }
        if lhs.maxClientToSelfDelay != rhs.maxClientToSelfDelay {
            return false
        }
        if lhs.minPaymentSizeMsat != rhs.minPaymentSizeMsat {
            return false
        }
        if lhs.maxPaymentSizeMsat != rhs.maxPaymentSizeMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(requireToken)
        hasher.combine(advertiseService)
        hasher.combine(channelOpeningFeePpm)
        hasher.combine(channelOverProvisioningPpm)
        hasher.combine(minChannelOpeningFeeMsat)
        hasher.combine(minChannelLifetime)
        hasher.combine(maxClientToSelfDelay)
        hasher.combine(minPaymentSizeMsat)
        hasher.combine(maxPaymentSizeMsat)
    }
}


public struct FfiConverterTypeLSPS2ServiceConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Lsps2ServiceConfig {
        return
            try Lsps2ServiceConfig(
                requireToken: FfiConverterOptionString.read(from: &buf), 
                advertiseService: FfiConverterBool.read(from: &buf), 
                channelOpeningFeePpm: FfiConverterUInt32.read(from: &buf), 
                channelOverProvisioningPpm: FfiConverterUInt32.read(from: &buf), 
                minChannelOpeningFeeMsat: FfiConverterUInt64.read(from: &buf), 
                minChannelLifetime: FfiConverterUInt32.read(from: &buf), 
                maxClientToSelfDelay: FfiConverterUInt32.read(from: &buf), 
                minPaymentSizeMsat: FfiConverterUInt64.read(from: &buf), 
                maxPaymentSizeMsat: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Lsps2ServiceConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.requireToken, into: &buf)
        FfiConverterBool.write(value.advertiseService, into: &buf)
        FfiConverterUInt32.write(value.channelOpeningFeePpm, into: &buf)
        FfiConverterUInt32.write(value.channelOverProvisioningPpm, into: &buf)
        FfiConverterUInt64.write(value.minChannelOpeningFeeMsat, into: &buf)
        FfiConverterUInt32.write(value.minChannelLifetime, into: &buf)
        FfiConverterUInt32.write(value.maxClientToSelfDelay, into: &buf)
        FfiConverterUInt64.write(value.minPaymentSizeMsat, into: &buf)
        FfiConverterUInt64.write(value.maxPaymentSizeMsat, into: &buf)
    }
}


public func FfiConverterTypeLSPS2ServiceConfig_lift(_ buf: RustBuffer) throws -> Lsps2ServiceConfig {
    return try FfiConverterTypeLSPS2ServiceConfig.lift(buf)
}

public func FfiConverterTypeLSPS2ServiceConfig_lower(_ value: Lsps2ServiceConfig) -> RustBuffer {
    return FfiConverterTypeLSPS2ServiceConfig.lower(value)
}


public struct LogRecord {
    public var level: LogLevel
    public var args: String
    public var modulePath: String
    public var line: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(level: LogLevel, args: String, modulePath: String, line: UInt32) {
        self.level = level
        self.args = args
        self.modulePath = modulePath
        self.line = line
    }
}



extension LogRecord: Equatable, Hashable {
    public static func ==(lhs: LogRecord, rhs: LogRecord) -> Bool {
        if lhs.level != rhs.level {
            return false
        }
        if lhs.args != rhs.args {
            return false
        }
        if lhs.modulePath != rhs.modulePath {
            return false
        }
        if lhs.line != rhs.line {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(args)
        hasher.combine(modulePath)
        hasher.combine(line)
    }
}


public struct FfiConverterTypeLogRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogRecord {
        return
            try LogRecord(
                level: FfiConverterTypeLogLevel.read(from: &buf), 
                args: FfiConverterString.read(from: &buf), 
                modulePath: FfiConverterString.read(from: &buf), 
                line: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LogRecord, into buf: inout [UInt8]) {
        FfiConverterTypeLogLevel.write(value.level, into: &buf)
        FfiConverterString.write(value.args, into: &buf)
        FfiConverterString.write(value.modulePath, into: &buf)
        FfiConverterUInt32.write(value.line, into: &buf)
    }
}


public func FfiConverterTypeLogRecord_lift(_ buf: RustBuffer) throws -> LogRecord {
    return try FfiConverterTypeLogRecord.lift(buf)
}

public func FfiConverterTypeLogRecord_lower(_ value: LogRecord) -> RustBuffer {
    return FfiConverterTypeLogRecord.lower(value)
}


public struct NodeAnnouncementInfo {
    public var lastUpdate: UInt32
    public var alias: String
    public var addresses: [SocketAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUpdate: UInt32, alias: String, addresses: [SocketAddress]) {
        self.lastUpdate = lastUpdate
        self.alias = alias
        self.addresses = addresses
    }
}



extension NodeAnnouncementInfo: Equatable, Hashable {
    public static func ==(lhs: NodeAnnouncementInfo, rhs: NodeAnnouncementInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(alias)
        hasher.combine(addresses)
    }
}


public struct FfiConverterTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAnnouncementInfo {
        return
            try NodeAnnouncementInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf), 
                alias: FfiConverterString.read(from: &buf), 
                addresses: FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        )
    }

    public static func write(_ value: NodeAnnouncementInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterSequenceTypeSocketAddress.write(value.addresses, into: &buf)
    }
}


public func FfiConverterTypeNodeAnnouncementInfo_lift(_ buf: RustBuffer) throws -> NodeAnnouncementInfo {
    return try FfiConverterTypeNodeAnnouncementInfo.lift(buf)
}

public func FfiConverterTypeNodeAnnouncementInfo_lower(_ value: NodeAnnouncementInfo) -> RustBuffer {
    return FfiConverterTypeNodeAnnouncementInfo.lower(value)
}


public struct NodeInfo {
    public var channels: [UInt64]
    public var announcementInfo: NodeAnnouncementInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channels: [UInt64], announcementInfo: NodeAnnouncementInfo?) {
        self.channels = channels
        self.announcementInfo = announcementInfo
    }
}



extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.channels != rhs.channels {
            return false
        }
        if lhs.announcementInfo != rhs.announcementInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channels)
        hasher.combine(announcementInfo)
    }
}


public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                channels: FfiConverterSequenceUInt64.read(from: &buf), 
                announcementInfo: FfiConverterOptionTypeNodeAnnouncementInfo.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.channels, into: &buf)
        FfiConverterOptionTypeNodeAnnouncementInfo.write(value.announcementInfo, into: &buf)
    }
}


public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct NodeStatus {
    public var isRunning: Bool
    public var isListening: Bool
    public var currentBestBlock: BestBlock
    public var latestLightningWalletSyncTimestamp: UInt64?
    public var latestOnchainWalletSyncTimestamp: UInt64?
    public var latestFeeRateCacheUpdateTimestamp: UInt64?
    public var latestRgsSnapshotTimestamp: UInt64?
    public var latestNodeAnnouncementBroadcastTimestamp: UInt64?
    public var latestChannelMonitorArchivalHeight: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRunning: Bool, isListening: Bool, currentBestBlock: BestBlock, latestLightningWalletSyncTimestamp: UInt64?, latestOnchainWalletSyncTimestamp: UInt64?, latestFeeRateCacheUpdateTimestamp: UInt64?, latestRgsSnapshotTimestamp: UInt64?, latestNodeAnnouncementBroadcastTimestamp: UInt64?, latestChannelMonitorArchivalHeight: UInt32?) {
        self.isRunning = isRunning
        self.isListening = isListening
        self.currentBestBlock = currentBestBlock
        self.latestLightningWalletSyncTimestamp = latestLightningWalletSyncTimestamp
        self.latestOnchainWalletSyncTimestamp = latestOnchainWalletSyncTimestamp
        self.latestFeeRateCacheUpdateTimestamp = latestFeeRateCacheUpdateTimestamp
        self.latestRgsSnapshotTimestamp = latestRgsSnapshotTimestamp
        self.latestNodeAnnouncementBroadcastTimestamp = latestNodeAnnouncementBroadcastTimestamp
        self.latestChannelMonitorArchivalHeight = latestChannelMonitorArchivalHeight
    }
}



extension NodeStatus: Equatable, Hashable {
    public static func ==(lhs: NodeStatus, rhs: NodeStatus) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.isListening != rhs.isListening {
            return false
        }
        if lhs.currentBestBlock != rhs.currentBestBlock {
            return false
        }
        if lhs.latestLightningWalletSyncTimestamp != rhs.latestLightningWalletSyncTimestamp {
            return false
        }
        if lhs.latestOnchainWalletSyncTimestamp != rhs.latestOnchainWalletSyncTimestamp {
            return false
        }
        if lhs.latestFeeRateCacheUpdateTimestamp != rhs.latestFeeRateCacheUpdateTimestamp {
            return false
        }
        if lhs.latestRgsSnapshotTimestamp != rhs.latestRgsSnapshotTimestamp {
            return false
        }
        if lhs.latestNodeAnnouncementBroadcastTimestamp != rhs.latestNodeAnnouncementBroadcastTimestamp {
            return false
        }
        if lhs.latestChannelMonitorArchivalHeight != rhs.latestChannelMonitorArchivalHeight {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(isListening)
        hasher.combine(currentBestBlock)
        hasher.combine(latestLightningWalletSyncTimestamp)
        hasher.combine(latestOnchainWalletSyncTimestamp)
        hasher.combine(latestFeeRateCacheUpdateTimestamp)
        hasher.combine(latestRgsSnapshotTimestamp)
        hasher.combine(latestNodeAnnouncementBroadcastTimestamp)
        hasher.combine(latestChannelMonitorArchivalHeight)
    }
}


public struct FfiConverterTypeNodeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatus {
        return
            try NodeStatus(
                isRunning: FfiConverterBool.read(from: &buf), 
                isListening: FfiConverterBool.read(from: &buf), 
                currentBestBlock: FfiConverterTypeBestBlock.read(from: &buf), 
                latestLightningWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestOnchainWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestFeeRateCacheUpdateTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestRgsSnapshotTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestNodeAnnouncementBroadcastTimestamp: FfiConverterOptionUInt64.read(from: &buf), 
                latestChannelMonitorArchivalHeight: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: NodeStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterBool.write(value.isListening, into: &buf)
        FfiConverterTypeBestBlock.write(value.currentBestBlock, into: &buf)
        FfiConverterOptionUInt64.write(value.latestLightningWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestOnchainWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestFeeRateCacheUpdateTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestRgsSnapshotTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestNodeAnnouncementBroadcastTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.latestChannelMonitorArchivalHeight, into: &buf)
    }
}


public func FfiConverterTypeNodeStatus_lift(_ buf: RustBuffer) throws -> NodeStatus {
    return try FfiConverterTypeNodeStatus.lift(buf)
}

public func FfiConverterTypeNodeStatus_lower(_ value: NodeStatus) -> RustBuffer {
    return FfiConverterTypeNodeStatus.lower(value)
}


public struct OnchainPaymentInfo {
    public var state: PaymentState
    public var expiresAt: DateTime
    public var feeTotalSat: UInt64
    public var orderTotalSat: UInt64
    public var address: Address
    public var minOnchainPaymentConfirmations: UInt16?
    public var minFeeFor0conf: FeeRate
    public var refundOnchainAddress: Address?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: PaymentState, expiresAt: DateTime, feeTotalSat: UInt64, orderTotalSat: UInt64, address: Address, minOnchainPaymentConfirmations: UInt16?, minFeeFor0conf: FeeRate, refundOnchainAddress: Address?) {
        self.state = state
        self.expiresAt = expiresAt
        self.feeTotalSat = feeTotalSat
        self.orderTotalSat = orderTotalSat
        self.address = address
        self.minOnchainPaymentConfirmations = minOnchainPaymentConfirmations
        self.minFeeFor0conf = minFeeFor0conf
        self.refundOnchainAddress = refundOnchainAddress
    }
}



public struct FfiConverterTypeOnchainPaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainPaymentInfo {
        return
            try OnchainPaymentInfo(
                state: FfiConverterTypePaymentState.read(from: &buf), 
                expiresAt: FfiConverterTypeDateTime.read(from: &buf), 
                feeTotalSat: FfiConverterUInt64.read(from: &buf), 
                orderTotalSat: FfiConverterUInt64.read(from: &buf), 
                address: FfiConverterTypeAddress.read(from: &buf), 
                minOnchainPaymentConfirmations: FfiConverterOptionUInt16.read(from: &buf), 
                minFeeFor0conf: FfiConverterTypeFeeRate.read(from: &buf), 
                refundOnchainAddress: FfiConverterOptionTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: OnchainPaymentInfo, into buf: inout [UInt8]) {
        FfiConverterTypePaymentState.write(value.state, into: &buf)
        FfiConverterTypeDateTime.write(value.expiresAt, into: &buf)
        FfiConverterUInt64.write(value.feeTotalSat, into: &buf)
        FfiConverterUInt64.write(value.orderTotalSat, into: &buf)
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterOptionUInt16.write(value.minOnchainPaymentConfirmations, into: &buf)
        FfiConverterTypeFeeRate.write(value.minFeeFor0conf, into: &buf)
        FfiConverterOptionTypeAddress.write(value.refundOnchainAddress, into: &buf)
    }
}


public func FfiConverterTypeOnchainPaymentInfo_lift(_ buf: RustBuffer) throws -> OnchainPaymentInfo {
    return try FfiConverterTypeOnchainPaymentInfo.lift(buf)
}

public func FfiConverterTypeOnchainPaymentInfo_lower(_ value: OnchainPaymentInfo) -> RustBuffer {
    return FfiConverterTypeOnchainPaymentInfo.lower(value)
}


public struct OrderParameters {
    public var lspBalanceSat: UInt64
    public var clientBalanceSat: UInt64
    public var requiredChannelConfirmations: UInt16
    public var fundingConfirmsWithinBlocks: UInt16
    public var channelExpiryBlocks: UInt32
    public var token: String?
    public var announceChannel: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lspBalanceSat: UInt64, clientBalanceSat: UInt64, requiredChannelConfirmations: UInt16, fundingConfirmsWithinBlocks: UInt16, channelExpiryBlocks: UInt32, token: String?, announceChannel: Bool) {
        self.lspBalanceSat = lspBalanceSat
        self.clientBalanceSat = clientBalanceSat
        self.requiredChannelConfirmations = requiredChannelConfirmations
        self.fundingConfirmsWithinBlocks = fundingConfirmsWithinBlocks
        self.channelExpiryBlocks = channelExpiryBlocks
        self.token = token
        self.announceChannel = announceChannel
    }
}



extension OrderParameters: Equatable, Hashable {
    public static func ==(lhs: OrderParameters, rhs: OrderParameters) -> Bool {
        if lhs.lspBalanceSat != rhs.lspBalanceSat {
            return false
        }
        if lhs.clientBalanceSat != rhs.clientBalanceSat {
            return false
        }
        if lhs.requiredChannelConfirmations != rhs.requiredChannelConfirmations {
            return false
        }
        if lhs.fundingConfirmsWithinBlocks != rhs.fundingConfirmsWithinBlocks {
            return false
        }
        if lhs.channelExpiryBlocks != rhs.channelExpiryBlocks {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        if lhs.announceChannel != rhs.announceChannel {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lspBalanceSat)
        hasher.combine(clientBalanceSat)
        hasher.combine(requiredChannelConfirmations)
        hasher.combine(fundingConfirmsWithinBlocks)
        hasher.combine(channelExpiryBlocks)
        hasher.combine(token)
        hasher.combine(announceChannel)
    }
}


public struct FfiConverterTypeOrderParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderParameters {
        return
            try OrderParameters(
                lspBalanceSat: FfiConverterUInt64.read(from: &buf), 
                clientBalanceSat: FfiConverterUInt64.read(from: &buf), 
                requiredChannelConfirmations: FfiConverterUInt16.read(from: &buf), 
                fundingConfirmsWithinBlocks: FfiConverterUInt16.read(from: &buf), 
                channelExpiryBlocks: FfiConverterUInt32.read(from: &buf), 
                token: FfiConverterOptionString.read(from: &buf), 
                announceChannel: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: OrderParameters, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.lspBalanceSat, into: &buf)
        FfiConverterUInt64.write(value.clientBalanceSat, into: &buf)
        FfiConverterUInt16.write(value.requiredChannelConfirmations, into: &buf)
        FfiConverterUInt16.write(value.fundingConfirmsWithinBlocks, into: &buf)
        FfiConverterUInt32.write(value.channelExpiryBlocks, into: &buf)
        FfiConverterOptionString.write(value.token, into: &buf)
        FfiConverterBool.write(value.announceChannel, into: &buf)
    }
}


public func FfiConverterTypeOrderParameters_lift(_ buf: RustBuffer) throws -> OrderParameters {
    return try FfiConverterTypeOrderParameters.lift(buf)
}

public func FfiConverterTypeOrderParameters_lower(_ value: OrderParameters) -> RustBuffer {
    return FfiConverterTypeOrderParameters.lower(value)
}


public struct OutPoint {
    public var txid: Txid
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(txid: Txid, vout: UInt32) {
        self.txid = txid
        self.vout = vout
    }
}



extension OutPoint: Equatable, Hashable {
    public static func ==(lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}


public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterTypeTxid.read(from: &buf), 
                vout: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}


public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}


public struct PaymentDetails {
    public var id: PaymentId
    public var kind: PaymentKind
    public var amountMsat: UInt64?
    public var feePaidMsat: UInt64?
    public var direction: PaymentDirection
    public var status: PaymentStatus
    public var latestUpdateTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PaymentId, kind: PaymentKind, amountMsat: UInt64?, feePaidMsat: UInt64?, direction: PaymentDirection, status: PaymentStatus, latestUpdateTimestamp: UInt64) {
        self.id = id
        self.kind = kind
        self.amountMsat = amountMsat
        self.feePaidMsat = feePaidMsat
        self.direction = direction
        self.status = status
        self.latestUpdateTimestamp = latestUpdateTimestamp
    }
}



extension PaymentDetails: Equatable, Hashable {
    public static func ==(lhs: PaymentDetails, rhs: PaymentDetails) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.feePaidMsat != rhs.feePaidMsat {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.latestUpdateTimestamp != rhs.latestUpdateTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(kind)
        hasher.combine(amountMsat)
        hasher.combine(feePaidMsat)
        hasher.combine(direction)
        hasher.combine(status)
        hasher.combine(latestUpdateTimestamp)
    }
}


public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        return
            try PaymentDetails(
                id: FfiConverterTypePaymentId.read(from: &buf), 
                kind: FfiConverterTypePaymentKind.read(from: &buf), 
                amountMsat: FfiConverterOptionUInt64.read(from: &buf), 
                feePaidMsat: FfiConverterOptionUInt64.read(from: &buf), 
                direction: FfiConverterTypePaymentDirection.read(from: &buf), 
                status: FfiConverterTypePaymentStatus.read(from: &buf), 
                latestUpdateTimestamp: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        FfiConverterTypePaymentId.write(value.id, into: &buf)
        FfiConverterTypePaymentKind.write(value.kind, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.feePaidMsat, into: &buf)
        FfiConverterTypePaymentDirection.write(value.direction, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.latestUpdateTimestamp, into: &buf)
    }
}


public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}


public struct PaymentInfo {
    public var bolt11: Bolt11PaymentInfo?
    public var onchain: OnchainPaymentInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bolt11: Bolt11PaymentInfo?, onchain: OnchainPaymentInfo?) {
        self.bolt11 = bolt11
        self.onchain = onchain
    }
}



public struct FfiConverterTypePaymentInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentInfo {
        return
            try PaymentInfo(
                bolt11: FfiConverterOptionTypeBolt11PaymentInfo.read(from: &buf), 
                onchain: FfiConverterOptionTypeOnchainPaymentInfo.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentInfo, into buf: inout [UInt8]) {
        FfiConverterOptionTypeBolt11PaymentInfo.write(value.bolt11, into: &buf)
        FfiConverterOptionTypeOnchainPaymentInfo.write(value.onchain, into: &buf)
    }
}


public func FfiConverterTypePaymentInfo_lift(_ buf: RustBuffer) throws -> PaymentInfo {
    return try FfiConverterTypePaymentInfo.lift(buf)
}

public func FfiConverterTypePaymentInfo_lower(_ value: PaymentInfo) -> RustBuffer {
    return FfiConverterTypePaymentInfo.lower(value)
}


public struct PeerDetails {
    public var nodeId: PublicKey
    public var address: SocketAddress
    public var isPersisted: Bool
    public var isConnected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeId: PublicKey, address: SocketAddress, isPersisted: Bool, isConnected: Bool) {
        self.nodeId = nodeId
        self.address = address
        self.isPersisted = isPersisted
        self.isConnected = isConnected
    }
}



extension PeerDetails: Equatable, Hashable {
    public static func ==(lhs: PeerDetails, rhs: PeerDetails) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.isPersisted != rhs.isPersisted {
            return false
        }
        if lhs.isConnected != rhs.isConnected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(address)
        hasher.combine(isPersisted)
        hasher.combine(isConnected)
    }
}


public struct FfiConverterTypePeerDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerDetails {
        return
            try PeerDetails(
                nodeId: FfiConverterTypePublicKey.read(from: &buf), 
                address: FfiConverterTypeSocketAddress.read(from: &buf), 
                isPersisted: FfiConverterBool.read(from: &buf), 
                isConnected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PeerDetails, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.nodeId, into: &buf)
        FfiConverterTypeSocketAddress.write(value.address, into: &buf)
        FfiConverterBool.write(value.isPersisted, into: &buf)
        FfiConverterBool.write(value.isConnected, into: &buf)
    }
}


public func FfiConverterTypePeerDetails_lift(_ buf: RustBuffer) throws -> PeerDetails {
    return try FfiConverterTypePeerDetails.lift(buf)
}

public func FfiConverterTypePeerDetails_lower(_ value: PeerDetails) -> RustBuffer {
    return FfiConverterTypePeerDetails.lower(value)
}


public struct RouteHintHop {
    public var srcNodeId: PublicKey
    public var shortChannelId: UInt64
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64?
    public var htlcMaximumMsat: UInt64?
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(srcNodeId: PublicKey, shortChannelId: UInt64, cltvExpiryDelta: UInt16, htlcMinimumMsat: UInt64?, htlcMaximumMsat: UInt64?, fees: RoutingFees) {
        self.srcNodeId = srcNodeId
        self.shortChannelId = shortChannelId
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}



extension RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: RouteHintHop, rhs: RouteHintHop) -> Bool {
        if lhs.srcNodeId != rhs.srcNodeId {
            return false
        }
        if lhs.shortChannelId != rhs.shortChannelId {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(srcNodeId)
        hasher.combine(shortChannelId)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}


public struct FfiConverterTypeRouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHintHop {
        return
            try RouteHintHop(
                srcNodeId: FfiConverterTypePublicKey.read(from: &buf), 
                shortChannelId: FfiConverterUInt64.read(from: &buf), 
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf), 
                htlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                htlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf), 
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.srcNodeId, into: &buf)
        FfiConverterUInt64.write(value.shortChannelId, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}


public func FfiConverterTypeRouteHintHop_lift(_ buf: RustBuffer) throws -> RouteHintHop {
    return try FfiConverterTypeRouteHintHop.lift(buf)
}

public func FfiConverterTypeRouteHintHop_lower(_ value: RouteHintHop) -> RustBuffer {
    return FfiConverterTypeRouteHintHop.lower(value)
}


public struct RoutingFees {
    public var baseMsat: UInt32
    public var proportionalMillionths: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseMsat: UInt32, proportionalMillionths: UInt32) {
        self.baseMsat = baseMsat
        self.proportionalMillionths = proportionalMillionths
    }
}



extension RoutingFees: Equatable, Hashable {
    public static func ==(lhs: RoutingFees, rhs: RoutingFees) -> Bool {
        if lhs.baseMsat != rhs.baseMsat {
            return false
        }
        if lhs.proportionalMillionths != rhs.proportionalMillionths {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseMsat)
        hasher.combine(proportionalMillionths)
    }
}


public struct FfiConverterTypeRoutingFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoutingFees {
        return
            try RoutingFees(
                baseMsat: FfiConverterUInt32.read(from: &buf), 
                proportionalMillionths: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RoutingFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.baseMsat, into: &buf)
        FfiConverterUInt32.write(value.proportionalMillionths, into: &buf)
    }
}


public func FfiConverterTypeRoutingFees_lift(_ buf: RustBuffer) throws -> RoutingFees {
    return try FfiConverterTypeRoutingFees.lift(buf)
}

public func FfiConverterTypeRoutingFees_lower(_ value: RoutingFees) -> RustBuffer {
    return FfiConverterTypeRoutingFees.lower(value)
}


public struct SendingParameters {
    public var maxTotalRoutingFeeMsat: MaxTotalRoutingFeeLimit?
    public var maxTotalCltvExpiryDelta: UInt32?
    public var maxPathCount: UInt8?
    public var maxChannelSaturationPowerOfHalf: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(maxTotalRoutingFeeMsat: MaxTotalRoutingFeeLimit?, maxTotalCltvExpiryDelta: UInt32?, maxPathCount: UInt8?, maxChannelSaturationPowerOfHalf: UInt8?) {
        self.maxTotalRoutingFeeMsat = maxTotalRoutingFeeMsat
        self.maxTotalCltvExpiryDelta = maxTotalCltvExpiryDelta
        self.maxPathCount = maxPathCount
        self.maxChannelSaturationPowerOfHalf = maxChannelSaturationPowerOfHalf
    }
}



extension SendingParameters: Equatable, Hashable {
    public static func ==(lhs: SendingParameters, rhs: SendingParameters) -> Bool {
        if lhs.maxTotalRoutingFeeMsat != rhs.maxTotalRoutingFeeMsat {
            return false
        }
        if lhs.maxTotalCltvExpiryDelta != rhs.maxTotalCltvExpiryDelta {
            return false
        }
        if lhs.maxPathCount != rhs.maxPathCount {
            return false
        }
        if lhs.maxChannelSaturationPowerOfHalf != rhs.maxChannelSaturationPowerOfHalf {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalRoutingFeeMsat)
        hasher.combine(maxTotalCltvExpiryDelta)
        hasher.combine(maxPathCount)
        hasher.combine(maxChannelSaturationPowerOfHalf)
    }
}


public struct FfiConverterTypeSendingParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendingParameters {
        return
            try SendingParameters(
                maxTotalRoutingFeeMsat: FfiConverterOptionTypeMaxTotalRoutingFeeLimit.read(from: &buf), 
                maxTotalCltvExpiryDelta: FfiConverterOptionUInt32.read(from: &buf), 
                maxPathCount: FfiConverterOptionUInt8.read(from: &buf), 
                maxChannelSaturationPowerOfHalf: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SendingParameters, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMaxTotalRoutingFeeLimit.write(value.maxTotalRoutingFeeMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.maxTotalCltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt8.write(value.maxPathCount, into: &buf)
        FfiConverterOptionUInt8.write(value.maxChannelSaturationPowerOfHalf, into: &buf)
    }
}


public func FfiConverterTypeSendingParameters_lift(_ buf: RustBuffer) throws -> SendingParameters {
    return try FfiConverterTypeSendingParameters.lift(buf)
}

public func FfiConverterTypeSendingParameters_lower(_ value: SendingParameters) -> RustBuffer {
    return FfiConverterTypeSendingParameters.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BalanceSource {
    
    case holderForceClosed
    case counterpartyForceClosed
    case coopClose
    case htlc
}


public struct FfiConverterTypeBalanceSource: FfiConverterRustBuffer {
    typealias SwiftType = BalanceSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .holderForceClosed
        
        case 2: return .counterpartyForceClosed
        
        case 3: return .coopClose
        
        case 4: return .htlc
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BalanceSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case .holderForceClosed:
            writeInt(&buf, Int32(1))
        
        
        case .counterpartyForceClosed:
            writeInt(&buf, Int32(2))
        
        
        case .coopClose:
            writeInt(&buf, Int32(3))
        
        
        case .htlc:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeBalanceSource_lift(_ buf: RustBuffer) throws -> BalanceSource {
    return try FfiConverterTypeBalanceSource.lift(buf)
}

public func FfiConverterTypeBalanceSource_lower(_ value: BalanceSource) -> RustBuffer {
    return FfiConverterTypeBalanceSource.lower(value)
}



extension BalanceSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Bolt11InvoiceDescription {
    
    case hash(hash: String
    )
    case direct(description: String
    )
}


public struct FfiConverterTypeBolt11InvoiceDescription: FfiConverterRustBuffer {
    typealias SwiftType = Bolt11InvoiceDescription

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11InvoiceDescription {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hash(hash: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .direct(description: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bolt11InvoiceDescription, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hash(hash):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .direct(description):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(description, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBolt11InvoiceDescription_lift(_ buf: RustBuffer) throws -> Bolt11InvoiceDescription {
    return try FfiConverterTypeBolt11InvoiceDescription.lift(buf)
}

public func FfiConverterTypeBolt11InvoiceDescription_lower(_ value: Bolt11InvoiceDescription) -> RustBuffer {
    return FfiConverterTypeBolt11InvoiceDescription.lower(value)
}



extension Bolt11InvoiceDescription: Equatable, Hashable {}




public enum BuildError {

    
    
    case InvalidSeedBytes(message: String)
    
    case InvalidSeedFile(message: String)
    
    case InvalidSystemTime(message: String)
    
    case InvalidChannelMonitor(message: String)
    
    case InvalidListeningAddresses(message: String)
    
    case InvalidAnnouncementAddresses(message: String)
    
    case InvalidNodeAlias(message: String)
    
    case ReadFailed(message: String)
    
    case WriteFailed(message: String)
    
    case StoragePathAccessFailed(message: String)
    
    case KvStoreSetupFailed(message: String)
    
    case WalletSetupFailed(message: String)
    
    case LoggerSetupFailed(message: String)
    
    case NetworkMismatch(message: String)
    
}


public struct FfiConverterTypeBuildError: FfiConverterRustBuffer {
    typealias SwiftType = BuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSeedBytes(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidSeedFile(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidSystemTime(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidChannelMonitor(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidListeningAddresses(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidAnnouncementAddresses(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .InvalidNodeAlias(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .ReadFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .WriteFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .StoragePathAccessFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .KvStoreSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .WalletSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .LoggerSetupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .NetworkMismatch(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuildError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidSeedBytes(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidSeedFile(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidSystemTime(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidChannelMonitor(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidListeningAddresses(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidAnnouncementAddresses(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .InvalidNodeAlias(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .ReadFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .WriteFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .StoragePathAccessFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .KvStoreSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .WalletSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .LoggerSetupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .NetworkMismatch(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))

        
        }
    }
}


extension BuildError: Equatable, Hashable {}

extension BuildError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ClosureReason {
    
    case counterpartyForceClosed(peerMsg: UntrustedString
    )
    case holderForceClosed(broadcastedLatestTxn: Bool?
    )
    case legacyCooperativeClosure
    case counterpartyInitiatedCooperativeClosure
    case locallyInitiatedCooperativeClosure
    case commitmentTxConfirmed
    case fundingTimedOut
    case processingError(err: String
    )
    case disconnectedPeer
    case outdatedChannelManager
    case counterpartyCoopClosedUnfundedChannel
    case fundingBatchClosure
    case htlCsTimedOut
    case peerFeerateTooLow(peerFeerateSatPerKw: UInt32, requiredFeerateSatPerKw: UInt32
    )
}


public struct FfiConverterTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .counterpartyForceClosed(peerMsg: try FfiConverterTypeUntrustedString.read(from: &buf)
        )
        
        case 2: return .holderForceClosed(broadcastedLatestTxn: try FfiConverterOptionBool.read(from: &buf)
        )
        
        case 3: return .legacyCooperativeClosure
        
        case 4: return .counterpartyInitiatedCooperativeClosure
        
        case 5: return .locallyInitiatedCooperativeClosure
        
        case 6: return .commitmentTxConfirmed
        
        case 7: return .fundingTimedOut
        
        case 8: return .processingError(err: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .disconnectedPeer
        
        case 10: return .outdatedChannelManager
        
        case 11: return .counterpartyCoopClosedUnfundedChannel
        
        case 12: return .fundingBatchClosure
        
        case 13: return .htlCsTimedOut
        
        case 14: return .peerFeerateTooLow(peerFeerateSatPerKw: try FfiConverterUInt32.read(from: &buf), requiredFeerateSatPerKw: try FfiConverterUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClosureReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .counterpartyForceClosed(peerMsg):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUntrustedString.write(peerMsg, into: &buf)
            
        
        case let .holderForceClosed(broadcastedLatestTxn):
            writeInt(&buf, Int32(2))
            FfiConverterOptionBool.write(broadcastedLatestTxn, into: &buf)
            
        
        case .legacyCooperativeClosure:
            writeInt(&buf, Int32(3))
        
        
        case .counterpartyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(4))
        
        
        case .locallyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(5))
        
        
        case .commitmentTxConfirmed:
            writeInt(&buf, Int32(6))
        
        
        case .fundingTimedOut:
            writeInt(&buf, Int32(7))
        
        
        case let .processingError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)
            
        
        case .disconnectedPeer:
            writeInt(&buf, Int32(9))
        
        
        case .outdatedChannelManager:
            writeInt(&buf, Int32(10))
        
        
        case .counterpartyCoopClosedUnfundedChannel:
            writeInt(&buf, Int32(11))
        
        
        case .fundingBatchClosure:
            writeInt(&buf, Int32(12))
        
        
        case .htlCsTimedOut:
            writeInt(&buf, Int32(13))
        
        
        case let .peerFeerateTooLow(peerFeerateSatPerKw,requiredFeerateSatPerKw):
            writeInt(&buf, Int32(14))
            FfiConverterUInt32.write(peerFeerateSatPerKw, into: &buf)
            FfiConverterUInt32.write(requiredFeerateSatPerKw, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClosureReason_lift(_ buf: RustBuffer) throws -> ClosureReason {
    return try FfiConverterTypeClosureReason.lift(buf)
}

public func FfiConverterTypeClosureReason_lower(_ value: ClosureReason) -> RustBuffer {
    return FfiConverterTypeClosureReason.lower(value)
}



extension ClosureReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ConfirmationStatus {
    
    case confirmed(blockHash: BlockHash, height: UInt32, timestamp: UInt64
    )
    case unconfirmed
}


public struct FfiConverterTypeConfirmationStatus: FfiConverterRustBuffer {
    typealias SwiftType = ConfirmationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .confirmed(blockHash: try FfiConverterTypeBlockHash.read(from: &buf), height: try FfiConverterUInt32.read(from: &buf), timestamp: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .unconfirmed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfirmationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .confirmed(blockHash,height,timestamp):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBlockHash.write(blockHash, into: &buf)
            FfiConverterUInt32.write(height, into: &buf)
            FfiConverterUInt64.write(timestamp, into: &buf)
            
        
        case .unconfirmed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeConfirmationStatus_lift(_ buf: RustBuffer) throws -> ConfirmationStatus {
    return try FfiConverterTypeConfirmationStatus.lift(buf)
}

public func FfiConverterTypeConfirmationStatus_lower(_ value: ConfirmationStatus) -> RustBuffer {
    return FfiConverterTypeConfirmationStatus.lower(value)
}



extension ConfirmationStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Currency {
    
    case bitcoin
    case bitcoinTestnet
    case regtest
    case simnet
    case signet
}


public struct FfiConverterTypeCurrency: FfiConverterRustBuffer {
    typealias SwiftType = Currency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Currency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .bitcoinTestnet
        
        case 3: return .regtest
        
        case 4: return .simnet
        
        case 5: return .signet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Currency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .bitcoinTestnet:
            writeInt(&buf, Int32(2))
        
        
        case .regtest:
            writeInt(&buf, Int32(3))
        
        
        case .simnet:
            writeInt(&buf, Int32(4))
        
        
        case .signet:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeCurrency_lift(_ buf: RustBuffer) throws -> Currency {
    return try FfiConverterTypeCurrency.lift(buf)
}

public func FfiConverterTypeCurrency_lower(_ value: Currency) -> RustBuffer {
    return FfiConverterTypeCurrency.lower(value)
}



extension Currency: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Event {
    
    case paymentSuccessful(paymentId: PaymentId?, paymentHash: PaymentHash, paymentPreimage: PaymentPreimage?, feePaidMsat: UInt64?
    )
    case paymentFailed(paymentId: PaymentId?, paymentHash: PaymentHash?, reason: PaymentFailureReason?
    )
    case paymentReceived(paymentId: PaymentId?, paymentHash: PaymentHash, amountMsat: UInt64, customRecords: [CustomTlvRecord]
    )
    case paymentClaimable(paymentId: PaymentId, paymentHash: PaymentHash, claimableAmountMsat: UInt64, claimDeadline: UInt32?, customRecords: [CustomTlvRecord]
    )
    case paymentForwarded(prevChannelId: ChannelId, nextChannelId: ChannelId, prevUserChannelId: UserChannelId?, nextUserChannelId: UserChannelId?, prevNodeId: PublicKey?, nextNodeId: PublicKey?, totalFeeEarnedMsat: UInt64?, skimmedFeeMsat: UInt64?, claimFromOnchainTx: Bool, outboundAmountForwardedMsat: UInt64?
    )
    case channelPending(channelId: ChannelId, userChannelId: UserChannelId, formerTemporaryChannelId: ChannelId, counterpartyNodeId: PublicKey, fundingTxo: OutPoint
    )
    case channelReady(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey?
    )
    case channelClosed(channelId: ChannelId, userChannelId: UserChannelId, counterpartyNodeId: PublicKey?, reason: ClosureReason?
    )
}


public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentSuccessful(paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), paymentPreimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), feePaidMsat: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 2: return .paymentFailed(paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: try FfiConverterOptionTypePaymentHash.read(from: &buf), reason: try FfiConverterOptionTypePaymentFailureReason.read(from: &buf)
        )
        
        case 3: return .paymentReceived(paymentId: try FfiConverterOptionTypePaymentId.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), amountMsat: try FfiConverterUInt64.read(from: &buf), customRecords: try FfiConverterSequenceTypeCustomTlvRecord.read(from: &buf)
        )
        
        case 4: return .paymentClaimable(paymentId: try FfiConverterTypePaymentId.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), claimableAmountMsat: try FfiConverterUInt64.read(from: &buf), claimDeadline: try FfiConverterOptionUInt32.read(from: &buf), customRecords: try FfiConverterSequenceTypeCustomTlvRecord.read(from: &buf)
        )
        
        case 5: return .paymentForwarded(prevChannelId: try FfiConverterTypeChannelId.read(from: &buf), nextChannelId: try FfiConverterTypeChannelId.read(from: &buf), prevUserChannelId: try FfiConverterOptionTypeUserChannelId.read(from: &buf), nextUserChannelId: try FfiConverterOptionTypeUserChannelId.read(from: &buf), prevNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf), nextNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf), totalFeeEarnedMsat: try FfiConverterOptionUInt64.read(from: &buf), skimmedFeeMsat: try FfiConverterOptionUInt64.read(from: &buf), claimFromOnchainTx: try FfiConverterBool.read(from: &buf), outboundAmountForwardedMsat: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 6: return .channelPending(channelId: try FfiConverterTypeChannelId.read(from: &buf), userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), formerTemporaryChannelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), fundingTxo: try FfiConverterTypeOutPoint.read(from: &buf)
        )
        
        case 7: return .channelReady(channelId: try FfiConverterTypeChannelId.read(from: &buf), userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf)
        )
        
        case 8: return .channelClosed(channelId: try FfiConverterTypeChannelId.read(from: &buf), userChannelId: try FfiConverterTypeUserChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterOptionTypePublicKey.read(from: &buf), reason: try FfiConverterOptionTypeClosureReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .paymentSuccessful(paymentId,paymentHash,paymentPreimage,feePaidMsat):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(paymentPreimage, into: &buf)
            FfiConverterOptionUInt64.write(feePaidMsat, into: &buf)
            
        
        case let .paymentFailed(paymentId,paymentHash,reason):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterOptionTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentFailureReason.write(reason, into: &buf)
            
        
        case let .paymentReceived(paymentId,paymentHash,amountMsat,customRecords):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(amountMsat, into: &buf)
            FfiConverterSequenceTypeCustomTlvRecord.write(customRecords, into: &buf)
            
        
        case let .paymentClaimable(paymentId,paymentHash,claimableAmountMsat,claimDeadline,customRecords):
            writeInt(&buf, Int32(4))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(claimableAmountMsat, into: &buf)
            FfiConverterOptionUInt32.write(claimDeadline, into: &buf)
            FfiConverterSequenceTypeCustomTlvRecord.write(customRecords, into: &buf)
            
        
        case let .paymentForwarded(prevChannelId,nextChannelId,prevUserChannelId,nextUserChannelId,prevNodeId,nextNodeId,totalFeeEarnedMsat,skimmedFeeMsat,claimFromOnchainTx,outboundAmountForwardedMsat):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(prevChannelId, into: &buf)
            FfiConverterTypeChannelId.write(nextChannelId, into: &buf)
            FfiConverterOptionTypeUserChannelId.write(prevUserChannelId, into: &buf)
            FfiConverterOptionTypeUserChannelId.write(nextUserChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(prevNodeId, into: &buf)
            FfiConverterOptionTypePublicKey.write(nextNodeId, into: &buf)
            FfiConverterOptionUInt64.write(totalFeeEarnedMsat, into: &buf)
            FfiConverterOptionUInt64.write(skimmedFeeMsat, into: &buf)
            FfiConverterBool.write(claimFromOnchainTx, into: &buf)
            FfiConverterOptionUInt64.write(outboundAmountForwardedMsat, into: &buf)
            
        
        case let .channelPending(channelId,userChannelId,formerTemporaryChannelId,counterpartyNodeId,fundingTxo):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypeChannelId.write(formerTemporaryChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterTypeOutPoint.write(fundingTxo, into: &buf)
            
        
        case let .channelReady(channelId,userChannelId,counterpartyNodeId):
            writeInt(&buf, Int32(7))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            
        
        case let .channelClosed(channelId,userChannelId,counterpartyNodeId,reason):
            writeInt(&buf, Int32(8))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeClosureReason.write(reason, into: &buf)
            
        }
    }
}


public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}



extension Event: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LightningBalance {
    
    case claimableOnChannelClose(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, transactionFeeSatoshis: UInt64, outboundPaymentHtlcRoundedMsat: UInt64, outboundForwardedHtlcRoundedMsat: UInt64, inboundClaimingHtlcRoundedMsat: UInt64, inboundHtlcRoundedMsat: UInt64
    )
    case claimableAwaitingConfirmations(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, confirmationHeight: UInt32, source: BalanceSource
    )
    case contentiousClaimable(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, timeoutHeight: UInt32, paymentHash: PaymentHash, paymentPreimage: PaymentPreimage
    )
    case maybeTimeoutClaimableHtlc(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, claimableHeight: UInt32, paymentHash: PaymentHash, outboundPayment: Bool
    )
    case maybePreimageClaimableHtlc(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64, expiryHeight: UInt32, paymentHash: PaymentHash
    )
    case counterpartyRevokedOutputClaimable(channelId: ChannelId, counterpartyNodeId: PublicKey, amountSatoshis: UInt64
    )
}


public struct FfiConverterTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = LightningBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .claimableOnChannelClose(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf), transactionFeeSatoshis: try FfiConverterUInt64.read(from: &buf), outboundPaymentHtlcRoundedMsat: try FfiConverterUInt64.read(from: &buf), outboundForwardedHtlcRoundedMsat: try FfiConverterUInt64.read(from: &buf), inboundClaimingHtlcRoundedMsat: try FfiConverterUInt64.read(from: &buf), inboundHtlcRoundedMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .claimableAwaitingConfirmations(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf), confirmationHeight: try FfiConverterUInt32.read(from: &buf), source: try FfiConverterTypeBalanceSource.read(from: &buf)
        )
        
        case 3: return .contentiousClaimable(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf), timeoutHeight: try FfiConverterUInt32.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), paymentPreimage: try FfiConverterTypePaymentPreimage.read(from: &buf)
        )
        
        case 4: return .maybeTimeoutClaimableHtlc(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf), claimableHeight: try FfiConverterUInt32.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf), outboundPayment: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .maybePreimageClaimableHtlc(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf), expiryHeight: try FfiConverterUInt32.read(from: &buf), paymentHash: try FfiConverterTypePaymentHash.read(from: &buf)
        )
        
        case 6: return .counterpartyRevokedOutputClaimable(channelId: try FfiConverterTypeChannelId.read(from: &buf), counterpartyNodeId: try FfiConverterTypePublicKey.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningBalance, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .claimableOnChannelClose(channelId,counterpartyNodeId,amountSatoshis,transactionFeeSatoshis,outboundPaymentHtlcRoundedMsat,outboundForwardedHtlcRoundedMsat,inboundClaimingHtlcRoundedMsat,inboundHtlcRoundedMsat):
            writeInt(&buf, Int32(1))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt64.write(transactionFeeSatoshis, into: &buf)
            FfiConverterUInt64.write(outboundPaymentHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(outboundForwardedHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundClaimingHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundHtlcRoundedMsat, into: &buf)
            
        
        case let .claimableAwaitingConfirmations(channelId,counterpartyNodeId,amountSatoshis,confirmationHeight,source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterTypeBalanceSource.write(source, into: &buf)
            
        
        case let .contentiousClaimable(channelId,counterpartyNodeId,amountSatoshis,timeoutHeight,paymentHash,paymentPreimage):
            writeInt(&buf, Int32(3))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(timeoutHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterTypePaymentPreimage.write(paymentPreimage, into: &buf)
            
        
        case let .maybeTimeoutClaimableHtlc(channelId,counterpartyNodeId,amountSatoshis,claimableHeight,paymentHash,outboundPayment):
            writeInt(&buf, Int32(4))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(claimableHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterBool.write(outboundPayment, into: &buf)
            
        
        case let .maybePreimageClaimableHtlc(channelId,counterpartyNodeId,amountSatoshis,expiryHeight,paymentHash):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(expiryHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            
        
        case let .counterpartyRevokedOutputClaimable(channelId,counterpartyNodeId,amountSatoshis):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLightningBalance_lift(_ buf: RustBuffer) throws -> LightningBalance {
    return try FfiConverterTypeLightningBalance.lift(buf)
}

public func FfiConverterTypeLightningBalance_lower(_ value: LightningBalance) -> RustBuffer {
    return FfiConverterTypeLightningBalance.lower(value)
}



extension LightningBalance: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    
    case gossip
    case trace
    case debug
    case info
    case warn
    case error
}


public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gossip
        
        case 2: return .trace
        
        case 3: return .debug
        
        case 4: return .info
        
        case 5: return .warn
        
        case 6: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gossip:
            writeInt(&buf, Int32(1))
        
        
        case .trace:
            writeInt(&buf, Int32(2))
        
        
        case .debug:
            writeInt(&buf, Int32(3))
        
        
        case .info:
            writeInt(&buf, Int32(4))
        
        
        case .warn:
            writeInt(&buf, Int32(5))
        
        
        case .error:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}



extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MaxDustHtlcExposure {
    
    case fixedLimit(limitMsat: UInt64
    )
    case feeRateMultiplier(multiplier: UInt64
    )
}


public struct FfiConverterTypeMaxDustHTLCExposure: FfiConverterRustBuffer {
    typealias SwiftType = MaxDustHtlcExposure

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxDustHtlcExposure {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fixedLimit(limitMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .feeRateMultiplier(multiplier: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxDustHtlcExposure, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fixedLimit(limitMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(limitMsat, into: &buf)
            
        
        case let .feeRateMultiplier(multiplier):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(multiplier, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMaxDustHTLCExposure_lift(_ buf: RustBuffer) throws -> MaxDustHtlcExposure {
    return try FfiConverterTypeMaxDustHTLCExposure.lift(buf)
}

public func FfiConverterTypeMaxDustHTLCExposure_lower(_ value: MaxDustHtlcExposure) -> RustBuffer {
    return FfiConverterTypeMaxDustHTLCExposure.lower(value)
}



extension MaxDustHtlcExposure: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MaxTotalRoutingFeeLimit {
    
    case none
    case some(amountMsat: UInt64
    )
}


public struct FfiConverterTypeMaxTotalRoutingFeeLimit: FfiConverterRustBuffer {
    typealias SwiftType = MaxTotalRoutingFeeLimit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxTotalRoutingFeeLimit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .some(amountMsat: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxTotalRoutingFeeLimit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .some(amountMsat):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(amountMsat, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMaxTotalRoutingFeeLimit_lift(_ buf: RustBuffer) throws -> MaxTotalRoutingFeeLimit {
    return try FfiConverterTypeMaxTotalRoutingFeeLimit.lift(buf)
}

public func FfiConverterTypeMaxTotalRoutingFeeLimit_lower(_ value: MaxTotalRoutingFeeLimit) -> RustBuffer {
    return FfiConverterTypeMaxTotalRoutingFeeLimit.lower(value)
}



extension MaxTotalRoutingFeeLimit: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Network {
    
    case bitcoin
    case testnet
    case signet
    case regtest
}


public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bitcoin
        
        case 2: return .testnet
        
        case 3: return .signet
        
        case 4: return .regtest
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bitcoin:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        
        case .signet:
            writeInt(&buf, Int32(3))
        
        
        case .regtest:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}



extension Network: Equatable, Hashable {}




public enum NodeError {

    
    
    case AlreadyRunning(message: String)
    
    case NotRunning(message: String)
    
    case OnchainTxCreationFailed(message: String)
    
    case ConnectionFailed(message: String)
    
    case InvoiceCreationFailed(message: String)
    
    case InvoiceRequestCreationFailed(message: String)
    
    case OfferCreationFailed(message: String)
    
    case RefundCreationFailed(message: String)
    
    case PaymentSendingFailed(message: String)
    
    case InvalidCustomTlvs(message: String)
    
    case ProbeSendingFailed(message: String)
    
    case ChannelCreationFailed(message: String)
    
    case ChannelClosingFailed(message: String)
    
    case ChannelConfigUpdateFailed(message: String)
    
    case PersistenceFailed(message: String)
    
    case FeerateEstimationUpdateFailed(message: String)
    
    case FeerateEstimationUpdateTimeout(message: String)
    
    case WalletOperationFailed(message: String)
    
    case WalletOperationTimeout(message: String)
    
    case OnchainTxSigningFailed(message: String)
    
    case TxSyncFailed(message: String)
    
    case TxSyncTimeout(message: String)
    
    case GossipUpdateFailed(message: String)
    
    case GossipUpdateTimeout(message: String)
    
    case LiquidityRequestFailed(message: String)
    
    case UriParameterParsingFailed(message: String)
    
    case InvalidAddress(message: String)
    
    case InvalidSocketAddress(message: String)
    
    case InvalidPublicKey(message: String)
    
    case InvalidSecretKey(message: String)
    
    case InvalidOfferId(message: String)
    
    case InvalidNodeId(message: String)
    
    case InvalidPaymentId(message: String)
    
    case InvalidPaymentHash(message: String)
    
    case InvalidPaymentPreimage(message: String)
    
    case InvalidPaymentSecret(message: String)
    
    case InvalidAmount(message: String)
    
    case InvalidInvoice(message: String)
    
    case InvalidOffer(message: String)
    
    case InvalidRefund(message: String)
    
    case InvalidChannelId(message: String)
    
    case InvalidNetwork(message: String)
    
    case InvalidUri(message: String)
    
    case InvalidQuantity(message: String)
    
    case InvalidNodeAlias(message: String)
    
    case InvalidDateTime(message: String)
    
    case InvalidFeeRate(message: String)
    
    case DuplicatePayment(message: String)
    
    case UnsupportedCurrency(message: String)
    
    case InsufficientFunds(message: String)
    
    case LiquiditySourceUnavailable(message: String)
    
    case LiquidityFeeTooHigh(message: String)
    
}


public struct FfiConverterTypeNodeError: FfiConverterRustBuffer {
    typealias SwiftType = NodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AlreadyRunning(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NotRunning(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .OnchainTxCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .ConnectionFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvoiceCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvoiceRequestCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .OfferCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .RefundCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .PaymentSendingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .InvalidCustomTlvs(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ProbeSendingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .ChannelCreationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .ChannelClosingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .ChannelConfigUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .PersistenceFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .FeerateEstimationUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .FeerateEstimationUpdateTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .WalletOperationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .WalletOperationTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .OnchainTxSigningFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .TxSyncFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .TxSyncTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .GossipUpdateFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 24: return .GossipUpdateTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .LiquidityRequestFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .UriParameterParsingFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .InvalidAddress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .InvalidSocketAddress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 29: return .InvalidPublicKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .InvalidSecretKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .InvalidOfferId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .InvalidNodeId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 33: return .InvalidPaymentId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .InvalidPaymentHash(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .InvalidPaymentPreimage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .InvalidPaymentSecret(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 38: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 39: return .InvalidOffer(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .InvalidRefund(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .InvalidChannelId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .InvalidNetwork(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .InvalidUri(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 44: return .InvalidQuantity(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 45: return .InvalidNodeAlias(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 46: return .InvalidDateTime(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 47: return .InvalidFeeRate(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 48: return .DuplicatePayment(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 49: return .UnsupportedCurrency(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 50: return .InsufficientFunds(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 51: return .LiquiditySourceUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 52: return .LiquidityFeeTooHigh(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AlreadyRunning(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .NotRunning(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .OnchainTxCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .ConnectionFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvoiceCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvoiceRequestCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .OfferCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .RefundCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .PaymentSendingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .InvalidCustomTlvs(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .ProbeSendingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .ChannelCreationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .ChannelClosingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .ChannelConfigUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .PersistenceFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .FeerateEstimationUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .FeerateEstimationUpdateTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .WalletOperationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))
        case .WalletOperationTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(19))
        case .OnchainTxSigningFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(20))
        case .TxSyncFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(21))
        case .TxSyncTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(22))
        case .GossipUpdateFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(23))
        case .GossipUpdateTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(24))
        case .LiquidityRequestFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(25))
        case .UriParameterParsingFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(26))
        case .InvalidAddress(_ /* message is ignored*/):
            writeInt(&buf, Int32(27))
        case .InvalidSocketAddress(_ /* message is ignored*/):
            writeInt(&buf, Int32(28))
        case .InvalidPublicKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(29))
        case .InvalidSecretKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(30))
        case .InvalidOfferId(_ /* message is ignored*/):
            writeInt(&buf, Int32(31))
        case .InvalidNodeId(_ /* message is ignored*/):
            writeInt(&buf, Int32(32))
        case .InvalidPaymentId(_ /* message is ignored*/):
            writeInt(&buf, Int32(33))
        case .InvalidPaymentHash(_ /* message is ignored*/):
            writeInt(&buf, Int32(34))
        case .InvalidPaymentPreimage(_ /* message is ignored*/):
            writeInt(&buf, Int32(35))
        case .InvalidPaymentSecret(_ /* message is ignored*/):
            writeInt(&buf, Int32(36))
        case .InvalidAmount(_ /* message is ignored*/):
            writeInt(&buf, Int32(37))
        case .InvalidInvoice(_ /* message is ignored*/):
            writeInt(&buf, Int32(38))
        case .InvalidOffer(_ /* message is ignored*/):
            writeInt(&buf, Int32(39))
        case .InvalidRefund(_ /* message is ignored*/):
            writeInt(&buf, Int32(40))
        case .InvalidChannelId(_ /* message is ignored*/):
            writeInt(&buf, Int32(41))
        case .InvalidNetwork(_ /* message is ignored*/):
            writeInt(&buf, Int32(42))
        case .InvalidUri(_ /* message is ignored*/):
            writeInt(&buf, Int32(43))
        case .InvalidQuantity(_ /* message is ignored*/):
            writeInt(&buf, Int32(44))
        case .InvalidNodeAlias(_ /* message is ignored*/):
            writeInt(&buf, Int32(45))
        case .InvalidDateTime(_ /* message is ignored*/):
            writeInt(&buf, Int32(46))
        case .InvalidFeeRate(_ /* message is ignored*/):
            writeInt(&buf, Int32(47))
        case .DuplicatePayment(_ /* message is ignored*/):
            writeInt(&buf, Int32(48))
        case .UnsupportedCurrency(_ /* message is ignored*/):
            writeInt(&buf, Int32(49))
        case .InsufficientFunds(_ /* message is ignored*/):
            writeInt(&buf, Int32(50))
        case .LiquiditySourceUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(51))
        case .LiquidityFeeTooHigh(_ /* message is ignored*/):
            writeInt(&buf, Int32(52))

        
        }
    }
}


extension NodeError: Equatable, Hashable {}

extension NodeError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentDirection {
    
    case inbound
    case outbound
}


public struct FfiConverterTypePaymentDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .inbound
        
        case 2: return .outbound
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDirection, into buf: inout [UInt8]) {
        switch value {
        
        
        case .inbound:
            writeInt(&buf, Int32(1))
        
        
        case .outbound:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypePaymentDirection_lift(_ buf: RustBuffer) throws -> PaymentDirection {
    return try FfiConverterTypePaymentDirection.lift(buf)
}

public func FfiConverterTypePaymentDirection_lower(_ value: PaymentDirection) -> RustBuffer {
    return FfiConverterTypePaymentDirection.lower(value)
}



extension PaymentDirection: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentFailureReason {
    
    case recipientRejected
    case userAbandoned
    case retriesExhausted
    case paymentExpired
    case routeNotFound
    case unexpectedError
    case unknownRequiredFeatures
    case invoiceRequestExpired
    case invoiceRequestRejected
    case blindedPathCreationFailed
}


public struct FfiConverterTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .recipientRejected
        
        case 2: return .userAbandoned
        
        case 3: return .retriesExhausted
        
        case 4: return .paymentExpired
        
        case 5: return .routeNotFound
        
        case 6: return .unexpectedError
        
        case 7: return .unknownRequiredFeatures
        
        case 8: return .invoiceRequestExpired
        
        case 9: return .invoiceRequestRejected
        
        case 10: return .blindedPathCreationFailed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFailureReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .recipientRejected:
            writeInt(&buf, Int32(1))
        
        
        case .userAbandoned:
            writeInt(&buf, Int32(2))
        
        
        case .retriesExhausted:
            writeInt(&buf, Int32(3))
        
        
        case .paymentExpired:
            writeInt(&buf, Int32(4))
        
        
        case .routeNotFound:
            writeInt(&buf, Int32(5))
        
        
        case .unexpectedError:
            writeInt(&buf, Int32(6))
        
        
        case .unknownRequiredFeatures:
            writeInt(&buf, Int32(7))
        
        
        case .invoiceRequestExpired:
            writeInt(&buf, Int32(8))
        
        
        case .invoiceRequestRejected:
            writeInt(&buf, Int32(9))
        
        
        case .blindedPathCreationFailed:
            writeInt(&buf, Int32(10))
        
        }
    }
}


public func FfiConverterTypePaymentFailureReason_lift(_ buf: RustBuffer) throws -> PaymentFailureReason {
    return try FfiConverterTypePaymentFailureReason.lift(buf)
}

public func FfiConverterTypePaymentFailureReason_lower(_ value: PaymentFailureReason) -> RustBuffer {
    return FfiConverterTypePaymentFailureReason.lower(value)
}



extension PaymentFailureReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentKind {
    
    case onchain(txid: Txid, status: ConfirmationStatus
    )
    case bolt11(hash: PaymentHash, preimage: PaymentPreimage?, secret: PaymentSecret?
    )
    case bolt11Jit(hash: PaymentHash, preimage: PaymentPreimage?, secret: PaymentSecret?, counterpartySkimmedFeeMsat: UInt64?, lspFeeLimits: LspFeeLimits
    )
    case bolt12Offer(hash: PaymentHash?, preimage: PaymentPreimage?, secret: PaymentSecret?, offerId: OfferId, payerNote: UntrustedString?, quantity: UInt64?
    )
    case bolt12Refund(hash: PaymentHash?, preimage: PaymentPreimage?, secret: PaymentSecret?, payerNote: UntrustedString?, quantity: UInt64?
    )
    case spontaneous(hash: PaymentHash, preimage: PaymentPreimage?
    )
}


public struct FfiConverterTypePaymentKind: FfiConverterRustBuffer {
    typealias SwiftType = PaymentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .onchain(txid: try FfiConverterTypeTxid.read(from: &buf), status: try FfiConverterTypeConfirmationStatus.read(from: &buf)
        )
        
        case 2: return .bolt11(hash: try FfiConverterTypePaymentHash.read(from: &buf), preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf)
        )
        
        case 3: return .bolt11Jit(hash: try FfiConverterTypePaymentHash.read(from: &buf), preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf), counterpartySkimmedFeeMsat: try FfiConverterOptionUInt64.read(from: &buf), lspFeeLimits: try FfiConverterTypeLSPFeeLimits.read(from: &buf)
        )
        
        case 4: return .bolt12Offer(hash: try FfiConverterOptionTypePaymentHash.read(from: &buf), preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf), offerId: try FfiConverterTypeOfferId.read(from: &buf), payerNote: try FfiConverterOptionTypeUntrustedString.read(from: &buf), quantity: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 5: return .bolt12Refund(hash: try FfiConverterOptionTypePaymentHash.read(from: &buf), preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf), secret: try FfiConverterOptionTypePaymentSecret.read(from: &buf), payerNote: try FfiConverterOptionTypeUntrustedString.read(from: &buf), quantity: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 6: return .spontaneous(hash: try FfiConverterTypePaymentHash.read(from: &buf), preimage: try FfiConverterOptionTypePaymentPreimage.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .onchain(txid,status):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTxid.write(txid, into: &buf)
            FfiConverterTypeConfirmationStatus.write(status, into: &buf)
            
        
        case let .bolt11(hash,preimage,secret):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            
        
        case let .bolt11Jit(hash,preimage,secret,counterpartySkimmedFeeMsat,lspFeeLimits):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionUInt64.write(counterpartySkimmedFeeMsat, into: &buf)
            FfiConverterTypeLSPFeeLimits.write(lspFeeLimits, into: &buf)
            
        
        case let .bolt12Offer(hash,preimage,secret,offerId,payerNote,quantity):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeOfferId.write(offerId, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)
            
        
        case let .bolt12Refund(hash,preimage,secret,payerNote,quantity):
            writeInt(&buf, Int32(5))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)
            
        
        case let .spontaneous(hash,preimage):
            writeInt(&buf, Int32(6))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaymentKind_lift(_ buf: RustBuffer) throws -> PaymentKind {
    return try FfiConverterTypePaymentKind.lift(buf)
}

public func FfiConverterTypePaymentKind_lower(_ value: PaymentKind) -> RustBuffer {
    return FfiConverterTypePaymentKind.lower(value)
}



extension PaymentKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentState {
    
    case expectPayment
    case paid
    case refunded
}


public struct FfiConverterTypePaymentState: FfiConverterRustBuffer {
    typealias SwiftType = PaymentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .expectPayment
        
        case 2: return .paid
        
        case 3: return .refunded
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .expectPayment:
            writeInt(&buf, Int32(1))
        
        
        case .paid:
            writeInt(&buf, Int32(2))
        
        
        case .refunded:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentState_lift(_ buf: RustBuffer) throws -> PaymentState {
    return try FfiConverterTypePaymentState.lift(buf)
}

public func FfiConverterTypePaymentState_lower(_ value: PaymentState) -> RustBuffer {
    return FfiConverterTypePaymentState.lower(value)
}



extension PaymentState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PaymentStatus {
    
    case pending
    case succeeded
    case failed
}


public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .succeeded
        
        case 3: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .succeeded:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}



extension PaymentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PendingSweepBalance {
    
    case pendingBroadcast(channelId: ChannelId?, amountSatoshis: UInt64
    )
    case broadcastAwaitingConfirmation(channelId: ChannelId?, latestBroadcastHeight: UInt32, latestSpendingTxid: Txid, amountSatoshis: UInt64
    )
    case awaitingThresholdConfirmations(channelId: ChannelId?, latestSpendingTxid: Txid, confirmationHash: BlockHash, confirmationHeight: UInt32, amountSatoshis: UInt64
    )
}


public struct FfiConverterTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = PendingSweepBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingSweepBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pendingBroadcast(channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .broadcastAwaitingConfirmation(channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), latestBroadcastHeight: try FfiConverterUInt32.read(from: &buf), latestSpendingTxid: try FfiConverterTypeTxid.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .awaitingThresholdConfirmations(channelId: try FfiConverterOptionTypeChannelId.read(from: &buf), latestSpendingTxid: try FfiConverterTypeTxid.read(from: &buf), confirmationHash: try FfiConverterTypeBlockHash.read(from: &buf), confirmationHeight: try FfiConverterUInt32.read(from: &buf), amountSatoshis: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingSweepBalance, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pendingBroadcast(channelId,amountSatoshis):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        
        case let .broadcastAwaitingConfirmation(channelId,latestBroadcastHeight,latestSpendingTxid,amountSatoshis):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt32.write(latestBroadcastHeight, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        
        case let .awaitingThresholdConfirmations(channelId,latestSpendingTxid,confirmationHash,confirmationHeight,amountSatoshis):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterTypeBlockHash.write(confirmationHash, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            
        }
    }
}


public func FfiConverterTypePendingSweepBalance_lift(_ buf: RustBuffer) throws -> PendingSweepBalance {
    return try FfiConverterTypePendingSweepBalance.lift(buf)
}

public func FfiConverterTypePendingSweepBalance_lower(_ value: PendingSweepBalance) -> RustBuffer {
    return FfiConverterTypePendingSweepBalance.lower(value)
}



extension PendingSweepBalance: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum QrPaymentResult {
    
    case onchain(txid: Txid
    )
    case bolt11(paymentId: PaymentId
    )
    case bolt12(paymentId: PaymentId
    )
}


public struct FfiConverterTypeQrPaymentResult: FfiConverterRustBuffer {
    typealias SwiftType = QrPaymentResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrPaymentResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .onchain(txid: try FfiConverterTypeTxid.read(from: &buf)
        )
        
        case 2: return .bolt11(paymentId: try FfiConverterTypePaymentId.read(from: &buf)
        )
        
        case 3: return .bolt12(paymentId: try FfiConverterTypePaymentId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrPaymentResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .onchain(txid):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTxid.write(txid, into: &buf)
            
        
        case let .bolt11(paymentId):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            
        
        case let .bolt12(paymentId):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeQrPaymentResult_lift(_ buf: RustBuffer) throws -> QrPaymentResult {
    return try FfiConverterTypeQrPaymentResult.lift(buf)
}

public func FfiConverterTypeQrPaymentResult_lower(_ value: QrPaymentResult) -> RustBuffer {
    return FfiConverterTypeQrPaymentResult.lower(value)
}



extension QrPaymentResult: Equatable, Hashable {}




public enum VssHeaderProviderError {

    
    
    case InvalidData(message: String)
    
    case RequestError(message: String)
    
    case AuthorizationError(message: String)
    
    case InternalError(message: String)
    
}


public struct FfiConverterTypeVssHeaderProviderError: FfiConverterRustBuffer {
    typealias SwiftType = VssHeaderProviderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VssHeaderProviderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .RequestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .AuthorizationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InternalError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VssHeaderProviderError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidData(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .RequestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .AuthorizationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InternalError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


extension VssHeaderProviderError: Equatable, Hashable {}

extension VssHeaderProviderError: Error { }

fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeeRate: FfiConverterRustBuffer {
    typealias SwiftType = FeeRate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeRate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeRate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    typealias SwiftType = AnchorChannelsConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAnchorChannelsConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAnchorChannelsConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBackgroundSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = BackgroundSyncConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackgroundSyncConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackgroundSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBolt11PaymentInfo: FfiConverterRustBuffer {
    typealias SwiftType = Bolt11PaymentInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBolt11PaymentInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBolt11PaymentInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelConfig: FfiConverterRustBuffer {
    typealias SwiftType = ChannelConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelOrderInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelOrderInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelOrderInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelOrderInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelUpdateInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelUpdateInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelUpdateInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelUpdateInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeElectrumSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = ElectrumSyncConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeElectrumSyncConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeElectrumSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEsploraSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = EsploraSyncConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEsploraSyncConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEsploraSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeAnnouncementInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAnnouncementInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAnnouncementInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOnchainPaymentInfo: FfiConverterRustBuffer {
    typealias SwiftType = OnchainPaymentInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOnchainPaymentInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOnchainPaymentInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = OutPoint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutPoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutPoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSendingParameters: FfiConverterRustBuffer {
    typealias SwiftType = SendingParameters?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendingParameters.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendingParameters.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClosureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClosureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLogLevel.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLogLevel.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMaxTotalRoutingFeeLimit: FfiConverterRustBuffer {
    typealias SwiftType = MaxTotalRoutingFeeLimit?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMaxTotalRoutingFeeLimit.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMaxTotalRoutingFeeLimit.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentFailureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentFailureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSocketAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChannelId: FfiConverterRustBuffer {
    typealias SwiftType = ChannelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeAlias: FfiConverterRustBuffer {
    typealias SwiftType = NodeAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentHash: FfiConverterRustBuffer {
    typealias SwiftType = PaymentHash?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentHash.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentId: FfiConverterRustBuffer {
    typealias SwiftType = PaymentId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentPreimage: FfiConverterRustBuffer {
    typealias SwiftType = PaymentPreimage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentPreimage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentPreimage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePaymentSecret: FfiConverterRustBuffer {
    typealias SwiftType = PaymentSecret?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentSecret.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentSecret.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUntrustedString: FfiConverterRustBuffer {
    typealias SwiftType = UntrustedString?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUntrustedString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUntrustedString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUserChannelId: FfiConverterRustBuffer {
    typealias SwiftType = UserChannelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserChannelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChannelDetails: FfiConverterRustBuffer {
    typealias SwiftType = [ChannelDetails]

    public static func write(_ value: [ChannelDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChannelDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChannelDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChannelDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChannelDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCustomTlvRecord: FfiConverterRustBuffer {
    typealias SwiftType = [CustomTlvRecord]

    public static func write(_ value: [CustomTlvRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCustomTlvRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CustomTlvRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [CustomTlvRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCustomTlvRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetails]

    public static func write(_ value: [PaymentDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePeerDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PeerDetails]

    public static func write(_ value: [PeerDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeerDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PeerDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PeerDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePeerDetails.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHintHop]

    public static func write(_ value: [RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = [LightningBalance]

    public static func write(_ value: [LightningBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLightningBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LightningBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [LightningBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLightningBalance.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = [PendingSweepBalance]

    public static func write(_ value: [PendingSweepBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePendingSweepBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PendingSweepBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [PendingSweepBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePendingSweepBalance.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [[RouteHintHop]]

    public static func write(_ value: [[RouteHintHop]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeRouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[RouteHintHop]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[RouteHintHop]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeId: FfiConverterRustBuffer {
    typealias SwiftType = [NodeId]

    public static func write(_ value: [NodeId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]

    public static func write(_ value: [SocketAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSocketAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SocketAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [SocketAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSocketAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Address = String
public struct FfiConverterTypeAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Address {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Address) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeAddress_lift(_ value: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(value)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BlockHash = String
public struct FfiConverterTypeBlockHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BlockHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BlockHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BlockHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBlockHash_lift(_ value: RustBuffer) throws -> BlockHash {
    return try FfiConverterTypeBlockHash.lift(value)
}

public func FfiConverterTypeBlockHash_lower(_ value: BlockHash) -> RustBuffer {
    return FfiConverterTypeBlockHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bolt12Invoice = String
public struct FfiConverterTypeBolt12Invoice: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bolt12Invoice {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bolt12Invoice) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeBolt12Invoice_lift(_ value: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(value)
}

public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ChannelId = String
public struct FfiConverterTypeChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeChannelId_lift(_ value: RustBuffer) throws -> ChannelId {
    return try FfiConverterTypeChannelId.lift(value)
}

public func FfiConverterTypeChannelId_lower(_ value: ChannelId) -> RustBuffer {
    return FfiConverterTypeChannelId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = String
public struct FfiConverterTypeDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DateTime {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: DateTime) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeDateTime_lift(_ value: RustBuffer) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> RustBuffer {
    return FfiConverterTypeDateTime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Mnemonic = String
public struct FfiConverterTypeMnemonic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Mnemonic {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Mnemonic) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeMnemonic_lift(_ value: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(value)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeAlias = String
public struct FfiConverterTypeNodeAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNodeAlias_lift(_ value: RustBuffer) throws -> NodeAlias {
    return try FfiConverterTypeNodeAlias.lift(value)
}

public func FfiConverterTypeNodeAlias_lower(_ value: NodeAlias) -> RustBuffer {
    return FfiConverterTypeNodeAlias.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeId = String
public struct FfiConverterTypeNodeId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeNodeId_lift(_ value: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(value)
}

public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Offer = String
public struct FfiConverterTypeOffer: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Offer {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Offer, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Offer {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Offer) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeOffer_lift(_ value: RustBuffer) throws -> Offer {
    return try FfiConverterTypeOffer.lift(value)
}

public func FfiConverterTypeOffer_lower(_ value: Offer) -> RustBuffer {
    return FfiConverterTypeOffer.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OfferId = String
public struct FfiConverterTypeOfferId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OfferId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OfferId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OfferId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeOfferId_lift(_ value: RustBuffer) throws -> OfferId {
    return try FfiConverterTypeOfferId.lift(value)
}

public func FfiConverterTypeOfferId_lower(_ value: OfferId) -> RustBuffer {
    return FfiConverterTypeOfferId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OrderId = String
public struct FfiConverterTypeOrderId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OrderId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OrderId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OrderId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeOrderId_lift(_ value: RustBuffer) throws -> OrderId {
    return try FfiConverterTypeOrderId.lift(value)
}

public func FfiConverterTypeOrderId_lower(_ value: OrderId) -> RustBuffer {
    return FfiConverterTypeOrderId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentHash = String
public struct FfiConverterTypePaymentHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentHash_lift(_ value: RustBuffer) throws -> PaymentHash {
    return try FfiConverterTypePaymentHash.lift(value)
}

public func FfiConverterTypePaymentHash_lower(_ value: PaymentHash) -> RustBuffer {
    return FfiConverterTypePaymentHash.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentId = String
public struct FfiConverterTypePaymentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentId_lift(_ value: RustBuffer) throws -> PaymentId {
    return try FfiConverterTypePaymentId.lift(value)
}

public func FfiConverterTypePaymentId_lower(_ value: PaymentId) -> RustBuffer {
    return FfiConverterTypePaymentId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentPreimage = String
public struct FfiConverterTypePaymentPreimage: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentPreimage {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentPreimage, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentPreimage {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentPreimage) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentPreimage_lift(_ value: RustBuffer) throws -> PaymentPreimage {
    return try FfiConverterTypePaymentPreimage.lift(value)
}

public func FfiConverterTypePaymentPreimage_lower(_ value: PaymentPreimage) -> RustBuffer {
    return FfiConverterTypePaymentPreimage.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentSecret = String
public struct FfiConverterTypePaymentSecret: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentSecret {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentSecret, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentSecret {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentSecret) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePaymentSecret_lift(_ value: RustBuffer) throws -> PaymentSecret {
    return try FfiConverterTypePaymentSecret.lift(value)
}

public func FfiConverterTypePaymentSecret_lower(_ value: PaymentSecret) -> RustBuffer {
    return FfiConverterTypePaymentSecret.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PublicKey = String
public struct FfiConverterTypePublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PublicKey {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PublicKey) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePublicKey_lift(_ value: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(value)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Refund = String
public struct FfiConverterTypeRefund: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Refund {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Refund, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Refund {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Refund) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeRefund_lift(_ value: RustBuffer) throws -> Refund {
    return try FfiConverterTypeRefund.lift(value)
}

public func FfiConverterTypeRefund_lower(_ value: Refund) -> RustBuffer {
    return FfiConverterTypeRefund.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SocketAddress = String
public struct FfiConverterTypeSocketAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SocketAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: SocketAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SocketAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: SocketAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeSocketAddress_lift(_ value: RustBuffer) throws -> SocketAddress {
    return try FfiConverterTypeSocketAddress.lift(value)
}

public func FfiConverterTypeSocketAddress_lower(_ value: SocketAddress) -> RustBuffer {
    return FfiConverterTypeSocketAddress.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Txid = String
public struct FfiConverterTypeTxid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Txid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Txid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Txid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Txid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeTxid_lift(_ value: RustBuffer) throws -> Txid {
    return try FfiConverterTypeTxid.lift(value)
}

public func FfiConverterTypeTxid_lower(_ value: Txid) -> RustBuffer {
    return FfiConverterTypeTxid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UntrustedString = String
public struct FfiConverterTypeUntrustedString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UntrustedString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UntrustedString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UntrustedString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UntrustedString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUntrustedString_lift(_ value: RustBuffer) throws -> UntrustedString {
    return try FfiConverterTypeUntrustedString.lift(value)
}

public func FfiConverterTypeUntrustedString_lower(_ value: UntrustedString) -> RustBuffer {
    return FfiConverterTypeUntrustedString.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserChannelId = String
public struct FfiConverterTypeUserChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UserChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UserChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UserChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUserChannelId_lift(_ value: RustBuffer) throws -> UserChannelId {
    return try FfiConverterTypeUserChannelId.lift(value)
}

public func FfiConverterTypeUserChannelId_lower(_ value: UserChannelId) -> RustBuffer {
    return FfiConverterTypeUserChannelId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func defaultConfig() -> Config {
    return try!  FfiConverterTypeConfig.lift(try! rustCall() {
    uniffi_ldk_node_fn_func_default_config($0
    )
})
}
public func generateEntropyMnemonic() -> Mnemonic {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_ldk_node_fn_func_generate_entropy_mnemonic($0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ldk_node_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_ldk_node_checksum_func_default_config() != 55381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_func_generate_entropy_mnemonic() != 59926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_amount_milli_satoshis() != 50823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_currency() != 32179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_description() != 9887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_expiry_time_seconds() != 23625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_fallback_addresses() != 55276) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_is_expired() != 15932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_min_final_cltv_expiry_delta() != 8855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_network() != 10420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_payment_hash() != 42571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_payment_secret() != 26081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_recover_payee_pub_key() != 18874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_route_hints() != 63051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_seconds_since_epoch() != 53979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_seconds_until_expiry() != 64193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_signable_hash() != 30910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11invoice_would_expire() != 30331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash() != 52848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash() != 24516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive() != 6073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash() != 27050) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount() != 4893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash() != 1402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel() != 24506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel() != 16532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send() != 63952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_probes() != 969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount() != 50136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount() != 36530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund() != 38039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_receive() != 15049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount() != 7279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment() != 61945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_send() != 56449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount() != 26006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build() != 785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build_with_fs_store() != 61304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build_with_vss_store() != 2871) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_fixed_headers() != 24910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_header_provider() != 9090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_announcement_addresses() != 39271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rpc() != 2111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_chain_source_electrum() != 55552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora() != 1781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_custom_logger() != 51232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic() != 827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes() != 44799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path() != 64056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_filesystem_logger() != 10249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p() != 9279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs() != 64312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps1() != 51527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2() != 14430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_listening_addresses() != 14051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_log_facade_logger() != 58410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_network() != 27539) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_node_alias() != 18342) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_builder_set_storage_dir_path() != 59019) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_feerate_to_sat_per_kwu() != 58911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_ceil() != 58575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_floor() != 59617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_lsps1liquidity_check_order_status() != 64731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_lsps1liquidity_request_channel() != 18153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_logwriter_log() != 3299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_channel() != 38070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_list_channels() != 4693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_list_nodes() != 36715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_networkgraph_node() != 48925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_announcement_addresses() != 61426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_bolt11_payment() != 41402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_bolt12_payment() != 49254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_close_channel() != 62479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_config() != 7511) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_connect() != 34120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_disconnect() != 43538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_event_handled() != 38712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_export_pathfinding_scores() != 62331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_force_close_channel() != 48831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_balances() != 57528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_channels() != 7954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_payments() != 35002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_list_peers() != 14889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_listening_addresses() != 2665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_lsps1_liquidity() != 38201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_network_graph() != 2695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_next_event() != 7682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_next_event_async() != 25426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_node_alias() != 29526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_node_id() != 51489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_onchain_payment() != 6092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_open_announced_channel() != 36623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_open_channel() != 40283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_payment() != 60296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_remove_payment() != 47952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_sign_message() != 49319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_spontaneous_payment() != 37403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_start() != 58480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_status() != 55952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_stop() != 42188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_sync_wallets() != 32474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_unified_qr_payment() != 9837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_update_channel_config() != 37852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_verify_signature() != 20486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_node_wait_next_event() != 55101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_new_address() != 37251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address() != 37748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_onchainpayment_send_to_address() != 55646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_spontaneouspayment_send() != 48210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes() != 25937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_custom_tlvs() != 2376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_unifiedqrpayment_receive() != 913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_unifiedqrpayment_send() != 53900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_method_vssheaderprovider_get_headers() != 7788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_bolt11invoice_from_str() != 349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_builder_from_config() != 994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_builder_new() != 40499) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_kwu() != 50548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_vb_unchecked() != 41808) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLogWriter()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all