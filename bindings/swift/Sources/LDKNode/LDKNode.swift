// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation
import SystemConfiguration

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(LDKNodeFFI)
    import LDKNodeFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ldk_node_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ldk_node_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol Bolt11PaymentProtocol: AnyObject {
    func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws

    func failForHash(paymentHash: PaymentHash) throws

    func receive(amountMsat: UInt64, description: String, expirySecs: UInt32) throws -> Bolt11Invoice

    func receiveForHash(amountMsat: UInt64, description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func receiveVariableAmount(description: String, expirySecs: UInt32) throws -> Bolt11Invoice

    func receiveVariableAmountForHash(description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice

    func receiveVariableAmountViaJitChannel(description: String, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws -> Bolt11Invoice

    func receiveViaJitChannel(amountMsat: UInt64, description: String, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws -> Bolt11Invoice

    func send(invoice: Bolt11Invoice, sendingParameters: SendingParameters?) throws -> PaymentId

    func sendProbes(invoice: Bolt11Invoice) throws

    func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws

    func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, sendingParameters: SendingParameters?) throws -> PaymentId
}

public class Bolt11Payment:
    Bolt11PaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt11payment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_bolt11payment(pointer, $0) }
    }

    public func claimForHash(paymentHash: PaymentHash, claimableAmountMsat: UInt64, preimage: PaymentPreimage) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash(self.uniffiClonePointer(),
                                                                       FfiConverterTypePaymentHash.lower(paymentHash),
                                                                       FfiConverterUInt64.lower(claimableAmountMsat),
                                                                       FfiConverterTypePaymentPreimage.lower(preimage), $0)
            }
    }

    public func failForHash(paymentHash: PaymentHash) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash(self.uniffiClonePointer(),
                                                                      FfiConverterTypePaymentHash.lower(paymentHash), $0)
            }
    }

    public func receive(amountMsat: UInt64, description: String, expirySecs: UInt32) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive(self.uniffiClonePointer(),
                                                                FfiConverterUInt64.lower(amountMsat),
                                                                FfiConverterString.lower(description),
                                                                FfiConverterUInt32.lower(expirySecs), $0)
            }
        )
    }

    public func receiveForHash(amountMsat: UInt64, description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash(self.uniffiClonePointer(),
                                                                         FfiConverterUInt64.lower(amountMsat),
                                                                         FfiConverterString.lower(description),
                                                                         FfiConverterUInt32.lower(expirySecs),
                                                                         FfiConverterTypePaymentHash.lower(paymentHash), $0)
            }
        )
    }

    public func receiveVariableAmount(description: String, expirySecs: UInt32) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount(self.uniffiClonePointer(),
                                                                                FfiConverterString.lower(description),
                                                                                FfiConverterUInt32.lower(expirySecs), $0)
            }
        )
    }

    public func receiveVariableAmountForHash(description: String, expirySecs: UInt32, paymentHash: PaymentHash) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash(self.uniffiClonePointer(),
                                                                                         FfiConverterString.lower(description),
                                                                                         FfiConverterUInt32.lower(expirySecs),
                                                                                         FfiConverterTypePaymentHash.lower(paymentHash), $0)
            }
        )
    }

    public func receiveVariableAmountViaJitChannel(description: String, expirySecs: UInt32, maxProportionalLspFeeLimitPpmMsat: UInt64?) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel(self.uniffiClonePointer(),
                                                                                                FfiConverterString.lower(description),
                                                                                                FfiConverterUInt32.lower(expirySecs),
                                                                                                FfiConverterOptionUInt64.lower(maxProportionalLspFeeLimitPpmMsat), $0)
            }
        )
    }

    public func receiveViaJitChannel(amountMsat: UInt64, description: String, expirySecs: UInt32, maxLspFeeLimitMsat: UInt64?) throws -> Bolt11Invoice {
        return try FfiConverterTypeBolt11Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel(self.uniffiClonePointer(),
                                                                                FfiConverterUInt64.lower(amountMsat),
                                                                                FfiConverterString.lower(description),
                                                                                FfiConverterUInt32.lower(expirySecs),
                                                                                FfiConverterOptionUInt64.lower(maxLspFeeLimitMsat), $0)
            }
        )
    }

    public func send(invoice: Bolt11Invoice, sendingParameters: SendingParameters?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_send(self.uniffiClonePointer(),
                                                             FfiConverterTypeBolt11Invoice.lower(invoice),
                                                             FfiConverterOptionTypeSendingParameters.lower(sendingParameters), $0)
            }
        )
    }

    public func sendProbes(invoice: Bolt11Invoice) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_send_probes(self.uniffiClonePointer(),
                                                                    FfiConverterTypeBolt11Invoice.lower(invoice), $0)
            }
    }

    public func sendProbesUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount(self.uniffiClonePointer(),
                                                                                 FfiConverterTypeBolt11Invoice.lower(invoice),
                                                                                 FfiConverterUInt64.lower(amountMsat), $0)
            }
    }

    public func sendUsingAmount(invoice: Bolt11Invoice, amountMsat: UInt64, sendingParameters: SendingParameters?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt11payment_send_using_amount(self.uniffiClonePointer(),
                                                                          FfiConverterTypeBolt11Invoice.lower(invoice),
                                                                          FfiConverterUInt64.lower(amountMsat),
                                                                          FfiConverterOptionTypeSendingParameters.lower(sendingParameters), $0)
            }
        )
    }
}

public struct FfiConverterTypeBolt11Payment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt11Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
        return Bolt11Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt11Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBolt11Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt11Payment {
    return try FfiConverterTypeBolt11Payment.lift(pointer)
}

public func FfiConverterTypeBolt11Payment_lower(_ value: Bolt11Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt11Payment.lower(value)
}

public protocol Bolt12PaymentProtocol: AnyObject {
    func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?) throws -> Refund

    func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?) throws -> Offer

    func receiveVariableAmount(description: String, expirySecs: UInt32?) throws -> Offer

    func requestRefundPayment(refund: Refund) throws -> Bolt12Invoice

    func send(offer: Offer, quantity: UInt64?, payerNote: String?) throws -> PaymentId

    func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?) throws -> PaymentId
}

public class Bolt12Payment:
    Bolt12PaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_bolt12payment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_bolt12payment(pointer, $0) }
    }

    public func initiateRefund(amountMsat: UInt64, expirySecs: UInt32, quantity: UInt64?, payerNote: String?) throws -> Refund {
        return try FfiConverterTypeRefund.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_initiate_refund(self.uniffiClonePointer(),
                                                                        FfiConverterUInt64.lower(amountMsat),
                                                                        FfiConverterUInt32.lower(expirySecs),
                                                                        FfiConverterOptionUInt64.lower(quantity),
                                                                        FfiConverterOptionString.lower(payerNote), $0)
            }
        )
    }

    public func receive(amountMsat: UInt64, description: String, expirySecs: UInt32?, quantity: UInt64?) throws -> Offer {
        return try FfiConverterTypeOffer.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_receive(self.uniffiClonePointer(),
                                                                FfiConverterUInt64.lower(amountMsat),
                                                                FfiConverterString.lower(description),
                                                                FfiConverterOptionUInt32.lower(expirySecs),
                                                                FfiConverterOptionUInt64.lower(quantity), $0)
            }
        )
    }

    public func receiveVariableAmount(description: String, expirySecs: UInt32?) throws -> Offer {
        return try FfiConverterTypeOffer.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount(self.uniffiClonePointer(),
                                                                                FfiConverterString.lower(description),
                                                                                FfiConverterOptionUInt32.lower(expirySecs), $0)
            }
        )
    }

    public func requestRefundPayment(refund: Refund) throws -> Bolt12Invoice {
        return try FfiConverterTypeBolt12Invoice.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment(self.uniffiClonePointer(),
                                                                               FfiConverterTypeRefund.lower(refund), $0)
            }
        )
    }

    public func send(offer: Offer, quantity: UInt64?, payerNote: String?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_send(self.uniffiClonePointer(),
                                                             FfiConverterTypeOffer.lower(offer),
                                                             FfiConverterOptionUInt64.lower(quantity),
                                                             FfiConverterOptionString.lower(payerNote), $0)
            }
        )
    }

    public func sendUsingAmount(offer: Offer, amountMsat: UInt64, quantity: UInt64?, payerNote: String?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_bolt12payment_send_using_amount(self.uniffiClonePointer(),
                                                                          FfiConverterTypeOffer.lower(offer),
                                                                          FfiConverterUInt64.lower(amountMsat),
                                                                          FfiConverterOptionUInt64.lower(quantity),
                                                                          FfiConverterOptionString.lower(payerNote), $0)
            }
        )
    }
}

public struct FfiConverterTypeBolt12Payment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bolt12Payment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
        return Bolt12Payment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Payment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bolt12Payment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBolt12Payment_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bolt12Payment {
    return try FfiConverterTypeBolt12Payment.lift(pointer)
}

public func FfiConverterTypeBolt12Payment_lower(_ value: Bolt12Payment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBolt12Payment.lower(value)
}

public protocol BuilderProtocol: AnyObject {
    func build() throws -> Node

    func buildWithFsStore() throws -> Node

    func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?)

    func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?)

    func setEntropySeedBytes(seedBytes: [UInt8]) throws

    func setEntropySeedPath(seedPath: String)

    func setGossipSourceP2p()

    func setGossipSourceRgs(rgsServerUrl: String)

    func setLiquiditySourceLsps2(address: SocketAddress, nodeId: PublicKey, token: String?)

    func setListeningAddresses(listeningAddresses: [SocketAddress]) throws

    func setNetwork(network: Network)

    func setNodeAlias(nodeAlias: String) throws

    func setStorageDirPath(storageDirPath: String)
}

public class Builder:
    BuilderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_builder(self.pointer, $0) }
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_ldk_node_fn_constructor_builder_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_builder(pointer, $0) }
    }

    public static func fromConfig(config: Config) -> Builder {
        return Builder(unsafeFromRawPointer: try! rustCall {
            uniffi_ldk_node_fn_constructor_builder_from_config(
                FfiConverterTypeConfig.lower(config), $0
            )
        })
    }

    public func build() throws -> Node {
        return try FfiConverterTypeNode.lift(
            rustCallWithError(FfiConverterTypeBuildError.lift) {
                uniffi_ldk_node_fn_method_builder_build(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func buildWithFsStore() throws -> Node {
        return try FfiConverterTypeNode.lift(
            rustCallWithError(FfiConverterTypeBuildError.lift) {
                uniffi_ldk_node_fn_method_builder_build_with_fs_store(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func setChainSourceEsplora(serverUrl: String, config: EsploraSyncConfig?) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_chain_source_esplora(self.uniffiClonePointer(),
                                                                           FfiConverterString.lower(serverUrl),
                                                                           FfiConverterOptionTypeEsploraSyncConfig.lower(config), $0)
            }
    }

    public func setEntropyBip39Mnemonic(mnemonic: Mnemonic, passphrase: String?) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic(self.uniffiClonePointer(),
                                                                             FfiConverterTypeMnemonic.lower(mnemonic),
                                                                             FfiConverterOptionString.lower(passphrase), $0)
            }
    }

    public func setEntropySeedBytes(seedBytes: [UInt8]) throws {
        try
            rustCallWithError(FfiConverterTypeBuildError.lift) {
                uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes(self.uniffiClonePointer(),
                                                                         FfiConverterSequenceUInt8.lower(seedBytes), $0)
            }
    }

    public func setEntropySeedPath(seedPath: String) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_entropy_seed_path(self.uniffiClonePointer(),
                                                                        FfiConverterString.lower(seedPath), $0)
            }
    }

    public func setGossipSourceP2p() {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p(self.uniffiClonePointer(), $0)
            }
    }

    public func setGossipSourceRgs(rgsServerUrl: String) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs(self.uniffiClonePointer(),
                                                                        FfiConverterString.lower(rgsServerUrl), $0)
            }
    }

    public func setLiquiditySourceLsps2(address: SocketAddress, nodeId: PublicKey, token: String?) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2(self.uniffiClonePointer(),
                                                                             FfiConverterTypeSocketAddress.lower(address),
                                                                             FfiConverterTypePublicKey.lower(nodeId),
                                                                             FfiConverterOptionString.lower(token), $0)
            }
    }

    public func setListeningAddresses(listeningAddresses: [SocketAddress]) throws {
        try
            rustCallWithError(FfiConverterTypeBuildError.lift) {
                uniffi_ldk_node_fn_method_builder_set_listening_addresses(self.uniffiClonePointer(),
                                                                          FfiConverterSequenceTypeSocketAddress.lower(listeningAddresses), $0)
            }
    }

    public func setNetwork(network: Network) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_network(self.uniffiClonePointer(),
                                                              FfiConverterTypeNetwork.lower(network), $0)
            }
    }

    public func setNodeAlias(nodeAlias: String) throws {
        try
            rustCallWithError(FfiConverterTypeBuildError.lift) {
                uniffi_ldk_node_fn_method_builder_set_node_alias(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(nodeAlias), $0)
            }
    }

    public func setStorageDirPath(storageDirPath: String) {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_builder_set_storage_dir_path(self.uniffiClonePointer(),
                                                                       FfiConverterString.lower(storageDirPath), $0)
            }
    }
}

public struct FfiConverterTypeBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Builder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
        return Builder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Builder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Builder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Builder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Builder {
    return try FfiConverterTypeBuilder.lift(pointer)
}

public func FfiConverterTypeBuilder_lower(_ value: Builder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBuilder.lower(value)
}

public protocol NetworkGraphProtocol: AnyObject {
    func channel(shortChannelId: UInt64) -> ChannelInfo?

    func listChannels() -> [UInt64]

    func listNodes() -> [NodeId]

    func node(nodeId: NodeId) -> NodeInfo?
}

public class NetworkGraph:
    NetworkGraphProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_networkgraph(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_networkgraph(pointer, $0) }
    }

    public func channel(shortChannelId: UInt64) -> ChannelInfo? {
        return try! FfiConverterOptionTypeChannelInfo.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_networkgraph_channel(self.uniffiClonePointer(),
                                                                   FfiConverterUInt64.lower(shortChannelId), $0)
                }
        )
    }

    public func listChannels() -> [UInt64] {
        return try! FfiConverterSequenceUInt64.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_networkgraph_list_channels(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listNodes() -> [NodeId] {
        return try! FfiConverterSequenceTypeNodeId.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_networkgraph_list_nodes(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func node(nodeId: NodeId) -> NodeInfo? {
        return try! FfiConverterOptionTypeNodeInfo.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_networkgraph_node(self.uniffiClonePointer(),
                                                                FfiConverterTypeNodeId.lower(nodeId), $0)
                }
        )
    }
}

public struct FfiConverterTypeNetworkGraph: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkGraph

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
        return NetworkGraph(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkGraph {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkGraph, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNetworkGraph_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkGraph {
    return try FfiConverterTypeNetworkGraph.lift(pointer)
}

public func FfiConverterTypeNetworkGraph_lower(_ value: NetworkGraph) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkGraph.lower(value)
}

public protocol NodeProtocol: AnyObject {
    func bolt11Payment() -> Bolt11Payment

    func bolt12Payment() -> Bolt12Payment

    func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws

    func config() -> Config

    func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws

    func disconnect(nodeId: PublicKey) throws

    func eventHandled()

    func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?) throws

    func getBalanceTest() -> Double

    func listBalances() -> BalanceDetails

    func listChannels() -> [ChannelDetails]

    func listPayments() -> [PaymentDetails]

    func listPeers() -> [PeerDetails]

    func listeningAddresses() -> [SocketAddress]?

    func networkGraph() -> NetworkGraph

    func nextEvent() -> Event?

    func nextEventAsync() async -> Event

    func nodeAlias() -> NodeAlias?

    func nodeId() -> PublicKey

    func onchainPayment() -> OnchainPayment

    func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId

    func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId

    func payment(paymentId: PaymentId) -> PaymentDetails?

    func removePayment(paymentId: PaymentId) throws

    func signMessage(msg: [UInt8]) -> String

    func spontaneousPayment() -> SpontaneousPayment

    func start() throws

    func status() -> NodeStatus

    func stop() throws

    func syncWallets() throws

    func unifiedQrPayment() -> UnifiedQrPayment

    func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws

    func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey) -> Bool

    func waitNextEvent() -> Event
}

public class Node:
    NodeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_node(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_node(pointer, $0) }
    }

    public func bolt11Payment() -> Bolt11Payment {
        return try! FfiConverterTypeBolt11Payment.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_bolt11_payment(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func bolt12Payment() -> Bolt12Payment {
        return try! FfiConverterTypeBolt12Payment.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_bolt12_payment(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func closeChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_close_channel(self.uniffiClonePointer(),
                                                             FfiConverterTypeUserChannelId.lower(userChannelId),
                                                             FfiConverterTypePublicKey.lower(counterpartyNodeId), $0)
            }
    }

    public func config() -> Config {
        return try! FfiConverterTypeConfig.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_config(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func connect(nodeId: PublicKey, address: SocketAddress, persist: Bool) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_connect(self.uniffiClonePointer(),
                                                       FfiConverterTypePublicKey.lower(nodeId),
                                                       FfiConverterTypeSocketAddress.lower(address),
                                                       FfiConverterBool.lower(persist), $0)
            }
    }

    public func disconnect(nodeId: PublicKey) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_disconnect(self.uniffiClonePointer(),
                                                          FfiConverterTypePublicKey.lower(nodeId), $0)
            }
    }

    public func eventHandled() {
        try!
            rustCall {
                uniffi_ldk_node_fn_method_node_event_handled(self.uniffiClonePointer(), $0)
            }
    }

    public func forceCloseChannel(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, reason: String?) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_force_close_channel(self.uniffiClonePointer(),
                                                                   FfiConverterTypeUserChannelId.lower(userChannelId),
                                                                   FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                                   FfiConverterOptionString.lower(reason), $0)
            }
    }

    public func getBalanceTest() -> Double {
        return try! FfiConverterDouble.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_get_balance_test(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listBalances() -> BalanceDetails {
        return try! FfiConverterTypeBalanceDetails.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_list_balances(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listChannels() -> [ChannelDetails] {
        return try! FfiConverterSequenceTypeChannelDetails.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_list_channels(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listPayments() -> [PaymentDetails] {
        return try! FfiConverterSequenceTypePaymentDetails.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_list_payments(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listPeers() -> [PeerDetails] {
        return try! FfiConverterSequenceTypePeerDetails.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_list_peers(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func listeningAddresses() -> [SocketAddress]? {
        return try! FfiConverterOptionSequenceTypeSocketAddress.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_listening_addresses(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func networkGraph() -> NetworkGraph {
        return try! FfiConverterTypeNetworkGraph.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_network_graph(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func nextEvent() -> Event? {
        return try! FfiConverterOptionTypeEvent.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_next_event(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func nextEventAsync() async -> Event {
        return try! await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_ldk_node_fn_method_node_next_event_async(
                    self.uniffiClonePointer()
                )
            },
            pollFunc: ffi_ldk_node_rust_future_poll_rust_buffer,
            completeFunc: ffi_ldk_node_rust_future_complete_rust_buffer,
            freeFunc: ffi_ldk_node_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEvent.lift,
            errorHandler: nil
        )
    }

    public func nodeAlias() -> NodeAlias? {
        return try! FfiConverterOptionTypeNodeAlias.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_node_alias(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func nodeId() -> PublicKey {
        return try! FfiConverterTypePublicKey.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_node_id(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func onchainPayment() -> OnchainPayment {
        return try! FfiConverterTypeOnchainPayment.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_onchain_payment(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func openAnnouncedChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId {
        return try FfiConverterTypeUserChannelId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_open_announced_channel(self.uniffiClonePointer(),
                                                                      FfiConverterTypePublicKey.lower(nodeId),
                                                                      FfiConverterTypeSocketAddress.lower(address),
                                                                      FfiConverterUInt64.lower(channelAmountSats),
                                                                      FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
                                                                      FfiConverterOptionTypeChannelConfig.lower(channelConfig), $0)
            }
        )
    }

    public func openChannel(nodeId: PublicKey, address: SocketAddress, channelAmountSats: UInt64, pushToCounterpartyMsat: UInt64?, channelConfig: ChannelConfig?) throws -> UserChannelId {
        return try FfiConverterTypeUserChannelId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_open_channel(self.uniffiClonePointer(),
                                                            FfiConverterTypePublicKey.lower(nodeId),
                                                            FfiConverterTypeSocketAddress.lower(address),
                                                            FfiConverterUInt64.lower(channelAmountSats),
                                                            FfiConverterOptionUInt64.lower(pushToCounterpartyMsat),
                                                            FfiConverterOptionTypeChannelConfig.lower(channelConfig), $0)
            }
        )
    }

    public func payment(paymentId: PaymentId) -> PaymentDetails? {
        return try! FfiConverterOptionTypePaymentDetails.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_payment(self.uniffiClonePointer(),
                                                           FfiConverterTypePaymentId.lower(paymentId), $0)
                }
        )
    }

    public func removePayment(paymentId: PaymentId) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_remove_payment(self.uniffiClonePointer(),
                                                              FfiConverterTypePaymentId.lower(paymentId), $0)
            }
    }

    public func signMessage(msg: [UInt8]) -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_sign_message(self.uniffiClonePointer(),
                                                                FfiConverterSequenceUInt8.lower(msg), $0)
                }
        )
    }

    public func spontaneousPayment() -> SpontaneousPayment {
        return try! FfiConverterTypeSpontaneousPayment.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_spontaneous_payment(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func start() throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_start(self.uniffiClonePointer(), $0)
            }
    }

    public func status() -> NodeStatus {
        return try! FfiConverterTypeNodeStatus.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_status(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func stop() throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_stop(self.uniffiClonePointer(), $0)
            }
    }

    public func syncWallets() throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_sync_wallets(self.uniffiClonePointer(), $0)
            }
    }

    public func unifiedQrPayment() -> UnifiedQrPayment {
        return try! FfiConverterTypeUnifiedQrPayment.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_unified_qr_payment(self.uniffiClonePointer(), $0)
                }
        )
    }

    public func updateChannelConfig(userChannelId: UserChannelId, counterpartyNodeId: PublicKey, channelConfig: ChannelConfig) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_node_update_channel_config(self.uniffiClonePointer(),
                                                                     FfiConverterTypeUserChannelId.lower(userChannelId),
                                                                     FfiConverterTypePublicKey.lower(counterpartyNodeId),
                                                                     FfiConverterTypeChannelConfig.lower(channelConfig), $0)
            }
    }

    public func verifySignature(msg: [UInt8], sig: String, pkey: PublicKey) -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_verify_signature(self.uniffiClonePointer(),
                                                                    FfiConverterSequenceUInt8.lower(msg),
                                                                    FfiConverterString.lower(sig),
                                                                    FfiConverterTypePublicKey.lower(pkey), $0)
                }
        )
    }

    public func waitNextEvent() -> Event {
        return try! FfiConverterTypeEvent.lift(
            try!
                rustCall {
                    uniffi_ldk_node_fn_method_node_wait_next_event(self.uniffiClonePointer(), $0)
                }
        )
    }
}

public struct FfiConverterTypeNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Node

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
        return Node(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Node) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
    return try FfiConverterTypeNode.lift(pointer)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNode.lower(value)
}

public protocol OnchainPaymentProtocol: AnyObject {
    func newAddress() throws -> Address

    func sendAllToAddress(address: Address) throws -> Txid

    func sendToAddress(address: Address, amountSats: UInt64) throws -> Txid
}

public class OnchainPayment:
    OnchainPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_onchainpayment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_onchainpayment(pointer, $0) }
    }

    public func newAddress() throws -> Address {
        return try FfiConverterTypeAddress.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_onchainpayment_new_address(self.uniffiClonePointer(), $0)
            }
        )
    }

    public func sendAllToAddress(address: Address) throws -> Txid {
        return try FfiConverterTypeTxid.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address(self.uniffiClonePointer(),
                                                                             FfiConverterTypeAddress.lower(address), $0)
            }
        )
    }

    public func sendToAddress(address: Address, amountSats: UInt64) throws -> Txid {
        return try FfiConverterTypeTxid.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_onchainpayment_send_to_address(self.uniffiClonePointer(),
                                                                         FfiConverterTypeAddress.lower(address),
                                                                         FfiConverterUInt64.lower(amountSats), $0)
            }
        )
    }
}

public struct FfiConverterTypeOnchainPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OnchainPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
        return OnchainPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OnchainPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeOnchainPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> OnchainPayment {
    return try FfiConverterTypeOnchainPayment.lift(pointer)
}

public func FfiConverterTypeOnchainPayment_lower(_ value: OnchainPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnchainPayment.lower(value)
}

public protocol SpontaneousPaymentProtocol: AnyObject {
    func send(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?) throws -> PaymentId

    func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws
}

public class SpontaneousPayment:
    SpontaneousPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_spontaneouspayment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_spontaneouspayment(pointer, $0) }
    }

    public func send(amountMsat: UInt64, nodeId: PublicKey, sendingParameters: SendingParameters?) throws -> PaymentId {
        return try FfiConverterTypePaymentId.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_spontaneouspayment_send(self.uniffiClonePointer(),
                                                                  FfiConverterUInt64.lower(amountMsat),
                                                                  FfiConverterTypePublicKey.lower(nodeId),
                                                                  FfiConverterOptionTypeSendingParameters.lower(sendingParameters), $0)
            }
        )
    }

    public func sendProbes(amountMsat: UInt64, nodeId: PublicKey) throws {
        try
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_spontaneouspayment_send_probes(self.uniffiClonePointer(),
                                                                         FfiConverterUInt64.lower(amountMsat),
                                                                         FfiConverterTypePublicKey.lower(nodeId), $0)
            }
    }
}

public struct FfiConverterTypeSpontaneousPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpontaneousPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
        return SpontaneousPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpontaneousPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpontaneousPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSpontaneousPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpontaneousPayment {
    return try FfiConverterTypeSpontaneousPayment.lift(pointer)
}

public func FfiConverterTypeSpontaneousPayment_lower(_ value: SpontaneousPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpontaneousPayment.lower(value)
}

public protocol UnifiedQrPaymentProtocol: AnyObject {
    func receive(amountSats: UInt64, message: String, expirySec: UInt32) throws -> String

    func send(uriStr: String) throws -> QrPaymentResult
}

public class UnifiedQrPayment:
    UnifiedQrPaymentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ldk_node_fn_clone_unifiedqrpayment(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_ldk_node_fn_free_unifiedqrpayment(pointer, $0) }
    }

    public func receive(amountSats: UInt64, message: String, expirySec: UInt32) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_unifiedqrpayment_receive(self.uniffiClonePointer(),
                                                                   FfiConverterUInt64.lower(amountSats),
                                                                   FfiConverterString.lower(message),
                                                                   FfiConverterUInt32.lower(expirySec), $0)
            }
        )
    }

    public func send(uriStr: String) throws -> QrPaymentResult {
        return try FfiConverterTypeQrPaymentResult.lift(
            rustCallWithError(FfiConverterTypeNodeError.lift) {
                uniffi_ldk_node_fn_method_unifiedqrpayment_send(self.uniffiClonePointer(),
                                                                FfiConverterString.lower(uriStr), $0)
            }
        )
    }
}

public struct FfiConverterTypeUnifiedQrPayment: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnifiedQrPayment

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
        return UnifiedQrPayment(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnifiedQrPayment {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnifiedQrPayment, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeUnifiedQrPayment_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnifiedQrPayment {
    return try FfiConverterTypeUnifiedQrPayment.lift(pointer)
}

public func FfiConverterTypeUnifiedQrPayment_lower(_ value: UnifiedQrPayment) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnifiedQrPayment.lower(value)
}

public struct AnchorChannelsConfig {
    public var trustedPeersNoReserve: [PublicKey]
    public var perChannelReserveSats: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        trustedPeersNoReserve: [PublicKey],
        perChannelReserveSats: UInt64
    ) {
        self.trustedPeersNoReserve = trustedPeersNoReserve
        self.perChannelReserveSats = perChannelReserveSats
    }
}

extension AnchorChannelsConfig: Equatable, Hashable {
    public static func == (lhs: AnchorChannelsConfig, rhs: AnchorChannelsConfig) -> Bool {
        if lhs.trustedPeersNoReserve != rhs.trustedPeersNoReserve {
            return false
        }
        if lhs.perChannelReserveSats != rhs.perChannelReserveSats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(trustedPeersNoReserve)
        hasher.combine(perChannelReserveSats)
    }
}

public struct FfiConverterTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AnchorChannelsConfig {
        return
            try AnchorChannelsConfig(
                trustedPeersNoReserve: FfiConverterSequenceTypePublicKey.read(from: &buf),
                perChannelReserveSats: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: AnchorChannelsConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePublicKey.write(value.trustedPeersNoReserve, into: &buf)
        FfiConverterUInt64.write(value.perChannelReserveSats, into: &buf)
    }
}

public func FfiConverterTypeAnchorChannelsConfig_lift(_ buf: RustBuffer) throws -> AnchorChannelsConfig {
    return try FfiConverterTypeAnchorChannelsConfig.lift(buf)
}

public func FfiConverterTypeAnchorChannelsConfig_lower(_ value: AnchorChannelsConfig) -> RustBuffer {
    return FfiConverterTypeAnchorChannelsConfig.lower(value)
}

public struct BalanceDetails {
    public var totalOnchainBalanceSats: UInt64
    public var spendableOnchainBalanceSats: UInt64
    public var totalAnchorChannelsReserveSats: UInt64
    public var totalLightningBalanceSats: UInt64
    public var lightningBalances: [LightningBalance]
    public var pendingBalancesFromChannelClosures: [PendingSweepBalance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        totalOnchainBalanceSats: UInt64,
        spendableOnchainBalanceSats: UInt64,
        totalAnchorChannelsReserveSats: UInt64,
        totalLightningBalanceSats: UInt64,
        lightningBalances: [LightningBalance],
        pendingBalancesFromChannelClosures: [PendingSweepBalance]
    ) {
        self.totalOnchainBalanceSats = totalOnchainBalanceSats
        self.spendableOnchainBalanceSats = spendableOnchainBalanceSats
        self.totalAnchorChannelsReserveSats = totalAnchorChannelsReserveSats
        self.totalLightningBalanceSats = totalLightningBalanceSats
        self.lightningBalances = lightningBalances
        self.pendingBalancesFromChannelClosures = pendingBalancesFromChannelClosures
    }
}

extension BalanceDetails: Equatable, Hashable {
    public static func == (lhs: BalanceDetails, rhs: BalanceDetails) -> Bool {
        if lhs.totalOnchainBalanceSats != rhs.totalOnchainBalanceSats {
            return false
        }
        if lhs.spendableOnchainBalanceSats != rhs.spendableOnchainBalanceSats {
            return false
        }
        if lhs.totalAnchorChannelsReserveSats != rhs.totalAnchorChannelsReserveSats {
            return false
        }
        if lhs.totalLightningBalanceSats != rhs.totalLightningBalanceSats {
            return false
        }
        if lhs.lightningBalances != rhs.lightningBalances {
            return false
        }
        if lhs.pendingBalancesFromChannelClosures != rhs.pendingBalancesFromChannelClosures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalOnchainBalanceSats)
        hasher.combine(spendableOnchainBalanceSats)
        hasher.combine(totalAnchorChannelsReserveSats)
        hasher.combine(totalLightningBalanceSats)
        hasher.combine(lightningBalances)
        hasher.combine(pendingBalancesFromChannelClosures)
    }
}

public struct FfiConverterTypeBalanceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceDetails {
        return
            try BalanceDetails(
                totalOnchainBalanceSats: FfiConverterUInt64.read(from: &buf),
                spendableOnchainBalanceSats: FfiConverterUInt64.read(from: &buf),
                totalAnchorChannelsReserveSats: FfiConverterUInt64.read(from: &buf),
                totalLightningBalanceSats: FfiConverterUInt64.read(from: &buf),
                lightningBalances: FfiConverterSequenceTypeLightningBalance.read(from: &buf),
                pendingBalancesFromChannelClosures: FfiConverterSequenceTypePendingSweepBalance.read(from: &buf)
            )
    }

    public static func write(_ value: BalanceDetails, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.totalOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.spendableOnchainBalanceSats, into: &buf)
        FfiConverterUInt64.write(value.totalAnchorChannelsReserveSats, into: &buf)
        FfiConverterUInt64.write(value.totalLightningBalanceSats, into: &buf)
        FfiConverterSequenceTypeLightningBalance.write(value.lightningBalances, into: &buf)
        FfiConverterSequenceTypePendingSweepBalance.write(value.pendingBalancesFromChannelClosures, into: &buf)
    }
}

public func FfiConverterTypeBalanceDetails_lift(_ buf: RustBuffer) throws -> BalanceDetails {
    return try FfiConverterTypeBalanceDetails.lift(buf)
}

public func FfiConverterTypeBalanceDetails_lower(_ value: BalanceDetails) -> RustBuffer {
    return FfiConverterTypeBalanceDetails.lower(value)
}

public struct BestBlock {
    public var blockHash: BlockHash
    public var height: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        blockHash: BlockHash,
        height: UInt32
    ) {
        self.blockHash = blockHash
        self.height = height
    }
}

extension BestBlock: Equatable, Hashable {
    public static func == (lhs: BestBlock, rhs: BestBlock) -> Bool {
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(blockHash)
        hasher.combine(height)
    }
}

public struct FfiConverterTypeBestBlock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BestBlock {
        return
            try BestBlock(
                blockHash: FfiConverterTypeBlockHash.read(from: &buf),
                height: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: BestBlock, into buf: inout [UInt8]) {
        FfiConverterTypeBlockHash.write(value.blockHash, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
    }
}

public func FfiConverterTypeBestBlock_lift(_ buf: RustBuffer) throws -> BestBlock {
    return try FfiConverterTypeBestBlock.lift(buf)
}

public func FfiConverterTypeBestBlock_lower(_ value: BestBlock) -> RustBuffer {
    return FfiConverterTypeBestBlock.lower(value)
}

public struct ChannelConfig {
    public var forwardingFeeProportionalMillionths: UInt32
    public var forwardingFeeBaseMsat: UInt32
    public var cltvExpiryDelta: UInt16
    public var maxDustHtlcExposure: MaxDustHtlcExposure
    public var forceCloseAvoidanceMaxFeeSatoshis: UInt64
    public var acceptUnderpayingHtlcs: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        forwardingFeeProportionalMillionths: UInt32,
        forwardingFeeBaseMsat: UInt32,
        cltvExpiryDelta: UInt16,
        maxDustHtlcExposure: MaxDustHtlcExposure,
        forceCloseAvoidanceMaxFeeSatoshis: UInt64,
        acceptUnderpayingHtlcs: Bool
    ) {
        self.forwardingFeeProportionalMillionths = forwardingFeeProportionalMillionths
        self.forwardingFeeBaseMsat = forwardingFeeBaseMsat
        self.cltvExpiryDelta = cltvExpiryDelta
        self.maxDustHtlcExposure = maxDustHtlcExposure
        self.forceCloseAvoidanceMaxFeeSatoshis = forceCloseAvoidanceMaxFeeSatoshis
        self.acceptUnderpayingHtlcs = acceptUnderpayingHtlcs
    }
}

extension ChannelConfig: Equatable, Hashable {
    public static func == (lhs: ChannelConfig, rhs: ChannelConfig) -> Bool {
        if lhs.forwardingFeeProportionalMillionths != rhs.forwardingFeeProportionalMillionths {
            return false
        }
        if lhs.forwardingFeeBaseMsat != rhs.forwardingFeeBaseMsat {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.maxDustHtlcExposure != rhs.maxDustHtlcExposure {
            return false
        }
        if lhs.forceCloseAvoidanceMaxFeeSatoshis != rhs.forceCloseAvoidanceMaxFeeSatoshis {
            return false
        }
        if lhs.acceptUnderpayingHtlcs != rhs.acceptUnderpayingHtlcs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(forwardingFeeProportionalMillionths)
        hasher.combine(forwardingFeeBaseMsat)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(maxDustHtlcExposure)
        hasher.combine(forceCloseAvoidanceMaxFeeSatoshis)
        hasher.combine(acceptUnderpayingHtlcs)
    }
}

public struct FfiConverterTypeChannelConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelConfig {
        return
            try ChannelConfig(
                forwardingFeeProportionalMillionths: FfiConverterUInt32.read(from: &buf),
                forwardingFeeBaseMsat: FfiConverterUInt32.read(from: &buf),
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf),
                maxDustHtlcExposure: FfiConverterTypeMaxDustHTLCExposure.read(from: &buf),
                forceCloseAvoidanceMaxFeeSatoshis: FfiConverterUInt64.read(from: &buf),
                acceptUnderpayingHtlcs: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelConfig, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.forwardingFeeProportionalMillionths, into: &buf)
        FfiConverterUInt32.write(value.forwardingFeeBaseMsat, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterTypeMaxDustHTLCExposure.write(value.maxDustHtlcExposure, into: &buf)
        FfiConverterUInt64.write(value.forceCloseAvoidanceMaxFeeSatoshis, into: &buf)
        FfiConverterBool.write(value.acceptUnderpayingHtlcs, into: &buf)
    }
}

public func FfiConverterTypeChannelConfig_lift(_ buf: RustBuffer) throws -> ChannelConfig {
    return try FfiConverterTypeChannelConfig.lift(buf)
}

public func FfiConverterTypeChannelConfig_lower(_ value: ChannelConfig) -> RustBuffer {
    return FfiConverterTypeChannelConfig.lower(value)
}

public struct ChannelDetails {
    public var channelId: ChannelId
    public var counterpartyNodeId: PublicKey
    public var fundingTxo: OutPoint?
    public var channelValueSats: UInt64
    public var unspendablePunishmentReserve: UInt64?
    public var userChannelId: UserChannelId
    public var feerateSatPer1000Weight: UInt32
    public var outboundCapacityMsat: UInt64
    public var inboundCapacityMsat: UInt64
    public var confirmationsRequired: UInt32?
    public var confirmations: UInt32?
    public var isOutbound: Bool
    public var isChannelReady: Bool
    public var isUsable: Bool
    public var isAnnounced: Bool
    public var cltvExpiryDelta: UInt16?
    public var counterpartyUnspendablePunishmentReserve: UInt64
    public var counterpartyOutboundHtlcMinimumMsat: UInt64?
    public var counterpartyOutboundHtlcMaximumMsat: UInt64?
    public var counterpartyForwardingInfoFeeBaseMsat: UInt32?
    public var counterpartyForwardingInfoFeeProportionalMillionths: UInt32?
    public var counterpartyForwardingInfoCltvExpiryDelta: UInt16?
    public var nextOutboundHtlcLimitMsat: UInt64
    public var nextOutboundHtlcMinimumMsat: UInt64
    public var forceCloseSpendDelay: UInt16?
    public var inboundHtlcMinimumMsat: UInt64
    public var inboundHtlcMaximumMsat: UInt64?
    public var config: ChannelConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        fundingTxo: OutPoint?,
        channelValueSats: UInt64,
        unspendablePunishmentReserve: UInt64?,
        userChannelId: UserChannelId,
        feerateSatPer1000Weight: UInt32,
        outboundCapacityMsat: UInt64,
        inboundCapacityMsat: UInt64,
        confirmationsRequired: UInt32?,
        confirmations: UInt32?,
        isOutbound: Bool,
        isChannelReady: Bool,
        isUsable: Bool,
        isAnnounced: Bool,
        cltvExpiryDelta: UInt16?,
        counterpartyUnspendablePunishmentReserve: UInt64,
        counterpartyOutboundHtlcMinimumMsat: UInt64?,
        counterpartyOutboundHtlcMaximumMsat: UInt64?,
        counterpartyForwardingInfoFeeBaseMsat: UInt32?,
        counterpartyForwardingInfoFeeProportionalMillionths: UInt32?,
        counterpartyForwardingInfoCltvExpiryDelta: UInt16?,
        nextOutboundHtlcLimitMsat: UInt64,
        nextOutboundHtlcMinimumMsat: UInt64,
        forceCloseSpendDelay: UInt16?,
        inboundHtlcMinimumMsat: UInt64,
        inboundHtlcMaximumMsat: UInt64?,
        config: ChannelConfig
    ) {
        self.channelId = channelId
        self.counterpartyNodeId = counterpartyNodeId
        self.fundingTxo = fundingTxo
        self.channelValueSats = channelValueSats
        self.unspendablePunishmentReserve = unspendablePunishmentReserve
        self.userChannelId = userChannelId
        self.feerateSatPer1000Weight = feerateSatPer1000Weight
        self.outboundCapacityMsat = outboundCapacityMsat
        self.inboundCapacityMsat = inboundCapacityMsat
        self.confirmationsRequired = confirmationsRequired
        self.confirmations = confirmations
        self.isOutbound = isOutbound
        self.isChannelReady = isChannelReady
        self.isUsable = isUsable
        self.isAnnounced = isAnnounced
        self.cltvExpiryDelta = cltvExpiryDelta
        self.counterpartyUnspendablePunishmentReserve = counterpartyUnspendablePunishmentReserve
        self.counterpartyOutboundHtlcMinimumMsat = counterpartyOutboundHtlcMinimumMsat
        self.counterpartyOutboundHtlcMaximumMsat = counterpartyOutboundHtlcMaximumMsat
        self.counterpartyForwardingInfoFeeBaseMsat = counterpartyForwardingInfoFeeBaseMsat
        self.counterpartyForwardingInfoFeeProportionalMillionths = counterpartyForwardingInfoFeeProportionalMillionths
        self.counterpartyForwardingInfoCltvExpiryDelta = counterpartyForwardingInfoCltvExpiryDelta
        self.nextOutboundHtlcLimitMsat = nextOutboundHtlcLimitMsat
        self.nextOutboundHtlcMinimumMsat = nextOutboundHtlcMinimumMsat
        self.forceCloseSpendDelay = forceCloseSpendDelay
        self.inboundHtlcMinimumMsat = inboundHtlcMinimumMsat
        self.inboundHtlcMaximumMsat = inboundHtlcMaximumMsat
        self.config = config
    }
}

extension ChannelDetails: Equatable, Hashable {
    public static func == (lhs: ChannelDetails, rhs: ChannelDetails) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.counterpartyNodeId != rhs.counterpartyNodeId {
            return false
        }
        if lhs.fundingTxo != rhs.fundingTxo {
            return false
        }
        if lhs.channelValueSats != rhs.channelValueSats {
            return false
        }
        if lhs.unspendablePunishmentReserve != rhs.unspendablePunishmentReserve {
            return false
        }
        if lhs.userChannelId != rhs.userChannelId {
            return false
        }
        if lhs.feerateSatPer1000Weight != rhs.feerateSatPer1000Weight {
            return false
        }
        if lhs.outboundCapacityMsat != rhs.outboundCapacityMsat {
            return false
        }
        if lhs.inboundCapacityMsat != rhs.inboundCapacityMsat {
            return false
        }
        if lhs.confirmationsRequired != rhs.confirmationsRequired {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.isOutbound != rhs.isOutbound {
            return false
        }
        if lhs.isChannelReady != rhs.isChannelReady {
            return false
        }
        if lhs.isUsable != rhs.isUsable {
            return false
        }
        if lhs.isAnnounced != rhs.isAnnounced {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.counterpartyUnspendablePunishmentReserve != rhs.counterpartyUnspendablePunishmentReserve {
            return false
        }
        if lhs.counterpartyOutboundHtlcMinimumMsat != rhs.counterpartyOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.counterpartyOutboundHtlcMaximumMsat != rhs.counterpartyOutboundHtlcMaximumMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeBaseMsat != rhs.counterpartyForwardingInfoFeeBaseMsat {
            return false
        }
        if lhs.counterpartyForwardingInfoFeeProportionalMillionths != rhs.counterpartyForwardingInfoFeeProportionalMillionths {
            return false
        }
        if lhs.counterpartyForwardingInfoCltvExpiryDelta != rhs.counterpartyForwardingInfoCltvExpiryDelta {
            return false
        }
        if lhs.nextOutboundHtlcLimitMsat != rhs.nextOutboundHtlcLimitMsat {
            return false
        }
        if lhs.nextOutboundHtlcMinimumMsat != rhs.nextOutboundHtlcMinimumMsat {
            return false
        }
        if lhs.forceCloseSpendDelay != rhs.forceCloseSpendDelay {
            return false
        }
        if lhs.inboundHtlcMinimumMsat != rhs.inboundHtlcMinimumMsat {
            return false
        }
        if lhs.inboundHtlcMaximumMsat != rhs.inboundHtlcMaximumMsat {
            return false
        }
        if lhs.config != rhs.config {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(counterpartyNodeId)
        hasher.combine(fundingTxo)
        hasher.combine(channelValueSats)
        hasher.combine(unspendablePunishmentReserve)
        hasher.combine(userChannelId)
        hasher.combine(feerateSatPer1000Weight)
        hasher.combine(outboundCapacityMsat)
        hasher.combine(inboundCapacityMsat)
        hasher.combine(confirmationsRequired)
        hasher.combine(confirmations)
        hasher.combine(isOutbound)
        hasher.combine(isChannelReady)
        hasher.combine(isUsable)
        hasher.combine(isAnnounced)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(counterpartyUnspendablePunishmentReserve)
        hasher.combine(counterpartyOutboundHtlcMinimumMsat)
        hasher.combine(counterpartyOutboundHtlcMaximumMsat)
        hasher.combine(counterpartyForwardingInfoFeeBaseMsat)
        hasher.combine(counterpartyForwardingInfoFeeProportionalMillionths)
        hasher.combine(counterpartyForwardingInfoCltvExpiryDelta)
        hasher.combine(nextOutboundHtlcLimitMsat)
        hasher.combine(nextOutboundHtlcMinimumMsat)
        hasher.combine(forceCloseSpendDelay)
        hasher.combine(inboundHtlcMinimumMsat)
        hasher.combine(inboundHtlcMaximumMsat)
        hasher.combine(config)
    }
}

public struct FfiConverterTypeChannelDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelDetails {
        return
            try ChannelDetails(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                fundingTxo: FfiConverterOptionTypeOutPoint.read(from: &buf),
                channelValueSats: FfiConverterUInt64.read(from: &buf),
                unspendablePunishmentReserve: FfiConverterOptionUInt64.read(from: &buf),
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf),
                feerateSatPer1000Weight: FfiConverterUInt32.read(from: &buf),
                outboundCapacityMsat: FfiConverterUInt64.read(from: &buf),
                inboundCapacityMsat: FfiConverterUInt64.read(from: &buf),
                confirmationsRequired: FfiConverterOptionUInt32.read(from: &buf),
                confirmations: FfiConverterOptionUInt32.read(from: &buf),
                isOutbound: FfiConverterBool.read(from: &buf),
                isChannelReady: FfiConverterBool.read(from: &buf),
                isUsable: FfiConverterBool.read(from: &buf),
                isAnnounced: FfiConverterBool.read(from: &buf),
                cltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf),
                counterpartyUnspendablePunishmentReserve: FfiConverterUInt64.read(from: &buf),
                counterpartyOutboundHtlcMinimumMsat: FfiConverterOptionUInt64.read(from: &buf),
                counterpartyOutboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf),
                counterpartyForwardingInfoFeeBaseMsat: FfiConverterOptionUInt32.read(from: &buf),
                counterpartyForwardingInfoFeeProportionalMillionths: FfiConverterOptionUInt32.read(from: &buf),
                counterpartyForwardingInfoCltvExpiryDelta: FfiConverterOptionUInt16.read(from: &buf),
                nextOutboundHtlcLimitMsat: FfiConverterUInt64.read(from: &buf),
                nextOutboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                forceCloseSpendDelay: FfiConverterOptionUInt16.read(from: &buf),
                inboundHtlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                inboundHtlcMaximumMsat: FfiConverterOptionUInt64.read(from: &buf),
                config: FfiConverterTypeChannelConfig.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelDetails, into buf: inout [UInt8]) {
        FfiConverterTypeChannelId.write(value.channelId, into: &buf)
        FfiConverterTypePublicKey.write(value.counterpartyNodeId, into: &buf)
        FfiConverterOptionTypeOutPoint.write(value.fundingTxo, into: &buf)
        FfiConverterUInt64.write(value.channelValueSats, into: &buf)
        FfiConverterOptionUInt64.write(value.unspendablePunishmentReserve, into: &buf)
        FfiConverterTypeUserChannelId.write(value.userChannelId, into: &buf)
        FfiConverterUInt32.write(value.feerateSatPer1000Weight, into: &buf)
        FfiConverterUInt64.write(value.outboundCapacityMsat, into: &buf)
        FfiConverterUInt64.write(value.inboundCapacityMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmationsRequired, into: &buf)
        FfiConverterOptionUInt32.write(value.confirmations, into: &buf)
        FfiConverterBool.write(value.isOutbound, into: &buf)
        FfiConverterBool.write(value.isChannelReady, into: &buf)
        FfiConverterBool.write(value.isUsable, into: &buf)
        FfiConverterBool.write(value.isAnnounced, into: &buf)
        FfiConverterOptionUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.counterpartyUnspendablePunishmentReserve, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.counterpartyOutboundHtlcMaximumMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeBaseMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.counterpartyForwardingInfoFeeProportionalMillionths, into: &buf)
        FfiConverterOptionUInt16.write(value.counterpartyForwardingInfoCltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcLimitMsat, into: &buf)
        FfiConverterUInt64.write(value.nextOutboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt16.write(value.forceCloseSpendDelay, into: &buf)
        FfiConverterUInt64.write(value.inboundHtlcMinimumMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.inboundHtlcMaximumMsat, into: &buf)
        FfiConverterTypeChannelConfig.write(value.config, into: &buf)
    }
}

public func FfiConverterTypeChannelDetails_lift(_ buf: RustBuffer) throws -> ChannelDetails {
    return try FfiConverterTypeChannelDetails.lift(buf)
}

public func FfiConverterTypeChannelDetails_lower(_ value: ChannelDetails) -> RustBuffer {
    return FfiConverterTypeChannelDetails.lower(value)
}

public struct ChannelInfo {
    public var nodeOne: NodeId
    public var oneToTwo: ChannelUpdateInfo?
    public var nodeTwo: NodeId
    public var twoToOne: ChannelUpdateInfo?
    public var capacitySats: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        nodeOne: NodeId,
        oneToTwo: ChannelUpdateInfo?,
        nodeTwo: NodeId,
        twoToOne: ChannelUpdateInfo?,
        capacitySats: UInt64?
    ) {
        self.nodeOne = nodeOne
        self.oneToTwo = oneToTwo
        self.nodeTwo = nodeTwo
        self.twoToOne = twoToOne
        self.capacitySats = capacitySats
    }
}

extension ChannelInfo: Equatable, Hashable {
    public static func == (lhs: ChannelInfo, rhs: ChannelInfo) -> Bool {
        if lhs.nodeOne != rhs.nodeOne {
            return false
        }
        if lhs.oneToTwo != rhs.oneToTwo {
            return false
        }
        if lhs.nodeTwo != rhs.nodeTwo {
            return false
        }
        if lhs.twoToOne != rhs.twoToOne {
            return false
        }
        if lhs.capacitySats != rhs.capacitySats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeOne)
        hasher.combine(oneToTwo)
        hasher.combine(nodeTwo)
        hasher.combine(twoToOne)
        hasher.combine(capacitySats)
    }
}

public struct FfiConverterTypeChannelInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelInfo {
        return
            try ChannelInfo(
                nodeOne: FfiConverterTypeNodeId.read(from: &buf),
                oneToTwo: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf),
                nodeTwo: FfiConverterTypeNodeId.read(from: &buf),
                twoToOne: FfiConverterOptionTypeChannelUpdateInfo.read(from: &buf),
                capacitySats: FfiConverterOptionUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelInfo, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.nodeOne, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.oneToTwo, into: &buf)
        FfiConverterTypeNodeId.write(value.nodeTwo, into: &buf)
        FfiConverterOptionTypeChannelUpdateInfo.write(value.twoToOne, into: &buf)
        FfiConverterOptionUInt64.write(value.capacitySats, into: &buf)
    }
}

public func FfiConverterTypeChannelInfo_lift(_ buf: RustBuffer) throws -> ChannelInfo {
    return try FfiConverterTypeChannelInfo.lift(buf)
}

public func FfiConverterTypeChannelInfo_lower(_ value: ChannelInfo) -> RustBuffer {
    return FfiConverterTypeChannelInfo.lower(value)
}

public struct ChannelUpdateInfo {
    public var lastUpdate: UInt32
    public var enabled: Bool
    public var cltvExpiryDelta: UInt16
    public var htlcMinimumMsat: UInt64
    public var htlcMaximumMsat: UInt64
    public var fees: RoutingFees

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUpdate: UInt32,
        enabled: Bool,
        cltvExpiryDelta: UInt16,
        htlcMinimumMsat: UInt64,
        htlcMaximumMsat: UInt64,
        fees: RoutingFees
    ) {
        self.lastUpdate = lastUpdate
        self.enabled = enabled
        self.cltvExpiryDelta = cltvExpiryDelta
        self.htlcMinimumMsat = htlcMinimumMsat
        self.htlcMaximumMsat = htlcMaximumMsat
        self.fees = fees
    }
}

extension ChannelUpdateInfo: Equatable, Hashable {
    public static func == (lhs: ChannelUpdateInfo, rhs: ChannelUpdateInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.cltvExpiryDelta != rhs.cltvExpiryDelta {
            return false
        }
        if lhs.htlcMinimumMsat != rhs.htlcMinimumMsat {
            return false
        }
        if lhs.htlcMaximumMsat != rhs.htlcMaximumMsat {
            return false
        }
        if lhs.fees != rhs.fees {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(enabled)
        hasher.combine(cltvExpiryDelta)
        hasher.combine(htlcMinimumMsat)
        hasher.combine(htlcMaximumMsat)
        hasher.combine(fees)
    }
}

public struct FfiConverterTypeChannelUpdateInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelUpdateInfo {
        return
            try ChannelUpdateInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf),
                enabled: FfiConverterBool.read(from: &buf),
                cltvExpiryDelta: FfiConverterUInt16.read(from: &buf),
                htlcMinimumMsat: FfiConverterUInt64.read(from: &buf),
                htlcMaximumMsat: FfiConverterUInt64.read(from: &buf),
                fees: FfiConverterTypeRoutingFees.read(from: &buf)
            )
    }

    public static func write(_ value: ChannelUpdateInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterUInt16.write(value.cltvExpiryDelta, into: &buf)
        FfiConverterUInt64.write(value.htlcMinimumMsat, into: &buf)
        FfiConverterUInt64.write(value.htlcMaximumMsat, into: &buf)
        FfiConverterTypeRoutingFees.write(value.fees, into: &buf)
    }
}

public func FfiConverterTypeChannelUpdateInfo_lift(_ buf: RustBuffer) throws -> ChannelUpdateInfo {
    return try FfiConverterTypeChannelUpdateInfo.lift(buf)
}

public func FfiConverterTypeChannelUpdateInfo_lower(_ value: ChannelUpdateInfo) -> RustBuffer {
    return FfiConverterTypeChannelUpdateInfo.lower(value)
}

public struct Config {
    public var storageDirPath: String
    public var logDirPath: String?
    public var network: Network
    public var listeningAddresses: [SocketAddress]?
    public var nodeAlias: NodeAlias?
    public var trustedPeers0conf: [PublicKey]
    public var probingLiquidityLimitMultiplier: UInt64
    public var logLevel: LogLevel
    public var anchorChannelsConfig: AnchorChannelsConfig?
    public var sendingParameters: SendingParameters?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        storageDirPath: String,
        logDirPath: String?,
        network: Network,
        listeningAddresses: [SocketAddress]?,
        nodeAlias: NodeAlias?,
        trustedPeers0conf: [PublicKey],
        probingLiquidityLimitMultiplier: UInt64,
        logLevel: LogLevel,
        anchorChannelsConfig: AnchorChannelsConfig?,
        sendingParameters: SendingParameters?
    ) {
        self.storageDirPath = storageDirPath
        self.logDirPath = logDirPath
        self.network = network
        self.listeningAddresses = listeningAddresses
        self.nodeAlias = nodeAlias
        self.trustedPeers0conf = trustedPeers0conf
        self.probingLiquidityLimitMultiplier = probingLiquidityLimitMultiplier
        self.logLevel = logLevel
        self.anchorChannelsConfig = anchorChannelsConfig
        self.sendingParameters = sendingParameters
    }
}

extension Config: Equatable, Hashable {
    public static func == (lhs: Config, rhs: Config) -> Bool {
        if lhs.storageDirPath != rhs.storageDirPath {
            return false
        }
        if lhs.logDirPath != rhs.logDirPath {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.listeningAddresses != rhs.listeningAddresses {
            return false
        }
        if lhs.nodeAlias != rhs.nodeAlias {
            return false
        }
        if lhs.trustedPeers0conf != rhs.trustedPeers0conf {
            return false
        }
        if lhs.probingLiquidityLimitMultiplier != rhs.probingLiquidityLimitMultiplier {
            return false
        }
        if lhs.logLevel != rhs.logLevel {
            return false
        }
        if lhs.anchorChannelsConfig != rhs.anchorChannelsConfig {
            return false
        }
        if lhs.sendingParameters != rhs.sendingParameters {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(storageDirPath)
        hasher.combine(logDirPath)
        hasher.combine(network)
        hasher.combine(listeningAddresses)
        hasher.combine(nodeAlias)
        hasher.combine(trustedPeers0conf)
        hasher.combine(probingLiquidityLimitMultiplier)
        hasher.combine(logLevel)
        hasher.combine(anchorChannelsConfig)
        hasher.combine(sendingParameters)
    }
}

public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                storageDirPath: FfiConverterString.read(from: &buf),
                logDirPath: FfiConverterOptionString.read(from: &buf),
                network: FfiConverterTypeNetwork.read(from: &buf),
                listeningAddresses: FfiConverterOptionSequenceTypeSocketAddress.read(from: &buf),
                nodeAlias: FfiConverterOptionTypeNodeAlias.read(from: &buf),
                trustedPeers0conf: FfiConverterSequenceTypePublicKey.read(from: &buf),
                probingLiquidityLimitMultiplier: FfiConverterUInt64.read(from: &buf),
                logLevel: FfiConverterTypeLogLevel.read(from: &buf),
                anchorChannelsConfig: FfiConverterOptionTypeAnchorChannelsConfig.read(from: &buf),
                sendingParameters: FfiConverterOptionTypeSendingParameters.read(from: &buf)
            )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.storageDirPath, into: &buf)
        FfiConverterOptionString.write(value.logDirPath, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
        FfiConverterOptionSequenceTypeSocketAddress.write(value.listeningAddresses, into: &buf)
        FfiConverterOptionTypeNodeAlias.write(value.nodeAlias, into: &buf)
        FfiConverterSequenceTypePublicKey.write(value.trustedPeers0conf, into: &buf)
        FfiConverterUInt64.write(value.probingLiquidityLimitMultiplier, into: &buf)
        FfiConverterTypeLogLevel.write(value.logLevel, into: &buf)
        FfiConverterOptionTypeAnchorChannelsConfig.write(value.anchorChannelsConfig, into: &buf)
        FfiConverterOptionTypeSendingParameters.write(value.sendingParameters, into: &buf)
    }
}

public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}

public struct EsploraSyncConfig {
    public var onchainWalletSyncIntervalSecs: UInt64
    public var lightningWalletSyncIntervalSecs: UInt64
    public var feeRateCacheUpdateIntervalSecs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        onchainWalletSyncIntervalSecs: UInt64,
        lightningWalletSyncIntervalSecs: UInt64,
        feeRateCacheUpdateIntervalSecs: UInt64
    ) {
        self.onchainWalletSyncIntervalSecs = onchainWalletSyncIntervalSecs
        self.lightningWalletSyncIntervalSecs = lightningWalletSyncIntervalSecs
        self.feeRateCacheUpdateIntervalSecs = feeRateCacheUpdateIntervalSecs
    }
}

extension EsploraSyncConfig: Equatable, Hashable {
    public static func == (lhs: EsploraSyncConfig, rhs: EsploraSyncConfig) -> Bool {
        if lhs.onchainWalletSyncIntervalSecs != rhs.onchainWalletSyncIntervalSecs {
            return false
        }
        if lhs.lightningWalletSyncIntervalSecs != rhs.lightningWalletSyncIntervalSecs {
            return false
        }
        if lhs.feeRateCacheUpdateIntervalSecs != rhs.feeRateCacheUpdateIntervalSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onchainWalletSyncIntervalSecs)
        hasher.combine(lightningWalletSyncIntervalSecs)
        hasher.combine(feeRateCacheUpdateIntervalSecs)
    }
}

public struct FfiConverterTypeEsploraSyncConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EsploraSyncConfig {
        return
            try EsploraSyncConfig(
                onchainWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                lightningWalletSyncIntervalSecs: FfiConverterUInt64.read(from: &buf),
                feeRateCacheUpdateIntervalSecs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: EsploraSyncConfig, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.onchainWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.lightningWalletSyncIntervalSecs, into: &buf)
        FfiConverterUInt64.write(value.feeRateCacheUpdateIntervalSecs, into: &buf)
    }
}

public func FfiConverterTypeEsploraSyncConfig_lift(_ buf: RustBuffer) throws -> EsploraSyncConfig {
    return try FfiConverterTypeEsploraSyncConfig.lift(buf)
}

public func FfiConverterTypeEsploraSyncConfig_lower(_ value: EsploraSyncConfig) -> RustBuffer {
    return FfiConverterTypeEsploraSyncConfig.lower(value)
}

public struct LspFeeLimits {
    public var maxTotalOpeningFeeMsat: UInt64?
    public var maxProportionalOpeningFeePpmMsat: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        maxTotalOpeningFeeMsat: UInt64?,
        maxProportionalOpeningFeePpmMsat: UInt64?
    ) {
        self.maxTotalOpeningFeeMsat = maxTotalOpeningFeeMsat
        self.maxProportionalOpeningFeePpmMsat = maxProportionalOpeningFeePpmMsat
    }
}

extension LspFeeLimits: Equatable, Hashable {
    public static func == (lhs: LspFeeLimits, rhs: LspFeeLimits) -> Bool {
        if lhs.maxTotalOpeningFeeMsat != rhs.maxTotalOpeningFeeMsat {
            return false
        }
        if lhs.maxProportionalOpeningFeePpmMsat != rhs.maxProportionalOpeningFeePpmMsat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalOpeningFeeMsat)
        hasher.combine(maxProportionalOpeningFeePpmMsat)
    }
}

public struct FfiConverterTypeLSPFeeLimits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspFeeLimits {
        return
            try LspFeeLimits(
                maxTotalOpeningFeeMsat: FfiConverterOptionUInt64.read(from: &buf),
                maxProportionalOpeningFeePpmMsat: FfiConverterOptionUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: LspFeeLimits, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxTotalOpeningFeeMsat, into: &buf)
        FfiConverterOptionUInt64.write(value.maxProportionalOpeningFeePpmMsat, into: &buf)
    }
}

public func FfiConverterTypeLSPFeeLimits_lift(_ buf: RustBuffer) throws -> LspFeeLimits {
    return try FfiConverterTypeLSPFeeLimits.lift(buf)
}

public func FfiConverterTypeLSPFeeLimits_lower(_ value: LspFeeLimits) -> RustBuffer {
    return FfiConverterTypeLSPFeeLimits.lower(value)
}

public struct NodeAnnouncementInfo {
    public var lastUpdate: UInt32
    public var alias: String
    public var addresses: [SocketAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        lastUpdate: UInt32,
        alias: String,
        addresses: [SocketAddress]
    ) {
        self.lastUpdate = lastUpdate
        self.alias = alias
        self.addresses = addresses
    }
}

extension NodeAnnouncementInfo: Equatable, Hashable {
    public static func == (lhs: NodeAnnouncementInfo, rhs: NodeAnnouncementInfo) -> Bool {
        if lhs.lastUpdate != rhs.lastUpdate {
            return false
        }
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUpdate)
        hasher.combine(alias)
        hasher.combine(addresses)
    }
}

public struct FfiConverterTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAnnouncementInfo {
        return
            try NodeAnnouncementInfo(
                lastUpdate: FfiConverterUInt32.read(from: &buf),
                alias: FfiConverterString.read(from: &buf),
                addresses: FfiConverterSequenceTypeSocketAddress.read(from: &buf)
            )
    }

    public static func write(_ value: NodeAnnouncementInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.lastUpdate, into: &buf)
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterSequenceTypeSocketAddress.write(value.addresses, into: &buf)
    }
}

public func FfiConverterTypeNodeAnnouncementInfo_lift(_ buf: RustBuffer) throws -> NodeAnnouncementInfo {
    return try FfiConverterTypeNodeAnnouncementInfo.lift(buf)
}

public func FfiConverterTypeNodeAnnouncementInfo_lower(_ value: NodeAnnouncementInfo) -> RustBuffer {
    return FfiConverterTypeNodeAnnouncementInfo.lower(value)
}

public struct NodeInfo {
    public var channels: [UInt64]
    public var announcementInfo: NodeAnnouncementInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        channels: [UInt64],
        announcementInfo: NodeAnnouncementInfo?
    ) {
        self.channels = channels
        self.announcementInfo = announcementInfo
    }
}

extension NodeInfo: Equatable, Hashable {
    public static func == (lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.channels != rhs.channels {
            return false
        }
        if lhs.announcementInfo != rhs.announcementInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channels)
        hasher.combine(announcementInfo)
    }
}

public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                channels: FfiConverterSequenceUInt64.read(from: &buf),
                announcementInfo: FfiConverterOptionTypeNodeAnnouncementInfo.read(from: &buf)
            )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.channels, into: &buf)
        FfiConverterOptionTypeNodeAnnouncementInfo.write(value.announcementInfo, into: &buf)
    }
}

public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}

public struct NodeStatus {
    public var isRunning: Bool
    public var isListening: Bool
    public var currentBestBlock: BestBlock
    public var latestLightningWalletSyncTimestamp: UInt64?
    public var latestOnchainWalletSyncTimestamp: UInt64?
    public var latestFeeRateCacheUpdateTimestamp: UInt64?
    public var latestRgsSnapshotTimestamp: UInt64?
    public var latestNodeAnnouncementBroadcastTimestamp: UInt64?
    public var latestChannelMonitorArchivalHeight: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        isRunning: Bool,
        isListening: Bool,
        currentBestBlock: BestBlock,
        latestLightningWalletSyncTimestamp: UInt64?,
        latestOnchainWalletSyncTimestamp: UInt64?,
        latestFeeRateCacheUpdateTimestamp: UInt64?,
        latestRgsSnapshotTimestamp: UInt64?,
        latestNodeAnnouncementBroadcastTimestamp: UInt64?,
        latestChannelMonitorArchivalHeight: UInt32?
    ) {
        self.isRunning = isRunning
        self.isListening = isListening
        self.currentBestBlock = currentBestBlock
        self.latestLightningWalletSyncTimestamp = latestLightningWalletSyncTimestamp
        self.latestOnchainWalletSyncTimestamp = latestOnchainWalletSyncTimestamp
        self.latestFeeRateCacheUpdateTimestamp = latestFeeRateCacheUpdateTimestamp
        self.latestRgsSnapshotTimestamp = latestRgsSnapshotTimestamp
        self.latestNodeAnnouncementBroadcastTimestamp = latestNodeAnnouncementBroadcastTimestamp
        self.latestChannelMonitorArchivalHeight = latestChannelMonitorArchivalHeight
    }
}

extension NodeStatus: Equatable, Hashable {
    public static func == (lhs: NodeStatus, rhs: NodeStatus) -> Bool {
        if lhs.isRunning != rhs.isRunning {
            return false
        }
        if lhs.isListening != rhs.isListening {
            return false
        }
        if lhs.currentBestBlock != rhs.currentBestBlock {
            return false
        }
        if lhs.latestLightningWalletSyncTimestamp != rhs.latestLightningWalletSyncTimestamp {
            return false
        }
        if lhs.latestOnchainWalletSyncTimestamp != rhs.latestOnchainWalletSyncTimestamp {
            return false
        }
        if lhs.latestFeeRateCacheUpdateTimestamp != rhs.latestFeeRateCacheUpdateTimestamp {
            return false
        }
        if lhs.latestRgsSnapshotTimestamp != rhs.latestRgsSnapshotTimestamp {
            return false
        }
        if lhs.latestNodeAnnouncementBroadcastTimestamp != rhs.latestNodeAnnouncementBroadcastTimestamp {
            return false
        }
        if lhs.latestChannelMonitorArchivalHeight != rhs.latestChannelMonitorArchivalHeight {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRunning)
        hasher.combine(isListening)
        hasher.combine(currentBestBlock)
        hasher.combine(latestLightningWalletSyncTimestamp)
        hasher.combine(latestOnchainWalletSyncTimestamp)
        hasher.combine(latestFeeRateCacheUpdateTimestamp)
        hasher.combine(latestRgsSnapshotTimestamp)
        hasher.combine(latestNodeAnnouncementBroadcastTimestamp)
        hasher.combine(latestChannelMonitorArchivalHeight)
    }
}

public struct FfiConverterTypeNodeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatus {
        return
            try NodeStatus(
                isRunning: FfiConverterBool.read(from: &buf),
                isListening: FfiConverterBool.read(from: &buf),
                currentBestBlock: FfiConverterTypeBestBlock.read(from: &buf),
                latestLightningWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestOnchainWalletSyncTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestFeeRateCacheUpdateTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestRgsSnapshotTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestNodeAnnouncementBroadcastTimestamp: FfiConverterOptionUInt64.read(from: &buf),
                latestChannelMonitorArchivalHeight: FfiConverterOptionUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: NodeStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRunning, into: &buf)
        FfiConverterBool.write(value.isListening, into: &buf)
        FfiConverterTypeBestBlock.write(value.currentBestBlock, into: &buf)
        FfiConverterOptionUInt64.write(value.latestLightningWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestOnchainWalletSyncTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestFeeRateCacheUpdateTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestRgsSnapshotTimestamp, into: &buf)
        FfiConverterOptionUInt64.write(value.latestNodeAnnouncementBroadcastTimestamp, into: &buf)
        FfiConverterOptionUInt32.write(value.latestChannelMonitorArchivalHeight, into: &buf)
    }
}

public func FfiConverterTypeNodeStatus_lift(_ buf: RustBuffer) throws -> NodeStatus {
    return try FfiConverterTypeNodeStatus.lift(buf)
}

public func FfiConverterTypeNodeStatus_lower(_ value: NodeStatus) -> RustBuffer {
    return FfiConverterTypeNodeStatus.lower(value)
}

public struct OutPoint {
    public var txid: Txid
    public var vout: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        txid: Txid,
        vout: UInt32
    ) {
        self.txid = txid
        self.vout = vout
    }
}

extension OutPoint: Equatable, Hashable {
    public static func == (lhs: OutPoint, rhs: OutPoint) -> Bool {
        if lhs.txid != rhs.txid {
            return false
        }
        if lhs.vout != rhs.vout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txid)
        hasher.combine(vout)
    }
}

public struct FfiConverterTypeOutPoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OutPoint {
        return
            try OutPoint(
                txid: FfiConverterTypeTxid.read(from: &buf),
                vout: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: OutPoint, into buf: inout [UInt8]) {
        FfiConverterTypeTxid.write(value.txid, into: &buf)
        FfiConverterUInt32.write(value.vout, into: &buf)
    }
}

public func FfiConverterTypeOutPoint_lift(_ buf: RustBuffer) throws -> OutPoint {
    return try FfiConverterTypeOutPoint.lift(buf)
}

public func FfiConverterTypeOutPoint_lower(_ value: OutPoint) -> RustBuffer {
    return FfiConverterTypeOutPoint.lower(value)
}

public struct PaymentDetails {
    public var id: PaymentId
    public var kind: PaymentKind
    public var amountMsat: UInt64?
    public var direction: PaymentDirection
    public var status: PaymentStatus
    public var latestUpdateTimestamp: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: PaymentId,
        kind: PaymentKind,
        amountMsat: UInt64?,
        direction: PaymentDirection,
        status: PaymentStatus,
        latestUpdateTimestamp: UInt64
    ) {
        self.id = id
        self.kind = kind
        self.amountMsat = amountMsat
        self.direction = direction
        self.status = status
        self.latestUpdateTimestamp = latestUpdateTimestamp
    }
}

extension PaymentDetails: Equatable, Hashable {
    public static func == (lhs: PaymentDetails, rhs: PaymentDetails) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.amountMsat != rhs.amountMsat {
            return false
        }
        if lhs.direction != rhs.direction {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.latestUpdateTimestamp != rhs.latestUpdateTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(kind)
        hasher.combine(amountMsat)
        hasher.combine(direction)
        hasher.combine(status)
        hasher.combine(latestUpdateTimestamp)
    }
}

public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        return
            try PaymentDetails(
                id: FfiConverterTypePaymentId.read(from: &buf),
                kind: FfiConverterTypePaymentKind.read(from: &buf),
                amountMsat: FfiConverterOptionUInt64.read(from: &buf),
                direction: FfiConverterTypePaymentDirection.read(from: &buf),
                status: FfiConverterTypePaymentStatus.read(from: &buf),
                latestUpdateTimestamp: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        FfiConverterTypePaymentId.write(value.id, into: &buf)
        FfiConverterTypePaymentKind.write(value.kind, into: &buf)
        FfiConverterOptionUInt64.write(value.amountMsat, into: &buf)
        FfiConverterTypePaymentDirection.write(value.direction, into: &buf)
        FfiConverterTypePaymentStatus.write(value.status, into: &buf)
        FfiConverterUInt64.write(value.latestUpdateTimestamp, into: &buf)
    }
}

public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}

public struct PeerDetails {
    public var nodeId: PublicKey
    public var address: SocketAddress
    public var isPersisted: Bool
    public var isConnected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        nodeId: PublicKey,
        address: SocketAddress,
        isPersisted: Bool,
        isConnected: Bool
    ) {
        self.nodeId = nodeId
        self.address = address
        self.isPersisted = isPersisted
        self.isConnected = isConnected
    }
}

extension PeerDetails: Equatable, Hashable {
    public static func == (lhs: PeerDetails, rhs: PeerDetails) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.isPersisted != rhs.isPersisted {
            return false
        }
        if lhs.isConnected != rhs.isConnected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(address)
        hasher.combine(isPersisted)
        hasher.combine(isConnected)
    }
}

public struct FfiConverterTypePeerDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerDetails {
        return
            try PeerDetails(
                nodeId: FfiConverterTypePublicKey.read(from: &buf),
                address: FfiConverterTypeSocketAddress.read(from: &buf),
                isPersisted: FfiConverterBool.read(from: &buf),
                isConnected: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: PeerDetails, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.nodeId, into: &buf)
        FfiConverterTypeSocketAddress.write(value.address, into: &buf)
        FfiConverterBool.write(value.isPersisted, into: &buf)
        FfiConverterBool.write(value.isConnected, into: &buf)
    }
}

public func FfiConverterTypePeerDetails_lift(_ buf: RustBuffer) throws -> PeerDetails {
    return try FfiConverterTypePeerDetails.lift(buf)
}

public func FfiConverterTypePeerDetails_lower(_ value: PeerDetails) -> RustBuffer {
    return FfiConverterTypePeerDetails.lower(value)
}

public struct RoutingFees {
    public var baseMsat: UInt32
    public var proportionalMillionths: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        baseMsat: UInt32,
        proportionalMillionths: UInt32
    ) {
        self.baseMsat = baseMsat
        self.proportionalMillionths = proportionalMillionths
    }
}

extension RoutingFees: Equatable, Hashable {
    public static func == (lhs: RoutingFees, rhs: RoutingFees) -> Bool {
        if lhs.baseMsat != rhs.baseMsat {
            return false
        }
        if lhs.proportionalMillionths != rhs.proportionalMillionths {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseMsat)
        hasher.combine(proportionalMillionths)
    }
}

public struct FfiConverterTypeRoutingFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoutingFees {
        return
            try RoutingFees(
                baseMsat: FfiConverterUInt32.read(from: &buf),
                proportionalMillionths: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: RoutingFees, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.baseMsat, into: &buf)
        FfiConverterUInt32.write(value.proportionalMillionths, into: &buf)
    }
}

public func FfiConverterTypeRoutingFees_lift(_ buf: RustBuffer) throws -> RoutingFees {
    return try FfiConverterTypeRoutingFees.lift(buf)
}

public func FfiConverterTypeRoutingFees_lower(_ value: RoutingFees) -> RustBuffer {
    return FfiConverterTypeRoutingFees.lower(value)
}

public struct SendingParameters {
    public var maxTotalRoutingFeeMsat: MaxTotalRoutingFeeLimit?
    public var maxTotalCltvExpiryDelta: UInt32?
    public var maxPathCount: UInt8?
    public var maxChannelSaturationPowerOfHalf: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        maxTotalRoutingFeeMsat: MaxTotalRoutingFeeLimit?,
        maxTotalCltvExpiryDelta: UInt32?,
        maxPathCount: UInt8?,
        maxChannelSaturationPowerOfHalf: UInt8?
    ) {
        self.maxTotalRoutingFeeMsat = maxTotalRoutingFeeMsat
        self.maxTotalCltvExpiryDelta = maxTotalCltvExpiryDelta
        self.maxPathCount = maxPathCount
        self.maxChannelSaturationPowerOfHalf = maxChannelSaturationPowerOfHalf
    }
}

extension SendingParameters: Equatable, Hashable {
    public static func == (lhs: SendingParameters, rhs: SendingParameters) -> Bool {
        if lhs.maxTotalRoutingFeeMsat != rhs.maxTotalRoutingFeeMsat {
            return false
        }
        if lhs.maxTotalCltvExpiryDelta != rhs.maxTotalCltvExpiryDelta {
            return false
        }
        if lhs.maxPathCount != rhs.maxPathCount {
            return false
        }
        if lhs.maxChannelSaturationPowerOfHalf != rhs.maxChannelSaturationPowerOfHalf {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(maxTotalRoutingFeeMsat)
        hasher.combine(maxTotalCltvExpiryDelta)
        hasher.combine(maxPathCount)
        hasher.combine(maxChannelSaturationPowerOfHalf)
    }
}

public struct FfiConverterTypeSendingParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendingParameters {
        return
            try SendingParameters(
                maxTotalRoutingFeeMsat: FfiConverterOptionTypeMaxTotalRoutingFeeLimit.read(from: &buf),
                maxTotalCltvExpiryDelta: FfiConverterOptionUInt32.read(from: &buf),
                maxPathCount: FfiConverterOptionUInt8.read(from: &buf),
                maxChannelSaturationPowerOfHalf: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: SendingParameters, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMaxTotalRoutingFeeLimit.write(value.maxTotalRoutingFeeMsat, into: &buf)
        FfiConverterOptionUInt32.write(value.maxTotalCltvExpiryDelta, into: &buf)
        FfiConverterOptionUInt8.write(value.maxPathCount, into: &buf)
        FfiConverterOptionUInt8.write(value.maxChannelSaturationPowerOfHalf, into: &buf)
    }
}

public func FfiConverterTypeSendingParameters_lift(_ buf: RustBuffer) throws -> SendingParameters {
    return try FfiConverterTypeSendingParameters.lift(buf)
}

public func FfiConverterTypeSendingParameters_lower(_ value: SendingParameters) -> RustBuffer {
    return FfiConverterTypeSendingParameters.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BalanceSource {
    case holderForceClosed
    case counterpartyForceClosed
    case coopClose
    case htlc
}

public struct FfiConverterTypeBalanceSource: FfiConverterRustBuffer {
    typealias SwiftType = BalanceSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalanceSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .holderForceClosed

        case 2: return .counterpartyForceClosed

        case 3: return .coopClose

        case 4: return .htlc

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BalanceSource, into buf: inout [UInt8]) {
        switch value {
        case .holderForceClosed:
            writeInt(&buf, Int32(1))

        case .counterpartyForceClosed:
            writeInt(&buf, Int32(2))

        case .coopClose:
            writeInt(&buf, Int32(3))

        case .htlc:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeBalanceSource_lift(_ buf: RustBuffer) throws -> BalanceSource {
    return try FfiConverterTypeBalanceSource.lift(buf)
}

public func FfiConverterTypeBalanceSource_lower(_ value: BalanceSource) -> RustBuffer {
    return FfiConverterTypeBalanceSource.lower(value)
}

extension BalanceSource: Equatable, Hashable {}

public enum BuildError {
    case InvalidSeedBytes(message: String)

    case InvalidSeedFile(message: String)

    case InvalidSystemTime(message: String)

    case InvalidChannelMonitor(message: String)

    case InvalidListeningAddresses(message: String)

    case InvalidNodeAlias(message: String)

    case ReadFailed(message: String)

    case WriteFailed(message: String)

    case StoragePathAccessFailed(message: String)

    case KvStoreSetupFailed(message: String)

    case WalletSetupFailed(message: String)

    case LoggerSetupFailed(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeBuildError.lift(error)
    }
}

public struct FfiConverterTypeBuildError: FfiConverterRustBuffer {
    typealias SwiftType = BuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .InvalidSeedBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .InvalidSeedFile(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .InvalidSystemTime(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InvalidChannelMonitor(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvalidListeningAddresses(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .InvalidNodeAlias(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .ReadFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .WriteFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .StoragePathAccessFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .KvStoreSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .WalletSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .LoggerSetupFailed(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuildError, into buf: inout [UInt8]) {
        switch value {
        case .InvalidSeedBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .InvalidSeedFile(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .InvalidSystemTime(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .InvalidChannelMonitor(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvalidListeningAddresses(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .InvalidNodeAlias(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .ReadFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .WriteFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .StoragePathAccessFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .KvStoreSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .WalletSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .LoggerSetupFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        }
    }
}

extension BuildError: Equatable, Hashable {}

extension BuildError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ClosureReason {
    case counterpartyForceClosed(
        peerMsg: UntrustedString
    )
    case holderForceClosed(
        broadcastedLatestTxn: Bool?
    )
    case legacyCooperativeClosure
    case counterpartyInitiatedCooperativeClosure
    case locallyInitiatedCooperativeClosure
    case commitmentTxConfirmed
    case fundingTimedOut
    case processingError(
        err: String
    )
    case disconnectedPeer
    case outdatedChannelManager
    case counterpartyCoopClosedUnfundedChannel
    case fundingBatchClosure
    case htlCsTimedOut
    case peerFeerateTooLow(
        peerFeerateSatPerKw: UInt32,
        requiredFeerateSatPerKw: UInt32
    )
}

public struct FfiConverterTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .counterpartyForceClosed(
                peerMsg: FfiConverterTypeUntrustedString.read(from: &buf)
            )

        case 2: return try .holderForceClosed(
                broadcastedLatestTxn: FfiConverterOptionBool.read(from: &buf)
            )

        case 3: return .legacyCooperativeClosure

        case 4: return .counterpartyInitiatedCooperativeClosure

        case 5: return .locallyInitiatedCooperativeClosure

        case 6: return .commitmentTxConfirmed

        case 7: return .fundingTimedOut

        case 8: return try .processingError(
                err: FfiConverterString.read(from: &buf)
            )

        case 9: return .disconnectedPeer

        case 10: return .outdatedChannelManager

        case 11: return .counterpartyCoopClosedUnfundedChannel

        case 12: return .fundingBatchClosure

        case 13: return .htlCsTimedOut

        case 14: return try .peerFeerateTooLow(
                peerFeerateSatPerKw: FfiConverterUInt32.read(from: &buf),
                requiredFeerateSatPerKw: FfiConverterUInt32.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClosureReason, into buf: inout [UInt8]) {
        switch value {
        case let .counterpartyForceClosed(peerMsg):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUntrustedString.write(peerMsg, into: &buf)

        case let .holderForceClosed(broadcastedLatestTxn):
            writeInt(&buf, Int32(2))
            FfiConverterOptionBool.write(broadcastedLatestTxn, into: &buf)

        case .legacyCooperativeClosure:
            writeInt(&buf, Int32(3))

        case .counterpartyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(4))

        case .locallyInitiatedCooperativeClosure:
            writeInt(&buf, Int32(5))

        case .commitmentTxConfirmed:
            writeInt(&buf, Int32(6))

        case .fundingTimedOut:
            writeInt(&buf, Int32(7))

        case let .processingError(err):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(err, into: &buf)

        case .disconnectedPeer:
            writeInt(&buf, Int32(9))

        case .outdatedChannelManager:
            writeInt(&buf, Int32(10))

        case .counterpartyCoopClosedUnfundedChannel:
            writeInt(&buf, Int32(11))

        case .fundingBatchClosure:
            writeInt(&buf, Int32(12))

        case .htlCsTimedOut:
            writeInt(&buf, Int32(13))

        case let .peerFeerateTooLow(peerFeerateSatPerKw, requiredFeerateSatPerKw):
            writeInt(&buf, Int32(14))
            FfiConverterUInt32.write(peerFeerateSatPerKw, into: &buf)
            FfiConverterUInt32.write(requiredFeerateSatPerKw, into: &buf)
        }
    }
}

public func FfiConverterTypeClosureReason_lift(_ buf: RustBuffer) throws -> ClosureReason {
    return try FfiConverterTypeClosureReason.lift(buf)
}

public func FfiConverterTypeClosureReason_lower(_ value: ClosureReason) -> RustBuffer {
    return FfiConverterTypeClosureReason.lower(value)
}

extension ClosureReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Event {
    case paymentSuccessful(
        paymentId: PaymentId?,
        paymentHash: PaymentHash,
        feePaidMsat: UInt64?
    )
    case paymentFailed(
        paymentId: PaymentId?,
        paymentHash: PaymentHash?,
        reason: PaymentFailureReason?
    )
    case paymentReceived(
        paymentId: PaymentId?,
        paymentHash: PaymentHash,
        amountMsat: UInt64
    )
    case paymentClaimable(
        paymentId: PaymentId,
        paymentHash: PaymentHash,
        claimableAmountMsat: UInt64,
        claimDeadline: UInt32?
    )
    case channelPending(
        channelId: ChannelId,
        userChannelId: UserChannelId,
        formerTemporaryChannelId: ChannelId,
        counterpartyNodeId: PublicKey,
        fundingTxo: OutPoint
    )
    case channelReady(
        channelId: ChannelId,
        userChannelId: UserChannelId,
        counterpartyNodeId: PublicKey?
    )
    case channelClosed(
        channelId: ChannelId,
        userChannelId: UserChannelId,
        counterpartyNodeId: PublicKey?,
        reason: ClosureReason?
    )
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .paymentSuccessful(
                paymentId: FfiConverterOptionTypePaymentId.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf),
                feePaidMsat: FfiConverterOptionUInt64.read(from: &buf)
            )

        case 2: return try .paymentFailed(
                paymentId: FfiConverterOptionTypePaymentId.read(from: &buf),
                paymentHash: FfiConverterOptionTypePaymentHash.read(from: &buf),
                reason: FfiConverterOptionTypePaymentFailureReason.read(from: &buf)
            )

        case 3: return try .paymentReceived(
                paymentId: FfiConverterOptionTypePaymentId.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf),
                amountMsat: FfiConverterUInt64.read(from: &buf)
            )

        case 4: return try .paymentClaimable(
                paymentId: FfiConverterTypePaymentId.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf),
                claimableAmountMsat: FfiConverterUInt64.read(from: &buf),
                claimDeadline: FfiConverterOptionUInt32.read(from: &buf)
            )

        case 5: return try .channelPending(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf),
                formerTemporaryChannelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                fundingTxo: FfiConverterTypeOutPoint.read(from: &buf)
            )

        case 6: return try .channelReady(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterOptionTypePublicKey.read(from: &buf)
            )

        case 7: return try .channelClosed(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                userChannelId: FfiConverterTypeUserChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterOptionTypePublicKey.read(from: &buf),
                reason: FfiConverterOptionTypeClosureReason.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        case let .paymentSuccessful(paymentId, paymentHash, feePaidMsat):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionUInt64.write(feePaidMsat, into: &buf)

        case let .paymentFailed(paymentId, paymentHash, reason):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterOptionTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterOptionTypePaymentFailureReason.write(reason, into: &buf)

        case let .paymentReceived(paymentId, paymentHash, amountMsat):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(amountMsat, into: &buf)

        case let .paymentClaimable(paymentId, paymentHash, claimableAmountMsat, claimDeadline):
            writeInt(&buf, Int32(4))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterUInt64.write(claimableAmountMsat, into: &buf)
            FfiConverterOptionUInt32.write(claimDeadline, into: &buf)

        case let .channelPending(channelId, userChannelId, formerTemporaryChannelId, counterpartyNodeId, fundingTxo):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterTypeChannelId.write(formerTemporaryChannelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterTypeOutPoint.write(fundingTxo, into: &buf)

        case let .channelReady(channelId, userChannelId, counterpartyNodeId):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)

        case let .channelClosed(channelId, userChannelId, counterpartyNodeId, reason):
            writeInt(&buf, Int32(7))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeUserChannelId.write(userChannelId, into: &buf)
            FfiConverterOptionTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterOptionTypeClosureReason.write(reason, into: &buf)
        }
    }
}

public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}

extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LightningBalance {
    case claimableOnChannelClose(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64,
        transactionFeeSatoshis: UInt64,
        outboundPaymentHtlcRoundedMsat: UInt64,
        outboundForwardedHtlcRoundedMsat: UInt64,
        inboundClaimingHtlcRoundedMsat: UInt64,
        inboundHtlcRoundedMsat: UInt64
    )
    case claimableAwaitingConfirmations(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64,
        confirmationHeight: UInt32,
        source: BalanceSource
    )
    case contentiousClaimable(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64,
        timeoutHeight: UInt32,
        paymentHash: PaymentHash,
        paymentPreimage: PaymentPreimage
    )
    case maybeTimeoutClaimableHtlc(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64,
        claimableHeight: UInt32,
        paymentHash: PaymentHash,
        outboundPayment: Bool
    )
    case maybePreimageClaimableHtlc(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64,
        expiryHeight: UInt32,
        paymentHash: PaymentHash
    )
    case counterpartyRevokedOutputClaimable(
        channelId: ChannelId,
        counterpartyNodeId: PublicKey,
        amountSatoshis: UInt64
    )
}

public struct FfiConverterTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = LightningBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .claimableOnChannelClose(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf),
                transactionFeeSatoshis: FfiConverterUInt64.read(from: &buf),
                outboundPaymentHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf),
                outboundForwardedHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf),
                inboundClaimingHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf),
                inboundHtlcRoundedMsat: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .claimableAwaitingConfirmations(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf),
                confirmationHeight: FfiConverterUInt32.read(from: &buf),
                source: FfiConverterTypeBalanceSource.read(from: &buf)
            )

        case 3: return try .contentiousClaimable(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf),
                timeoutHeight: FfiConverterUInt32.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf),
                paymentPreimage: FfiConverterTypePaymentPreimage.read(from: &buf)
            )

        case 4: return try .maybeTimeoutClaimableHtlc(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf),
                claimableHeight: FfiConverterUInt32.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf),
                outboundPayment: FfiConverterBool.read(from: &buf)
            )

        case 5: return try .maybePreimageClaimableHtlc(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf),
                expiryHeight: FfiConverterUInt32.read(from: &buf),
                paymentHash: FfiConverterTypePaymentHash.read(from: &buf)
            )

        case 6: return try .counterpartyRevokedOutputClaimable(
                channelId: FfiConverterTypeChannelId.read(from: &buf),
                counterpartyNodeId: FfiConverterTypePublicKey.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LightningBalance, into buf: inout [UInt8]) {
        switch value {
        case let .claimableOnChannelClose(channelId, counterpartyNodeId, amountSatoshis, transactionFeeSatoshis, outboundPaymentHtlcRoundedMsat, outboundForwardedHtlcRoundedMsat, inboundClaimingHtlcRoundedMsat, inboundHtlcRoundedMsat):
            writeInt(&buf, Int32(1))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt64.write(transactionFeeSatoshis, into: &buf)
            FfiConverterUInt64.write(outboundPaymentHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(outboundForwardedHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundClaimingHtlcRoundedMsat, into: &buf)
            FfiConverterUInt64.write(inboundHtlcRoundedMsat, into: &buf)

        case let .claimableAwaitingConfirmations(channelId, counterpartyNodeId, amountSatoshis, confirmationHeight, source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterTypeBalanceSource.write(source, into: &buf)

        case let .contentiousClaimable(channelId, counterpartyNodeId, amountSatoshis, timeoutHeight, paymentHash, paymentPreimage):
            writeInt(&buf, Int32(3))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(timeoutHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterTypePaymentPreimage.write(paymentPreimage, into: &buf)

        case let .maybeTimeoutClaimableHtlc(channelId, counterpartyNodeId, amountSatoshis, claimableHeight, paymentHash, outboundPayment):
            writeInt(&buf, Int32(4))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(claimableHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)
            FfiConverterBool.write(outboundPayment, into: &buf)

        case let .maybePreimageClaimableHtlc(channelId, counterpartyNodeId, amountSatoshis, expiryHeight, paymentHash):
            writeInt(&buf, Int32(5))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
            FfiConverterUInt32.write(expiryHeight, into: &buf)
            FfiConverterTypePaymentHash.write(paymentHash, into: &buf)

        case let .counterpartyRevokedOutputClaimable(channelId, counterpartyNodeId, amountSatoshis):
            writeInt(&buf, Int32(6))
            FfiConverterTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypePublicKey.write(counterpartyNodeId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
        }
    }
}

public func FfiConverterTypeLightningBalance_lift(_ buf: RustBuffer) throws -> LightningBalance {
    return try FfiConverterTypeLightningBalance.lift(buf)
}

public func FfiConverterTypeLightningBalance_lower(_ value: LightningBalance) -> RustBuffer {
    return FfiConverterTypeLightningBalance.lower(value)
}

extension LightningBalance: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LogLevel {
    case gossip
    case trace
    case debug
    case info
    case warn
    case error
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .gossip

        case 2: return .trace

        case 3: return .debug

        case 4: return .info

        case 5: return .warn

        case 6: return .error

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .gossip:
            writeInt(&buf, Int32(1))

        case .trace:
            writeInt(&buf, Int32(2))

        case .debug:
            writeInt(&buf, Int32(3))

        case .info:
            writeInt(&buf, Int32(4))

        case .warn:
            writeInt(&buf, Int32(5))

        case .error:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MaxDustHtlcExposure {
    case fixedLimit(
        limitMsat: UInt64
    )
    case feeRateMultiplier(
        multiplier: UInt64
    )
}

public struct FfiConverterTypeMaxDustHTLCExposure: FfiConverterRustBuffer {
    typealias SwiftType = MaxDustHtlcExposure

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxDustHtlcExposure {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fixedLimit(
                limitMsat: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .feeRateMultiplier(
                multiplier: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxDustHtlcExposure, into buf: inout [UInt8]) {
        switch value {
        case let .fixedLimit(limitMsat):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(limitMsat, into: &buf)

        case let .feeRateMultiplier(multiplier):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(multiplier, into: &buf)
        }
    }
}

public func FfiConverterTypeMaxDustHTLCExposure_lift(_ buf: RustBuffer) throws -> MaxDustHtlcExposure {
    return try FfiConverterTypeMaxDustHTLCExposure.lift(buf)
}

public func FfiConverterTypeMaxDustHTLCExposure_lower(_ value: MaxDustHtlcExposure) -> RustBuffer {
    return FfiConverterTypeMaxDustHTLCExposure.lower(value)
}

extension MaxDustHtlcExposure: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MaxTotalRoutingFeeLimit {
    case none
    case some(
        amountMsat: UInt64
    )
}

public struct FfiConverterTypeMaxTotalRoutingFeeLimit: FfiConverterRustBuffer {
    typealias SwiftType = MaxTotalRoutingFeeLimit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxTotalRoutingFeeLimit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return try .some(
                amountMsat: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MaxTotalRoutingFeeLimit, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case let .some(amountMsat):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(amountMsat, into: &buf)
        }
    }
}

public func FfiConverterTypeMaxTotalRoutingFeeLimit_lift(_ buf: RustBuffer) throws -> MaxTotalRoutingFeeLimit {
    return try FfiConverterTypeMaxTotalRoutingFeeLimit.lift(buf)
}

public func FfiConverterTypeMaxTotalRoutingFeeLimit_lower(_ value: MaxTotalRoutingFeeLimit) -> RustBuffer {
    return FfiConverterTypeMaxTotalRoutingFeeLimit.lower(value)
}

extension MaxTotalRoutingFeeLimit: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    case bitcoin
    case testnet
    case signet
    case regtest
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .bitcoin

        case 2: return .testnet

        case 3: return .signet

        case 4: return .regtest

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        case .bitcoin:
            writeInt(&buf, Int32(1))

        case .testnet:
            writeInt(&buf, Int32(2))

        case .signet:
            writeInt(&buf, Int32(3))

        case .regtest:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}

extension Network: Equatable, Hashable {}

public enum NodeError {
    case AlreadyRunning(message: String)

    case NotRunning(message: String)

    case OnchainTxCreationFailed(message: String)

    case ConnectionFailed(message: String)

    case InvoiceCreationFailed(message: String)

    case InvoiceRequestCreationFailed(message: String)

    case OfferCreationFailed(message: String)

    case RefundCreationFailed(message: String)

    case PaymentSendingFailed(message: String)

    case ProbeSendingFailed(message: String)

    case ChannelCreationFailed(message: String)

    case ChannelClosingFailed(message: String)

    case ChannelConfigUpdateFailed(message: String)

    case PersistenceFailed(message: String)

    case FeerateEstimationUpdateFailed(message: String)

    case FeerateEstimationUpdateTimeout(message: String)

    case WalletOperationFailed(message: String)

    case WalletOperationTimeout(message: String)

    case OnchainTxSigningFailed(message: String)

    case TxSyncFailed(message: String)

    case TxSyncTimeout(message: String)

    case GossipUpdateFailed(message: String)

    case GossipUpdateTimeout(message: String)

    case LiquidityRequestFailed(message: String)

    case UriParameterParsingFailed(message: String)

    case InvalidAddress(message: String)

    case InvalidSocketAddress(message: String)

    case InvalidPublicKey(message: String)

    case InvalidSecretKey(message: String)

    case InvalidOfferId(message: String)

    case InvalidNodeId(message: String)

    case InvalidPaymentId(message: String)

    case InvalidPaymentHash(message: String)

    case InvalidPaymentPreimage(message: String)

    case InvalidPaymentSecret(message: String)

    case InvalidAmount(message: String)

    case InvalidInvoice(message: String)

    case InvalidOffer(message: String)

    case InvalidRefund(message: String)

    case InvalidChannelId(message: String)

    case InvalidNetwork(message: String)

    case InvalidUri(message: String)

    case InvalidQuantity(message: String)

    case InvalidNodeAlias(message: String)

    case DuplicatePayment(message: String)

    case UnsupportedCurrency(message: String)

    case InsufficientFunds(message: String)

    case LiquiditySourceUnavailable(message: String)

    case LiquidityFeeTooHigh(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNodeError.lift(error)
    }
}

public struct FfiConverterTypeNodeError: FfiConverterRustBuffer {
    typealias SwiftType = NodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .AlreadyRunning(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .NotRunning(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .OnchainTxCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .ConnectionFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvoiceCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .InvoiceRequestCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .OfferCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .RefundCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .PaymentSendingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .ProbeSendingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .ChannelCreationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .ChannelClosingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .ChannelConfigUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .PersistenceFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .FeerateEstimationUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .FeerateEstimationUpdateTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 17: return try .WalletOperationFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 18: return try .WalletOperationTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 19: return try .OnchainTxSigningFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 20: return try .TxSyncFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 21: return try .TxSyncTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 22: return try .GossipUpdateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 23: return try .GossipUpdateTimeout(
                message: FfiConverterString.read(from: &buf)
            )

        case 24: return try .LiquidityRequestFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 25: return try .UriParameterParsingFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 26: return try .InvalidAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 27: return try .InvalidSocketAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 28: return try .InvalidPublicKey(
                message: FfiConverterString.read(from: &buf)
            )

        case 29: return try .InvalidSecretKey(
                message: FfiConverterString.read(from: &buf)
            )

        case 30: return try .InvalidOfferId(
                message: FfiConverterString.read(from: &buf)
            )

        case 31: return try .InvalidNodeId(
                message: FfiConverterString.read(from: &buf)
            )

        case 32: return try .InvalidPaymentId(
                message: FfiConverterString.read(from: &buf)
            )

        case 33: return try .InvalidPaymentHash(
                message: FfiConverterString.read(from: &buf)
            )

        case 34: return try .InvalidPaymentPreimage(
                message: FfiConverterString.read(from: &buf)
            )

        case 35: return try .InvalidPaymentSecret(
                message: FfiConverterString.read(from: &buf)
            )

        case 36: return try .InvalidAmount(
                message: FfiConverterString.read(from: &buf)
            )

        case 37: return try .InvalidInvoice(
                message: FfiConverterString.read(from: &buf)
            )

        case 38: return try .InvalidOffer(
                message: FfiConverterString.read(from: &buf)
            )

        case 39: return try .InvalidRefund(
                message: FfiConverterString.read(from: &buf)
            )

        case 40: return try .InvalidChannelId(
                message: FfiConverterString.read(from: &buf)
            )

        case 41: return try .InvalidNetwork(
                message: FfiConverterString.read(from: &buf)
            )

        case 42: return try .InvalidUri(
                message: FfiConverterString.read(from: &buf)
            )

        case 43: return try .InvalidQuantity(
                message: FfiConverterString.read(from: &buf)
            )

        case 44: return try .InvalidNodeAlias(
                message: FfiConverterString.read(from: &buf)
            )

        case 45: return try .DuplicatePayment(
                message: FfiConverterString.read(from: &buf)
            )

        case 46: return try .UnsupportedCurrency(
                message: FfiConverterString.read(from: &buf)
            )

        case 47: return try .InsufficientFunds(
                message: FfiConverterString.read(from: &buf)
            )

        case 48: return try .LiquiditySourceUnavailable(
                message: FfiConverterString.read(from: &buf)
            )

        case 49: return try .LiquidityFeeTooHigh(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeError, into buf: inout [UInt8]) {
        switch value {
        case .AlreadyRunning(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .NotRunning(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .OnchainTxCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .ConnectionFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvoiceCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .InvoiceRequestCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .OfferCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .RefundCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .PaymentSendingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .ProbeSendingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .ChannelCreationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .ChannelClosingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        case .ChannelConfigUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(13))
        case .PersistenceFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(14))
        case .FeerateEstimationUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(15))
        case .FeerateEstimationUpdateTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(16))
        case .WalletOperationFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(17))
        case .WalletOperationTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(18))
        case .OnchainTxSigningFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(19))
        case .TxSyncFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(20))
        case .TxSyncTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(21))
        case .GossipUpdateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(22))
        case .GossipUpdateTimeout(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(23))
        case .LiquidityRequestFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(24))
        case .UriParameterParsingFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(25))
        case .InvalidAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(26))
        case .InvalidSocketAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(27))
        case .InvalidPublicKey(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(28))
        case .InvalidSecretKey(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(29))
        case .InvalidOfferId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(30))
        case .InvalidNodeId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(31))
        case .InvalidPaymentId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(32))
        case .InvalidPaymentHash(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(33))
        case .InvalidPaymentPreimage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(34))
        case .InvalidPaymentSecret(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(35))
        case .InvalidAmount(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(36))
        case .InvalidInvoice(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(37))
        case .InvalidOffer(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(38))
        case .InvalidRefund(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(39))
        case .InvalidChannelId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(40))
        case .InvalidNetwork(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(41))
        case .InvalidUri(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(42))
        case .InvalidQuantity(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(43))
        case .InvalidNodeAlias(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(44))
        case .DuplicatePayment(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(45))
        case .UnsupportedCurrency(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(46))
        case .InsufficientFunds(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(47))
        case .LiquiditySourceUnavailable(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(48))
        case .LiquidityFeeTooHigh(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(49))
        }
    }
}

extension NodeError: Equatable, Hashable {}

extension NodeError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentDirection {
    case inbound
    case outbound
}

public struct FfiConverterTypePaymentDirection: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDirection

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDirection {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .inbound

        case 2: return .outbound

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDirection, into buf: inout [UInt8]) {
        switch value {
        case .inbound:
            writeInt(&buf, Int32(1))

        case .outbound:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypePaymentDirection_lift(_ buf: RustBuffer) throws -> PaymentDirection {
    return try FfiConverterTypePaymentDirection.lift(buf)
}

public func FfiConverterTypePaymentDirection_lower(_ value: PaymentDirection) -> RustBuffer {
    return FfiConverterTypePaymentDirection.lower(value)
}

extension PaymentDirection: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentFailureReason {
    case recipientRejected
    case userAbandoned
    case retriesExhausted
    case paymentExpired
    case routeNotFound
    case unexpectedError
    case unknownRequiredFeatures
    case invoiceRequestExpired
    case invoiceRequestRejected
}

public struct FfiConverterTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailureReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .recipientRejected

        case 2: return .userAbandoned

        case 3: return .retriesExhausted

        case 4: return .paymentExpired

        case 5: return .routeNotFound

        case 6: return .unexpectedError

        case 7: return .unknownRequiredFeatures

        case 8: return .invoiceRequestExpired

        case 9: return .invoiceRequestRejected

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentFailureReason, into buf: inout [UInt8]) {
        switch value {
        case .recipientRejected:
            writeInt(&buf, Int32(1))

        case .userAbandoned:
            writeInt(&buf, Int32(2))

        case .retriesExhausted:
            writeInt(&buf, Int32(3))

        case .paymentExpired:
            writeInt(&buf, Int32(4))

        case .routeNotFound:
            writeInt(&buf, Int32(5))

        case .unexpectedError:
            writeInt(&buf, Int32(6))

        case .unknownRequiredFeatures:
            writeInt(&buf, Int32(7))

        case .invoiceRequestExpired:
            writeInt(&buf, Int32(8))

        case .invoiceRequestRejected:
            writeInt(&buf, Int32(9))
        }
    }
}

public func FfiConverterTypePaymentFailureReason_lift(_ buf: RustBuffer) throws -> PaymentFailureReason {
    return try FfiConverterTypePaymentFailureReason.lift(buf)
}

public func FfiConverterTypePaymentFailureReason_lower(_ value: PaymentFailureReason) -> RustBuffer {
    return FfiConverterTypePaymentFailureReason.lower(value)
}

extension PaymentFailureReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentKind {
    case onchain
    case bolt11(
        hash: PaymentHash,
        preimage: PaymentPreimage?,
        secret: PaymentSecret?
    )
    case bolt11Jit(
        hash: PaymentHash,
        preimage: PaymentPreimage?,
        secret: PaymentSecret?,
        lspFeeLimits: LspFeeLimits
    )
    case bolt12Offer(
        hash: PaymentHash?,
        preimage: PaymentPreimage?,
        secret: PaymentSecret?,
        offerId: OfferId,
        payerNote: UntrustedString?,
        quantity: UInt64?
    )
    case bolt12Refund(
        hash: PaymentHash?,
        preimage: PaymentPreimage?,
        secret: PaymentSecret?,
        payerNote: UntrustedString?,
        quantity: UInt64?
    )
    case spontaneous(
        hash: PaymentHash,
        preimage: PaymentPreimage?
    )
}

public struct FfiConverterTypePaymentKind: FfiConverterRustBuffer {
    typealias SwiftType = PaymentKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .onchain

        case 2: return try .bolt11(
                hash: FfiConverterTypePaymentHash.read(from: &buf),
                preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf),
                secret: FfiConverterOptionTypePaymentSecret.read(from: &buf)
            )

        case 3: return try .bolt11Jit(
                hash: FfiConverterTypePaymentHash.read(from: &buf),
                preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf),
                secret: FfiConverterOptionTypePaymentSecret.read(from: &buf),
                lspFeeLimits: FfiConverterTypeLSPFeeLimits.read(from: &buf)
            )

        case 4: return try .bolt12Offer(
                hash: FfiConverterOptionTypePaymentHash.read(from: &buf),
                preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf),
                secret: FfiConverterOptionTypePaymentSecret.read(from: &buf),
                offerId: FfiConverterTypeOfferId.read(from: &buf),
                payerNote: FfiConverterOptionTypeUntrustedString.read(from: &buf),
                quantity: FfiConverterOptionUInt64.read(from: &buf)
            )

        case 5: return try .bolt12Refund(
                hash: FfiConverterOptionTypePaymentHash.read(from: &buf),
                preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf),
                secret: FfiConverterOptionTypePaymentSecret.read(from: &buf),
                payerNote: FfiConverterOptionTypeUntrustedString.read(from: &buf),
                quantity: FfiConverterOptionUInt64.read(from: &buf)
            )

        case 6: return try .spontaneous(
                hash: FfiConverterTypePaymentHash.read(from: &buf),
                preimage: FfiConverterOptionTypePaymentPreimage.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentKind, into buf: inout [UInt8]) {
        switch value {
        case .onchain:
            writeInt(&buf, Int32(1))

        case let .bolt11(hash, preimage, secret):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)

        case let .bolt11Jit(hash, preimage, secret, lspFeeLimits):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeLSPFeeLimits.write(lspFeeLimits, into: &buf)

        case let .bolt12Offer(hash, preimage, secret, offerId, payerNote, quantity):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterTypeOfferId.write(offerId, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)

        case let .bolt12Refund(hash, preimage, secret, payerNote, quantity):
            writeInt(&buf, Int32(5))
            FfiConverterOptionTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
            FfiConverterOptionTypePaymentSecret.write(secret, into: &buf)
            FfiConverterOptionTypeUntrustedString.write(payerNote, into: &buf)
            FfiConverterOptionUInt64.write(quantity, into: &buf)

        case let .spontaneous(hash, preimage):
            writeInt(&buf, Int32(6))
            FfiConverterTypePaymentHash.write(hash, into: &buf)
            FfiConverterOptionTypePaymentPreimage.write(preimage, into: &buf)
        }
    }
}

public func FfiConverterTypePaymentKind_lift(_ buf: RustBuffer) throws -> PaymentKind {
    return try FfiConverterTypePaymentKind.lift(buf)
}

public func FfiConverterTypePaymentKind_lower(_ value: PaymentKind) -> RustBuffer {
    return FfiConverterTypePaymentKind.lower(value)
}

extension PaymentKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentStatus {
    case pending
    case succeeded
    case failed
}

public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .pending

        case 2: return .succeeded

        case 3: return .failed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        case .pending:
            writeInt(&buf, Int32(1))

        case .succeeded:
            writeInt(&buf, Int32(2))

        case .failed:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}

extension PaymentStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PendingSweepBalance {
    case pendingBroadcast(
        channelId: ChannelId?,
        amountSatoshis: UInt64
    )
    case broadcastAwaitingConfirmation(
        channelId: ChannelId?,
        latestBroadcastHeight: UInt32,
        latestSpendingTxid: Txid,
        amountSatoshis: UInt64
    )
    case awaitingThresholdConfirmations(
        channelId: ChannelId?,
        latestSpendingTxid: Txid,
        confirmationHash: BlockHash,
        confirmationHeight: UInt32,
        amountSatoshis: UInt64
    )
}

public struct FfiConverterTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = PendingSweepBalance

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingSweepBalance {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .pendingBroadcast(
                channelId: FfiConverterOptionTypeChannelId.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .broadcastAwaitingConfirmation(
                channelId: FfiConverterOptionTypeChannelId.read(from: &buf),
                latestBroadcastHeight: FfiConverterUInt32.read(from: &buf),
                latestSpendingTxid: FfiConverterTypeTxid.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf)
            )

        case 3: return try .awaitingThresholdConfirmations(
                channelId: FfiConverterOptionTypeChannelId.read(from: &buf),
                latestSpendingTxid: FfiConverterTypeTxid.read(from: &buf),
                confirmationHash: FfiConverterTypeBlockHash.read(from: &buf),
                confirmationHeight: FfiConverterUInt32.read(from: &buf),
                amountSatoshis: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PendingSweepBalance, into buf: inout [UInt8]) {
        switch value {
        case let .pendingBroadcast(channelId, amountSatoshis):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)

        case let .broadcastAwaitingConfirmation(channelId, latestBroadcastHeight, latestSpendingTxid, amountSatoshis):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterUInt32.write(latestBroadcastHeight, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)

        case let .awaitingThresholdConfirmations(channelId, latestSpendingTxid, confirmationHash, confirmationHeight, amountSatoshis):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeChannelId.write(channelId, into: &buf)
            FfiConverterTypeTxid.write(latestSpendingTxid, into: &buf)
            FfiConverterTypeBlockHash.write(confirmationHash, into: &buf)
            FfiConverterUInt32.write(confirmationHeight, into: &buf)
            FfiConverterUInt64.write(amountSatoshis, into: &buf)
        }
    }
}

public func FfiConverterTypePendingSweepBalance_lift(_ buf: RustBuffer) throws -> PendingSweepBalance {
    return try FfiConverterTypePendingSweepBalance.lift(buf)
}

public func FfiConverterTypePendingSweepBalance_lower(_ value: PendingSweepBalance) -> RustBuffer {
    return FfiConverterTypePendingSweepBalance.lower(value)
}

extension PendingSweepBalance: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum QrPaymentResult {
    case onchain(
        txid: Txid
    )
    case bolt11(
        paymentId: PaymentId
    )
    case bolt12(
        paymentId: PaymentId
    )
}

public struct FfiConverterTypeQrPaymentResult: FfiConverterRustBuffer {
    typealias SwiftType = QrPaymentResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrPaymentResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .onchain(
                txid: FfiConverterTypeTxid.read(from: &buf)
            )

        case 2: return try .bolt11(
                paymentId: FfiConverterTypePaymentId.read(from: &buf)
            )

        case 3: return try .bolt12(
                paymentId: FfiConverterTypePaymentId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrPaymentResult, into buf: inout [UInt8]) {
        switch value {
        case let .onchain(txid):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTxid.write(txid, into: &buf)

        case let .bolt11(paymentId):
            writeInt(&buf, Int32(2))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)

        case let .bolt12(paymentId):
            writeInt(&buf, Int32(3))
            FfiConverterTypePaymentId.write(paymentId, into: &buf)
        }
    }
}

public func FfiConverterTypeQrPaymentResult_lift(_ buf: RustBuffer) throws -> QrPaymentResult {
    return try FfiConverterTypeQrPaymentResult.lift(buf)
}

public func FfiConverterTypeQrPaymentResult_lower(_ value: QrPaymentResult) -> RustBuffer {
    return FfiConverterTypeQrPaymentResult.lower(value)
}

extension QrPaymentResult: Equatable, Hashable {}

private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAnchorChannelsConfig: FfiConverterRustBuffer {
    typealias SwiftType = AnchorChannelsConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAnchorChannelsConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAnchorChannelsConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeChannelConfig: FfiConverterRustBuffer {
    typealias SwiftType = ChannelConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeChannelInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeChannelUpdateInfo: FfiConverterRustBuffer {
    typealias SwiftType = ChannelUpdateInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelUpdateInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelUpdateInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeEsploraSyncConfig: FfiConverterRustBuffer {
    typealias SwiftType = EsploraSyncConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEsploraSyncConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEsploraSyncConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeNodeAnnouncementInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeAnnouncementInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAnnouncementInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAnnouncementInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeNodeInfo: FfiConverterRustBuffer {
    typealias SwiftType = NodeInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeOutPoint: FfiConverterRustBuffer {
    typealias SwiftType = OutPoint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutPoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutPoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSendingParameters: FfiConverterRustBuffer {
    typealias SwiftType = SendingParameters?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendingParameters.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendingParameters.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeClosureReason: FfiConverterRustBuffer {
    typealias SwiftType = ClosureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeClosureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeClosureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEvent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEvent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeMaxTotalRoutingFeeLimit: FfiConverterRustBuffer {
    typealias SwiftType = MaxTotalRoutingFeeLimit?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMaxTotalRoutingFeeLimit.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMaxTotalRoutingFeeLimit.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentFailureReason: FfiConverterRustBuffer {
    typealias SwiftType = PaymentFailureReason?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentFailureReason.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentFailureReason.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeSocketAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeSocketAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeChannelId: FfiConverterRustBuffer {
    typealias SwiftType = ChannelId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChannelId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChannelId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeNodeAlias: FfiConverterRustBuffer {
    typealias SwiftType = NodeAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentHash: FfiConverterRustBuffer {
    typealias SwiftType = PaymentHash?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentHash.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentHash.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentId: FfiConverterRustBuffer {
    typealias SwiftType = PaymentId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentPreimage: FfiConverterRustBuffer {
    typealias SwiftType = PaymentPreimage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentPreimage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentPreimage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePaymentSecret: FfiConverterRustBuffer {
    typealias SwiftType = PaymentSecret?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePaymentSecret.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePaymentSecret.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeUntrustedString: FfiConverterRustBuffer {
    typealias SwiftType = UntrustedString?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUntrustedString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUntrustedString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeChannelDetails: FfiConverterRustBuffer {
    typealias SwiftType = [ChannelDetails]

    public static func write(_ value: [ChannelDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChannelDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChannelDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChannelDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeChannelDetails.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentDetails]

    public static func write(_ value: [PaymentDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePaymentDetails.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePeerDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PeerDetails]

    public static func write(_ value: [PeerDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePeerDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PeerDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PeerDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePeerDetails.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLightningBalance: FfiConverterRustBuffer {
    typealias SwiftType = [LightningBalance]

    public static func write(_ value: [LightningBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLightningBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LightningBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [LightningBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLightningBalance.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePendingSweepBalance: FfiConverterRustBuffer {
    typealias SwiftType = [PendingSweepBalance]

    public static func write(_ value: [PendingSweepBalance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePendingSweepBalance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PendingSweepBalance] {
        let len: Int32 = try readInt(&buf)
        var seq = [PendingSweepBalance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePendingSweepBalance.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNodeId: FfiConverterRustBuffer {
    typealias SwiftType = [NodeId]

    public static func write(_ value: [NodeId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNodeId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSocketAddress: FfiConverterRustBuffer {
    typealias SwiftType = [SocketAddress]

    public static func write(_ value: [SocketAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSocketAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SocketAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [SocketAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSocketAddress.read(from: &buf))
        }
        return seq
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Address = String
public struct FfiConverterTypeAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Address {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Address) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeAddress_lift(_ value: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(value)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BlockHash = String
public struct FfiConverterTypeBlockHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BlockHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BlockHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BlockHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBlockHash_lift(_ value: RustBuffer) throws -> BlockHash {
    return try FfiConverterTypeBlockHash.lift(value)
}

public func FfiConverterTypeBlockHash_lower(_ value: BlockHash) -> RustBuffer {
    return FfiConverterTypeBlockHash.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bolt11Invoice = String
public struct FfiConverterTypeBolt11Invoice: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt11Invoice {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bolt11Invoice, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bolt11Invoice {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bolt11Invoice) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBolt11Invoice_lift(_ value: RustBuffer) throws -> Bolt11Invoice {
    return try FfiConverterTypeBolt11Invoice.lift(value)
}

public func FfiConverterTypeBolt11Invoice_lower(_ value: Bolt11Invoice) -> RustBuffer {
    return FfiConverterTypeBolt11Invoice.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bolt12Invoice = String
public struct FfiConverterTypeBolt12Invoice: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bolt12Invoice {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bolt12Invoice, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bolt12Invoice {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bolt12Invoice) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBolt12Invoice_lift(_ value: RustBuffer) throws -> Bolt12Invoice {
    return try FfiConverterTypeBolt12Invoice.lift(value)
}

public func FfiConverterTypeBolt12Invoice_lower(_ value: Bolt12Invoice) -> RustBuffer {
    return FfiConverterTypeBolt12Invoice.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ChannelId = String
public struct FfiConverterTypeChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeChannelId_lift(_ value: RustBuffer) throws -> ChannelId {
    return try FfiConverterTypeChannelId.lift(value)
}

public func FfiConverterTypeChannelId_lower(_ value: ChannelId) -> RustBuffer {
    return FfiConverterTypeChannelId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Mnemonic = String
public struct FfiConverterTypeMnemonic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Mnemonic {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Mnemonic) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeMnemonic_lift(_ value: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(value)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeAlias = String
public struct FfiConverterTypeNodeAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeNodeAlias_lift(_ value: RustBuffer) throws -> NodeAlias {
    return try FfiConverterTypeNodeAlias.lift(value)
}

public func FfiConverterTypeNodeAlias_lower(_ value: NodeAlias) -> RustBuffer {
    return FfiConverterTypeNodeAlias.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NodeId = String
public struct FfiConverterTypeNodeId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> NodeId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: NodeId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeNodeId_lift(_ value: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(value)
}

public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Offer = String
public struct FfiConverterTypeOffer: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Offer {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Offer, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Offer {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Offer) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeOffer_lift(_ value: RustBuffer) throws -> Offer {
    return try FfiConverterTypeOffer.lift(value)
}

public func FfiConverterTypeOffer_lower(_ value: Offer) -> RustBuffer {
    return FfiConverterTypeOffer.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias OfferId = String
public struct FfiConverterTypeOfferId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OfferId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: OfferId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> OfferId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: OfferId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeOfferId_lift(_ value: RustBuffer) throws -> OfferId {
    return try FfiConverterTypeOfferId.lift(value)
}

public func FfiConverterTypeOfferId_lower(_ value: OfferId) -> RustBuffer {
    return FfiConverterTypeOfferId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentHash = String
public struct FfiConverterTypePaymentHash: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentHash {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentHash, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentHash {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentHash) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypePaymentHash_lift(_ value: RustBuffer) throws -> PaymentHash {
    return try FfiConverterTypePaymentHash.lift(value)
}

public func FfiConverterTypePaymentHash_lower(_ value: PaymentHash) -> RustBuffer {
    return FfiConverterTypePaymentHash.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentId = String
public struct FfiConverterTypePaymentId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypePaymentId_lift(_ value: RustBuffer) throws -> PaymentId {
    return try FfiConverterTypePaymentId.lift(value)
}

public func FfiConverterTypePaymentId_lower(_ value: PaymentId) -> RustBuffer {
    return FfiConverterTypePaymentId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentPreimage = String
public struct FfiConverterTypePaymentPreimage: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentPreimage {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentPreimage, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentPreimage {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentPreimage) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypePaymentPreimage_lift(_ value: RustBuffer) throws -> PaymentPreimage {
    return try FfiConverterTypePaymentPreimage.lift(value)
}

public func FfiConverterTypePaymentPreimage_lower(_ value: PaymentPreimage) -> RustBuffer {
    return FfiConverterTypePaymentPreimage.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PaymentSecret = String
public struct FfiConverterTypePaymentSecret: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentSecret {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PaymentSecret, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PaymentSecret {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PaymentSecret) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypePaymentSecret_lift(_ value: RustBuffer) throws -> PaymentSecret {
    return try FfiConverterTypePaymentSecret.lift(value)
}

public func FfiConverterTypePaymentSecret_lower(_ value: PaymentSecret) -> RustBuffer {
    return FfiConverterTypePaymentSecret.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PublicKey = String
public struct FfiConverterTypePublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PublicKey {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PublicKey) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypePublicKey_lift(_ value: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(value)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Refund = String
public struct FfiConverterTypeRefund: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Refund {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Refund, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Refund {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Refund) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRefund_lift(_ value: RustBuffer) throws -> Refund {
    return try FfiConverterTypeRefund.lift(value)
}

public func FfiConverterTypeRefund_lower(_ value: Refund) -> RustBuffer {
    return FfiConverterTypeRefund.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SocketAddress = String
public struct FfiConverterTypeSocketAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SocketAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: SocketAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SocketAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: SocketAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeSocketAddress_lift(_ value: RustBuffer) throws -> SocketAddress {
    return try FfiConverterTypeSocketAddress.lift(value)
}

public func FfiConverterTypeSocketAddress_lower(_ value: SocketAddress) -> RustBuffer {
    return FfiConverterTypeSocketAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Txid = String
public struct FfiConverterTypeTxid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Txid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Txid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Txid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Txid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeTxid_lift(_ value: RustBuffer) throws -> Txid {
    return try FfiConverterTypeTxid.lift(value)
}

public func FfiConverterTypeTxid_lower(_ value: Txid) -> RustBuffer {
    return FfiConverterTypeTxid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UntrustedString = String
public struct FfiConverterTypeUntrustedString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UntrustedString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UntrustedString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UntrustedString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UntrustedString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeUntrustedString_lift(_ value: RustBuffer) throws -> UntrustedString {
    return try FfiConverterTypeUntrustedString.lift(value)
}

public func FfiConverterTypeUntrustedString_lower(_ value: UntrustedString) -> RustBuffer {
    return FfiConverterTypeUntrustedString.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias UserChannelId = String
public struct FfiConverterTypeUserChannelId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserChannelId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: UserChannelId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> UserChannelId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: UserChannelId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeUserChannelId_lift(_ value: RustBuffer) throws -> UserChannelId {
    return try FfiConverterTypeUserChannelId.lift(value)
}

public func FfiConverterTypeUserChannelId_lower(_ value: UserChannelId) -> RustBuffer {
    return FfiConverterTypeUserChannelId.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UnsafeMutableRawPointer,
    pollFunc: (UnsafeMutableRawPointer, @escaping UniFfiRustFutureContinuation, UnsafeMutableRawPointer) -> Void,
    completeFunc: (UnsafeMutableRawPointer, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UnsafeMutableRawPointer) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(rustFuture, uniffiFutureContinuationCallback, ContinuationHolder($0).toOpaque())
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(ptr: UnsafeMutableRawPointer, pollResult: Int8) {
    ContinuationHolder.fromOpaque(ptr).resume(pollResult)
}

// Wraps UnsafeContinuation in a class so that we can use reference counting when passing it across
// the FFI
private class ContinuationHolder {
    let continuation: UnsafeContinuation<Int8, Never>

    init(_ continuation: UnsafeContinuation<Int8, Never>) {
        self.continuation = continuation
    }

    func resume(_ pollResult: Int8) {
        continuation.resume(returning: pollResult)
    }

    func toOpaque() -> UnsafeMutableRawPointer {
        return Unmanaged<ContinuationHolder>.passRetained(self).toOpaque()
    }

    static func fromOpaque(_ ptr: UnsafeRawPointer) -> ContinuationHolder {
        return Unmanaged<ContinuationHolder>.fromOpaque(ptr).takeRetainedValue()
    }
}

public func defaultConfig() -> Config {
    return try! FfiConverterTypeConfig.lift(
        try! rustCall {
            uniffi_ldk_node_fn_func_default_config($0)
        }
    )
}

public func generateEntropyMnemonic() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(
        try! rustCall {
            uniffi_ldk_node_fn_func_generate_entropy_mnemonic($0)
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ldk_node_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_ldk_node_checksum_func_default_config() != 55381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_func_generate_entropy_mnemonic() != 59926 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash() != 52848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash() != 24516 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive() != 28084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash() != 3869 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount() != 51453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash() != 21975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel() != 58617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel() != 50555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send() != 39133 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_probes() != 39625 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount() != 25010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount() != 19557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund() != 38039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_receive() != 15049 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount() != 7279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment() != 61945 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_send() != 56449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount() != 26006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build() != 785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_build_with_fs_store() != 61304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora() != 1781 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic() != 827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes() != 44799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path() != 64056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p() != 9279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs() != 64312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2() != 2667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_listening_addresses() != 14051 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_network() != 27539 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_node_alias() != 18342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_builder_set_storage_dir_path() != 59019 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_channel() != 38070 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_list_channels() != 4693 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_list_nodes() != 36715 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_networkgraph_node() != 48925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_bolt11_payment() != 41402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_bolt12_payment() != 49254 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_close_channel() != 62479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_config() != 7511 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_connect() != 34120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_disconnect() != 43538 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_event_handled() != 47939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_force_close_channel() != 48831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_get_balance_test() != 51529 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_balances() != 57528 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_channels() != 7954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_payments() != 35002 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_list_peers() != 14889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_listening_addresses() != 2665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_network_graph() != 2695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_next_event() != 7682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_next_event_async() != 25426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_node_alias() != 29526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_node_id() != 51489 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_onchain_payment() != 6092 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_open_announced_channel() != 36623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_open_channel() != 40283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_payment() != 60296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_remove_payment() != 47952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_sign_message() != 49319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_spontaneous_payment() != 37403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_start() != 58480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_status() != 55952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_stop() != 42188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_sync_wallets() != 32474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_unified_qr_payment() != 9837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_update_channel_config() != 37852 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_verify_signature() != 20486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_node_wait_next_event() != 55101 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_new_address() != 37251 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address() != 20046 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_onchainpayment_send_to_address() != 55731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send() != 48210 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes() != 25937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_unifiedqrpayment_receive() != 913 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_method_unifiedqrpayment_send() != 53900 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_builder_from_config() != 64393 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_ldk_node_checksum_constructor_builder_new() != 48442 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
