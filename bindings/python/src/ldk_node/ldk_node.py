

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_ldk_node_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_ldk_node_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_ldk_node_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("ldk_node")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_ldk_node_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_ldk_node_checksum_func_battery_saving_sync_intervals() != 25473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_func_default_config() != 55381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_func_derive_node_secret_from_mnemonic() != 15067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_func_generate_entropy_mnemonic() != 48014:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_amount_milli_satoshis() != 50823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_currency() != 32179:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_expiry_time_seconds() != 23625:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_fallback_addresses() != 55276:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_invoice_description() != 395:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_is_expired() != 15932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_min_final_cltv_expiry_delta() != 8855:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_network() != 10420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_hash() != 42571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_secret() != 26081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_recover_payee_pub_key() != 18874:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_route_hints() != 63051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_since_epoch() != 53979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_until_expiry() != 64193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_signable_hash() != 30910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11invoice_would_expire() != 30331:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash() != 52848:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees() != 5123:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees_using_amount() != 46411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash() != 24516:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive() != 6073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash() != 27050:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount() != 4893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash() != 1402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel() != 24506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash() != 38025:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel() != 16532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel_for_hash() != 1143:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_send() != 12953:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes() != 19286:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount() != 5976:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount() != 42793:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_absolute_expiry_seconds() != 28589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_amount() != 5213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_amount_msats() != 9297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_chain() != 3308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_created_at() != 56866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_encode() != 13200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_fallback_addresses() != 7925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_invoice_description() != 1713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_is_expired() != 39560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer() != 65270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer_signing_pubkey() != 55411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_metadata() != 37374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_offer_chains() != 39622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_note() != 28018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_signing_pubkey() != 12798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_payment_hash() != 63778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_quantity() != 43105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_relative_expiry() != 14024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_signable_hash() != 39303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12invoice_signing_pubkey() != 35202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_blinded_paths_for_async_recipient() != 14695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund() != 15019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_receive() != 59252:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_receive_async() != 23867:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount() != 35484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment() != 43248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_send() != 27679:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount() != 33255:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_bolt12payment_set_paths_to_static_invoice_server() != 20921:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_build() != 785:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_build_with_fs_store() != 61304:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store() != 2871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_fixed_headers() != 24910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_header_provider() != 9090:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_announcement_addresses() != 39271:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_async_payments_role() != 16463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rest() != 37382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rpc() != 2111:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_chain_source_electrum() != 55552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora() != 1781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_channel_data_migration() != 58453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_custom_logger() != 51232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic() != 827:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes() != 44799:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path() != 64056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_filesystem_logger() != 10249:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p() != 9279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs() != 64312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps1() != 51527:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2() != 14430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_listening_addresses() != 14051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_log_facade_logger() != 58410:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_network() != 27539:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_node_alias() != 18342:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_pathfinding_scores_source() != 63501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_builder_set_storage_dir_path() != 59019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_kwu() != 58911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_ceil() != 58575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_floor() != 59617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_lsps1liquidity_check_order_status() != 48853:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_lsps1liquidity_request_channel() != 5951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_logwriter_log() != 3299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_networkgraph_channel() != 38070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_networkgraph_list_channels() != 4693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_networkgraph_list_nodes() != 36715:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_networkgraph_node() != 48925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_announcement_addresses() != 61426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_bolt11_payment() != 41402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_bolt12_payment() != 49254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_close_channel() != 62479:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_config() != 7511:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_connect() != 34120:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_current_sync_intervals() != 51918:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_disconnect() != 43538:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_event_handled() != 38712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_export_pathfinding_scores() != 62331:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_force_close_channel() != 48831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_get_address_balance() != 45284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_get_transaction_details() != 65000:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_list_balances() != 57528:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_list_channels() != 7954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_list_payments() != 35002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_list_peers() != 14889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_listening_addresses() != 2665:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_lsps1_liquidity() != 5633:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_network_graph() != 2695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_next_event() != 7682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_next_event_async() != 25426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_node_alias() != 29526:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_node_id() != 51489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_onchain_payment() != 6092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_open_announced_channel() != 36623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_open_channel() != 40283:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_payment() != 60296:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_remove_payment() != 47952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_sign_message() != 49319:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_splice_in() != 46431:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_splice_out() != 22115:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_spontaneous_payment() != 37403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_start() != 58480:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_status() != 55952:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_stop() != 42188:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_sync_wallets() != 32474:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_unified_qr_payment() != 9837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_update_channel_config() != 37852:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_update_sync_intervals() != 42322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_verify_signature() != 20486:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_node_wait_next_event() != 55101:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_absolute_expiry_seconds() != 22836:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_amount() != 59890:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_chains() != 59522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_expects_quantity() != 58457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_id() != 8391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_is_expired() != 22651:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_is_valid_quantity() != 58469:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_issuer() != 41632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_issuer_signing_pubkey() != 38162:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_metadata() != 18979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_offer_description() != 11122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_offer_supports_chain() != 2135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_accelerate_by_cpfp() != 31954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_bump_fee_by_rbf() != 53877:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_cpfp_fee_rate() != 32879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_total_fee() != 57218:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_list_spendable_outputs() != 19144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_new_address() != 37251:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_select_utxos_with_algorithm() != 14084:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address() != 37748:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_onchainpayment_send_to_address() != 28826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_absolute_expiry_seconds() != 43722:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_amount_msats() != 26467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_chain() != 36565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_is_expired() != 10232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_issuer() != 40306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_payer_metadata() != 23501:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_payer_note() != 47799:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_payer_signing_pubkey() != 40880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_quantity() != 15192:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_refund_refund_description() != 39295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_spontaneouspayment_send() != 27905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes() != 25937:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_custom_tlvs() != 17876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage() != 30854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage_and_custom_tlvs() != 12104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_unifiedqrpayment_receive() != 913:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_unifiedqrpayment_send() != 28285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_method_vssheaderprovider_get_headers() != 7788:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_bolt11invoice_from_str() != 349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_bolt12invoice_from_str() != 22276:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_builder_from_config() != 994:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_builder_new() != 40499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_kwu() != 50548:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_vb_unchecked() != 41808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_offer_from_str() != 37070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ldk_node_checksum_constructor_refund_from_str() != 64884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_LOG_WRITER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_VSS_HEADER_PROVIDER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
class _UniffiVTableCallbackInterfaceLogWriter(ctypes.Structure):
    _fields_ = [
        ("log", _UNIFFI_CALLBACK_INTERFACE_LOG_WRITER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceVssHeaderProvider(ctypes.Structure):
    _fields_ = [
        ("get_headers", _UNIFFI_CALLBACK_INTERFACE_VSS_HEADER_PROVIDER_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_ldk_node_fn_clone_bolt11invoice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_bolt11invoice.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_bolt11invoice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_bolt11invoice.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_bolt11invoice_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_bolt11invoice_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_amount_milli_satoshis.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_amount_milli_satoshis.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_currency.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_currency.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_expiry_time_seconds.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_expiry_time_seconds.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_fallback_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_fallback_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_invoice_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_invoice_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_min_final_cltv_expiry_delta.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_min_final_cltv_expiry_delta.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_network.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_secret.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_recover_payee_pub_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_recover_payee_pub_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_route_hints.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_route_hints.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_since_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_since_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_until_expiry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_until_expiry.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_signable_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_signable_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_would_expire.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_would_expire.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_clone_bolt11payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_bolt11payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_bolt11payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_bolt11payment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees_using_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees_using_amount.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel_for_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel_for_hash.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_using_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_using_amount.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_bolt12invoice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_bolt12invoice.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_bolt12invoice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_bolt12invoice.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_bolt12invoice_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_bolt12invoice_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_absolute_expiry_seconds.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_absolute_expiry_seconds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount_msats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount_msats.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_chain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_chain.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_created_at.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_created_at.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_encode.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_fallback_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_fallback_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_invoice_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_invoice_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer_signing_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer_signing_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_offer_chains.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_offer_chains.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_note.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_note.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_signing_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_signing_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payment_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payment_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_quantity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_quantity.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_relative_expiry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_relative_expiry.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signable_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signable_hash.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signing_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signing_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_bolt12payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_bolt12payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_bolt12payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_bolt12payment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_blinded_paths_for_async_recipient.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_blinded_paths_for_async_recipient.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_initiate_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint32,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_initiate_refund.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_async.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_async.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send_using_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send_using_amount.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_set_paths_to_static_invoice_server.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_set_paths_to_static_invoice_server.restype = None
_UniffiLib.uniffi_ldk_node_fn_clone_builder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_builder.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_builder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_builder.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_builder_from_config.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_builder_from_config.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_constructor_builder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_builder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_fs_store.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_fs_store.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_fixed_headers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_fixed_headers.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_header_provider.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_header_provider.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_announcement_addresses.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_announcement_addresses.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_async_payments_role.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_async_payments_role.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rest.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint16,
    _UniffiRustBuffer,
    ctypes.c_uint16,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rest.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rpc.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint16,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rpc.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_electrum.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_electrum.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_esplora.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_esplora.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_channel_data_migration.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_channel_data_migration.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_custom_logger.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_custom_logger.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_path.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_path.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_filesystem_logger.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_filesystem_logger.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps1.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps1.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_listening_addresses.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_listening_addresses.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_log_facade_logger.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_log_facade_logger.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_network.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_network.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_node_alias.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_node_alias.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_pathfinding_scores_source.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_pathfinding_scores_source.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_storage_dir_path.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_builder_set_storage_dir_path.restype = None
_UniffiLib.uniffi_ldk_node_fn_clone_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_feerate.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_feerate.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_kwu.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_kwu.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_vb_unchecked.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_vb_unchecked.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_kwu.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_kwu.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_ceil.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_ceil.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_floor.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_clone_lsps1liquidity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_lsps1liquidity.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_lsps1liquidity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_lsps1liquidity.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_check_order_status.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_check_order_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_request_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint32,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_request_channel.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_logwriter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_logwriter.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_logwriter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_logwriter.restype = None
_UniffiLib.uniffi_ldk_node_fn_init_callback_vtable_logwriter.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceLogWriter),
)
_UniffiLib.uniffi_ldk_node_fn_init_callback_vtable_logwriter.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_logwriter_log.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_logwriter_log.restype = None
_UniffiLib.uniffi_ldk_node_fn_clone_networkgraph.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_networkgraph.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_networkgraph.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_networkgraph.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_channel.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_channel.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_channels.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_nodes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_nodes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_node.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_node.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_node.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_node.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_announcement_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_announcement_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_bolt11_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_bolt11_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_bolt12_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_bolt12_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_close_channel.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_close_channel.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_config.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_connect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_connect.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_current_sync_intervals.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_current_sync_intervals.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_disconnect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_disconnect.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_event_handled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_event_handled.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_export_pathfinding_scores.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_export_pathfinding_scores.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_force_close_channel.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_force_close_channel.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_get_address_balance.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_get_address_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_node_get_transaction_details.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_get_transaction_details.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_list_balances.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_list_balances.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_list_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_list_channels.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_list_payments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_list_payments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_list_peers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_list_peers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_listening_addresses.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_listening_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_lsps1_liquidity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_lsps1_liquidity.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_network_graph.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_network_graph.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_next_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_next_event.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_next_event_async.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ldk_node_fn_method_node_next_event_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_node_node_alias.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_node_alias.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_node_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_onchain_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_onchain_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_open_announced_channel.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_open_announced_channel.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_open_channel.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_open_channel.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_remove_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_remove_payment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_sign_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_sign_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_splice_in.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_splice_in.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_splice_out.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_splice_out.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_spontaneous_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_spontaneous_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_start.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_status.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_status.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_node_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_stop.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_sync_wallets.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_sync_wallets.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_unified_qr_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_unified_qr_payment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_node_update_channel_config.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_update_channel_config.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_update_sync_intervals.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_update_sync_intervals.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_node_verify_signature.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_verify_signature.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_node_wait_next_event.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_node_wait_next_event.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_offer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_offer.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_offer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_offer.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_offer_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_offer_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_offer_absolute_expiry_seconds.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_absolute_expiry_seconds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_amount.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_chains.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_chains.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_expects_quantity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_expects_quantity.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_offer_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_offer_is_valid_quantity.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_is_valid_quantity.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer_signing_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer_signing_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_offer_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_offer_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_supports_chain.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_supports_chain.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_clone_onchainpayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_onchainpayment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_onchainpayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_onchainpayment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_accelerate_by_cpfp.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_accelerate_by_cpfp.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_bump_fee_by_rbf.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_bump_fee_by_rbf.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_cpfp_fee_rate.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_cpfp_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_total_fee.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_total_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_list_spendable_outputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_list_spendable_outputs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_new_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_new_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_select_utxos_with_algorithm.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_select_utxos_with_algorithm.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_to_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_to_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_refund.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_refund.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_refund.restype = None
_UniffiLib.uniffi_ldk_node_fn_constructor_refund_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_constructor_refund_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_method_refund_absolute_expiry_seconds.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_absolute_expiry_seconds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_amount_msats.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_amount_msats.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_method_refund_chain.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_chain.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_is_expired.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_is_expired.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_refund_issuer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_issuer.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_metadata.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_note.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_note.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_signing_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_signing_pubkey.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_quantity.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_quantity.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_refund_description.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_refund_description.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_debug.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_debug.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_ldk_node_fn_clone_spontaneouspayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_spontaneouspayment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_spontaneouspayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_spontaneouspayment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_probes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_probes.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_custom_tlvs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_custom_tlvs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage_and_custom_tlvs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage_and_custom_tlvs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_unifiedqrpayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_unifiedqrpayment.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_unifiedqrpayment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_unifiedqrpayment.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_receive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_receive.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_clone_vssheaderprovider.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_clone_vssheaderprovider.restype = ctypes.c_void_p
_UniffiLib.uniffi_ldk_node_fn_free_vssheaderprovider.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_free_vssheaderprovider.restype = None
_UniffiLib.uniffi_ldk_node_fn_method_vssheaderprovider_get_headers.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ldk_node_fn_method_vssheaderprovider_get_headers.restype = ctypes.c_uint64
_UniffiLib.uniffi_ldk_node_fn_func_battery_saving_sync_intervals.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_func_battery_saving_sync_intervals.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_func_default_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_func_default_config.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_func_derive_node_secret_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_func_derive_node_secret_from_mnemonic.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ldk_node_fn_func_generate_entropy_mnemonic.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ldk_node_fn_func_generate_entropy_mnemonic.restype = _UniffiRustBuffer
_UniffiLib.ffi_ldk_node_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_ldk_node_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_ldk_node_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rustbuffer_free.restype = None
_UniffiLib.ffi_ldk_node_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_ldk_node_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_u8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_u8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_ldk_node_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_i8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_i8.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_ldk_node_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_u16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_u16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_ldk_node_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_i16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_i16.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_ldk_node_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_u32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_u32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_ldk_node_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_i32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_i32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_ldk_node_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_u64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_u64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_ldk_node_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_i64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_i64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_ldk_node_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_f32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_f32.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_ldk_node_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_f64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_f64.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_ldk_node_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_pointer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_ldk_node_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_ldk_node_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_poll_void.restype = None
_UniffiLib.ffi_ldk_node_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_cancel_void.restype = None
_UniffiLib.ffi_ldk_node_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ldk_node_rust_future_free_void.restype = None
_UniffiLib.ffi_ldk_node_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ldk_node_rust_future_complete_void.restype = None
_UniffiLib.uniffi_ldk_node_checksum_func_battery_saving_sync_intervals.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_func_battery_saving_sync_intervals.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_func_default_config.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_func_default_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_func_derive_node_secret_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_func_derive_node_secret_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_func_generate_entropy_mnemonic.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_func_generate_entropy_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_amount_milli_satoshis.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_amount_milli_satoshis.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_currency.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_currency.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_expiry_time_seconds.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_expiry_time_seconds.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_fallback_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_fallback_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_invoice_description.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_invoice_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_is_expired.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_min_final_cltv_expiry_delta.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_min_final_cltv_expiry_delta.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_network.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_secret.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_payment_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_recover_payee_pub_key.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_recover_payee_pub_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_route_hints.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_route_hints.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_since_epoch.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_since_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_until_expiry.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_seconds_until_expiry.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_signable_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_signable_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_would_expire.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11invoice_would_expire.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_claim_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees_using_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_estimate_routing_fees_using_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_fail_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel_for_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_receive_via_jit_channel_for_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_probes_using_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt11payment_send_using_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_absolute_expiry_seconds.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_absolute_expiry_seconds.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_amount_msats.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_amount_msats.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_chain.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_chain.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_created_at.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_created_at.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_encode.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_fallback_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_fallback_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_invoice_description.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_invoice_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_is_expired.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer_signing_pubkey.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_issuer_signing_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_metadata.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_offer_chains.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_offer_chains.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_note.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_signing_pubkey.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payer_signing_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payment_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_payment_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_quantity.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_quantity.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_relative_expiry.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_relative_expiry.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_signable_hash.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_signable_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_signing_pubkey.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12invoice_signing_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_blinded_paths_for_async_recipient.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_blinded_paths_for_async_recipient.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_initiate_refund.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive_async.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_receive_variable_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_request_refund_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_send.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_send_using_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_set_paths_to_static_invoice_server.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_bolt12payment_set_paths_to_static_invoice_server.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_fs_store.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_fs_store.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_fixed_headers.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_fixed_headers.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_header_provider.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_build_with_vss_store_and_header_provider.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_announcement_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_announcement_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_async_payments_role.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_async_payments_role.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rest.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rest.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rpc.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_bitcoind_rpc.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_electrum.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_electrum.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_chain_source_esplora.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_channel_data_migration.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_channel_data_migration.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_custom_logger.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_custom_logger.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_bip39_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_entropy_seed_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_filesystem_logger.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_filesystem_logger.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_p2p.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_gossip_source_rgs.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps1.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps1.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_liquidity_source_lsps2.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_listening_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_listening_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_log_facade_logger.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_log_facade_logger.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_network.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_node_alias.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_node_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_pathfinding_scores_source.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_pathfinding_scores_source.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_storage_dir_path.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_builder_set_storage_dir_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_kwu.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_kwu.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_ceil.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_ceil.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_floor.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_feerate_to_sat_per_vb_floor.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_lsps1liquidity_check_order_status.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_lsps1liquidity_check_order_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_lsps1liquidity_request_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_lsps1liquidity_request_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_logwriter_log.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_logwriter_log.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_list_channels.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_list_channels.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_list_nodes.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_list_nodes.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_node.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_networkgraph_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_announcement_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_announcement_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_bolt11_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_bolt11_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_bolt12_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_bolt12_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_close_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_close_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_config.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_connect.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_current_sync_intervals.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_current_sync_intervals.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_disconnect.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_disconnect.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_event_handled.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_event_handled.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_export_pathfinding_scores.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_export_pathfinding_scores.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_force_close_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_force_close_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_get_address_balance.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_get_address_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_get_transaction_details.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_get_transaction_details.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_balances.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_balances.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_channels.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_channels.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_payments.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_payments.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_peers.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_list_peers.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_listening_addresses.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_listening_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_lsps1_liquidity.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_lsps1_liquidity.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_network_graph.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_network_graph.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_next_event.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_next_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_next_event_async.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_next_event_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_node_alias.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_node_alias.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_node_id.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_onchain_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_onchain_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_open_announced_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_open_announced_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_open_channel.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_open_channel.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_remove_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_remove_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_sign_message.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_sign_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_splice_in.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_splice_in.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_splice_out.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_splice_out.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_spontaneous_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_spontaneous_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_start.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_start.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_status.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_stop.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_stop.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_sync_wallets.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_sync_wallets.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_unified_qr_payment.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_unified_qr_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_update_channel_config.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_update_channel_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_update_sync_intervals.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_update_sync_intervals.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_verify_signature.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_verify_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_node_wait_next_event.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_node_wait_next_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_absolute_expiry_seconds.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_absolute_expiry_seconds.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_amount.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_amount.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_chains.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_chains.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_expects_quantity.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_expects_quantity.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_id.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_is_expired.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_is_valid_quantity.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_is_valid_quantity.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_issuer.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_issuer.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_issuer_signing_pubkey.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_issuer_signing_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_metadata.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_offer_description.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_offer_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_offer_supports_chain.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_offer_supports_chain.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_accelerate_by_cpfp.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_accelerate_by_cpfp.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_bump_fee_by_rbf.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_bump_fee_by_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_cpfp_fee_rate.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_cpfp_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_total_fee.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_calculate_total_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_list_spendable_outputs.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_list_spendable_outputs.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_new_address.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_new_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_select_utxos_with_algorithm.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_select_utxos_with_algorithm.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_send_all_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_send_to_address.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_onchainpayment_send_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_absolute_expiry_seconds.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_absolute_expiry_seconds.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_amount_msats.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_amount_msats.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_chain.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_chain.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_is_expired.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_is_expired.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_issuer.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_issuer.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_metadata.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_note.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_note.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_signing_pubkey.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_payer_signing_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_quantity.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_quantity.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_refund_refund_description.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_refund_refund_description.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_probes.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_custom_tlvs.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_custom_tlvs.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage_and_custom_tlvs.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_spontaneouspayment_send_with_preimage_and_custom_tlvs.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_unifiedqrpayment_receive.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_unifiedqrpayment_receive.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_unifiedqrpayment_send.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_unifiedqrpayment_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_method_vssheaderprovider_get_headers.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_method_vssheaderprovider_get_headers.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_bolt11invoice_from_str.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_bolt11invoice_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_bolt12invoice_from_str.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_bolt12invoice_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_builder_from_config.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_builder_from_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_builder_new.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_builder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_kwu.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_kwu.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_vb_unchecked.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_feerate_from_sat_per_vb_unchecked.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_offer_from_str.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_offer_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_ldk_node_checksum_constructor_refund_from_str.argtypes = (
)
_UniffiLib.uniffi_ldk_node_checksum_constructor_refund_from_str.restype = ctypes.c_uint16
_UniffiLib.ffi_ldk_node_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_ldk_node_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class Bolt11InvoiceProtocol(typing.Protocol):
    def amount_milli_satoshis(self, ):
        raise NotImplementedError
    def currency(self, ):
        raise NotImplementedError
    def expiry_time_seconds(self, ):
        raise NotImplementedError
    def fallback_addresses(self, ):
        raise NotImplementedError
    def invoice_description(self, ):
        raise NotImplementedError
    def is_expired(self, ):
        raise NotImplementedError
    def min_final_cltv_expiry_delta(self, ):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def payment_hash(self, ):
        raise NotImplementedError
    def payment_secret(self, ):
        raise NotImplementedError
    def recover_payee_pub_key(self, ):
        raise NotImplementedError
    def route_hints(self, ):
        raise NotImplementedError
    def seconds_since_epoch(self, ):
        raise NotImplementedError
    def seconds_until_expiry(self, ):
        raise NotImplementedError
    def signable_hash(self, ):
        raise NotImplementedError
    def would_expire(self, at_time_seconds: "int"):
        raise NotImplementedError


class Bolt11Invoice:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_bolt11invoice, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_bolt11invoice, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_str(cls, invoice_str: "str"):
        _UniffiConverterString.check_lower(invoice_str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_constructor_bolt11invoice_from_str,
        _UniffiConverterString.lower(invoice_str))
        return cls._make_instance_(pointer)



    def amount_milli_satoshis(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_amount_milli_satoshis,self._uniffi_clone_pointer(),)
        )





    def currency(self, ) -> "Currency":
        return _UniffiConverterTypeCurrency.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_currency,self._uniffi_clone_pointer(),)
        )





    def expiry_time_seconds(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_expiry_time_seconds,self._uniffi_clone_pointer(),)
        )





    def fallback_addresses(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_fallback_addresses,self._uniffi_clone_pointer(),)
        )





    def invoice_description(self, ) -> "Bolt11InvoiceDescription":
        return _UniffiConverterTypeBolt11InvoiceDescription.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_invoice_description,self._uniffi_clone_pointer(),)
        )





    def is_expired(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_is_expired,self._uniffi_clone_pointer(),)
        )





    def min_final_cltv_expiry_delta(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_min_final_cltv_expiry_delta,self._uniffi_clone_pointer(),)
        )





    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_network,self._uniffi_clone_pointer(),)
        )





    def payment_hash(self, ) -> "PaymentHash":
        return _UniffiConverterTypePaymentHash.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_hash,self._uniffi_clone_pointer(),)
        )





    def payment_secret(self, ) -> "PaymentSecret":
        return _UniffiConverterTypePaymentSecret.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_payment_secret,self._uniffi_clone_pointer(),)
        )





    def recover_payee_pub_key(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_recover_payee_pub_key,self._uniffi_clone_pointer(),)
        )





    def route_hints(self, ) -> "typing.List[typing.List[RouteHintHop]]":
        return _UniffiConverterSequenceSequenceTypeRouteHintHop.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_route_hints,self._uniffi_clone_pointer(),)
        )





    def seconds_since_epoch(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_since_epoch,self._uniffi_clone_pointer(),)
        )





    def seconds_until_expiry(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_seconds_until_expiry,self._uniffi_clone_pointer(),)
        )





    def signable_hash(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_signable_hash,self._uniffi_clone_pointer(),)
        )





    def would_expire(self, at_time_seconds: "int") -> "bool":
        _UniffiConverterUInt64.check_lower(at_time_seconds)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_would_expire,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(at_time_seconds))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Bolt11Invoice):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Bolt11Invoice):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt11invoice_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(other)))



class _UniffiConverterTypeBolt11Invoice:

    @staticmethod
    def lift(value: int):
        return Bolt11Invoice._make_instance_(value)

    @staticmethod
    def check_lower(value: Bolt11Invoice):
        if not isinstance(value, Bolt11Invoice):
            raise TypeError("Expected Bolt11Invoice instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bolt11InvoiceProtocol):
        if not isinstance(value, Bolt11Invoice):
            raise TypeError("Expected Bolt11Invoice instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bolt11InvoiceProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Bolt11PaymentProtocol(typing.Protocol):
    def claim_for_hash(self, payment_hash: "PaymentHash",claimable_amount_msat: "int",preimage: "PaymentPreimage"):
        raise NotImplementedError
    def estimate_routing_fees(self, invoice: "Bolt11Invoice"):
        raise NotImplementedError
    def estimate_routing_fees_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int"):
        raise NotImplementedError
    def fail_for_hash(self, payment_hash: "PaymentHash"):
        raise NotImplementedError
    def receive(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int"):
        raise NotImplementedError
    def receive_for_hash(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",payment_hash: "PaymentHash"):
        raise NotImplementedError
    def receive_variable_amount(self, description: "Bolt11InvoiceDescription",expiry_secs: "int"):
        raise NotImplementedError
    def receive_variable_amount_for_hash(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",payment_hash: "PaymentHash"):
        raise NotImplementedError
    def receive_variable_amount_via_jit_channel(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",max_proportional_lsp_fee_limit_ppm_msat: "typing.Optional[int]"):
        raise NotImplementedError
    def receive_variable_amount_via_jit_channel_for_hash(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",max_proportional_lsp_fee_limit_ppm_msat: "typing.Optional[int]",payment_hash: "PaymentHash"):
        raise NotImplementedError
    def receive_via_jit_channel(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",max_lsp_fee_limit_msat: "typing.Optional[int]"):
        raise NotImplementedError
    def receive_via_jit_channel_for_hash(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",max_lsp_fee_limit_msat: "typing.Optional[int]",payment_hash: "PaymentHash"):
        raise NotImplementedError
    def send(self, invoice: "Bolt11Invoice",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_probes(self, invoice: "Bolt11Invoice",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_probes_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError


class Bolt11Payment:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_bolt11payment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_bolt11payment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def claim_for_hash(self, payment_hash: "PaymentHash",claimable_amount_msat: "int",preimage: "PaymentPreimage") -> None:
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        _UniffiConverterUInt64.check_lower(claimable_amount_msat)
        
        _UniffiConverterTypePaymentPreimage.check_lower(preimage)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_claim_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterTypePaymentHash.lower(payment_hash),
        _UniffiConverterUInt64.lower(claimable_amount_msat),
        _UniffiConverterTypePaymentPreimage.lower(preimage))






    def estimate_routing_fees(self, invoice: "Bolt11Invoice") -> "int":
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice))
        )





    def estimate_routing_fees_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int") -> "int":
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_estimate_routing_fees_using_amount,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice),
        _UniffiConverterUInt64.lower(amount_msat))
        )





    def fail_for_hash(self, payment_hash: "PaymentHash") -> None:
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_fail_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterTypePaymentHash.lower(payment_hash))






    def receive(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int") -> "Bolt11Invoice":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs))
        )





    def receive_for_hash(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",payment_hash: "PaymentHash") -> "Bolt11Invoice":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterTypePaymentHash.lower(payment_hash))
        )





    def receive_variable_amount(self, description: "Bolt11InvoiceDescription",expiry_secs: "int") -> "Bolt11Invoice":
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs))
        )





    def receive_variable_amount_for_hash(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",payment_hash: "PaymentHash") -> "Bolt11Invoice":
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterTypePaymentHash.lower(payment_hash))
        )





    def receive_variable_amount_via_jit_channel(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",max_proportional_lsp_fee_limit_ppm_msat: "typing.Optional[int]") -> "Bolt11Invoice":
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(max_proportional_lsp_fee_limit_ppm_msat)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(max_proportional_lsp_fee_limit_ppm_msat))
        )





    def receive_variable_amount_via_jit_channel_for_hash(self, description: "Bolt11InvoiceDescription",expiry_secs: "int",max_proportional_lsp_fee_limit_ppm_msat: "typing.Optional[int]",payment_hash: "PaymentHash") -> "Bolt11Invoice":
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(max_proportional_lsp_fee_limit_ppm_msat)
        
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_variable_amount_via_jit_channel_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(max_proportional_lsp_fee_limit_ppm_msat),
        _UniffiConverterTypePaymentHash.lower(payment_hash))
        )





    def receive_via_jit_channel(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",max_lsp_fee_limit_msat: "typing.Optional[int]") -> "Bolt11Invoice":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(max_lsp_fee_limit_msat)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(max_lsp_fee_limit_msat))
        )





    def receive_via_jit_channel_for_hash(self, amount_msat: "int",description: "Bolt11InvoiceDescription",expiry_secs: "int",max_lsp_fee_limit_msat: "typing.Optional[int]",payment_hash: "PaymentHash") -> "Bolt11Invoice":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypeBolt11InvoiceDescription.check_lower(description)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(max_lsp_fee_limit_msat)
        
        _UniffiConverterTypePaymentHash.check_lower(payment_hash)
        
        return _UniffiConverterTypeBolt11Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_receive_via_jit_channel_for_hash,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypeBolt11InvoiceDescription.lower(description),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(max_lsp_fee_limit_msat),
        _UniffiConverterTypePaymentHash.lower(payment_hash))
        )





    def send(self, invoice: "Bolt11Invoice",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def send_probes(self, invoice: "Bolt11Invoice",route_parameters: "typing.Optional[RouteParametersConfig]") -> None:
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))






    def send_probes_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int",route_parameters: "typing.Optional[RouteParametersConfig]") -> None:
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_probes_using_amount,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))






    def send_using_amount(self, invoice: "Bolt11Invoice",amount_msat: "int",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterTypeBolt11Invoice.check_lower(invoice)
        
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt11payment_send_using_amount,self._uniffi_clone_pointer(),
        _UniffiConverterTypeBolt11Invoice.lower(invoice),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )






class _UniffiConverterTypeBolt11Payment:

    @staticmethod
    def lift(value: int):
        return Bolt11Payment._make_instance_(value)

    @staticmethod
    def check_lower(value: Bolt11Payment):
        if not isinstance(value, Bolt11Payment):
            raise TypeError("Expected Bolt11Payment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bolt11PaymentProtocol):
        if not isinstance(value, Bolt11Payment):
            raise TypeError("Expected Bolt11Payment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bolt11PaymentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Bolt12InvoiceProtocol(typing.Protocol):
    def absolute_expiry_seconds(self, ):
        raise NotImplementedError
    def amount(self, ):
        raise NotImplementedError
    def amount_msats(self, ):
        raise NotImplementedError
    def chain(self, ):
        raise NotImplementedError
    def created_at(self, ):
        raise NotImplementedError
    def encode(self, ):
        raise NotImplementedError
    def fallback_addresses(self, ):
        raise NotImplementedError
    def invoice_description(self, ):
        raise NotImplementedError
    def is_expired(self, ):
        raise NotImplementedError
    def issuer(self, ):
        raise NotImplementedError
    def issuer_signing_pubkey(self, ):
        raise NotImplementedError
    def metadata(self, ):
        raise NotImplementedError
    def offer_chains(self, ):
        raise NotImplementedError
    def payer_note(self, ):
        raise NotImplementedError
    def payer_signing_pubkey(self, ):
        raise NotImplementedError
    def payment_hash(self, ):
        raise NotImplementedError
    def quantity(self, ):
        raise NotImplementedError
    def relative_expiry(self, ):
        raise NotImplementedError
    def signable_hash(self, ):
        raise NotImplementedError
    def signing_pubkey(self, ):
        raise NotImplementedError


class Bolt12Invoice:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_bolt12invoice, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_bolt12invoice, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_str(cls, invoice_str: "str"):
        _UniffiConverterString.check_lower(invoice_str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_constructor_bolt12invoice_from_str,
        _UniffiConverterString.lower(invoice_str))
        return cls._make_instance_(pointer)



    def absolute_expiry_seconds(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_absolute_expiry_seconds,self._uniffi_clone_pointer(),)
        )





    def amount(self, ) -> "typing.Optional[OfferAmount]":
        return _UniffiConverterOptionalTypeOfferAmount.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount,self._uniffi_clone_pointer(),)
        )





    def amount_msats(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_amount_msats,self._uniffi_clone_pointer(),)
        )





    def chain(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_chain,self._uniffi_clone_pointer(),)
        )





    def created_at(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_created_at,self._uniffi_clone_pointer(),)
        )





    def encode(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_encode,self._uniffi_clone_pointer(),)
        )





    def fallback_addresses(self, ) -> "typing.List[Address]":
        return _UniffiConverterSequenceTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_fallback_addresses,self._uniffi_clone_pointer(),)
        )





    def invoice_description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_invoice_description,self._uniffi_clone_pointer(),)
        )





    def is_expired(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_is_expired,self._uniffi_clone_pointer(),)
        )





    def issuer(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer,self._uniffi_clone_pointer(),)
        )





    def issuer_signing_pubkey(self, ) -> "typing.Optional[PublicKey]":
        return _UniffiConverterOptionalTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_issuer_signing_pubkey,self._uniffi_clone_pointer(),)
        )





    def metadata(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_metadata,self._uniffi_clone_pointer(),)
        )





    def offer_chains(self, ) -> "typing.Optional[typing.List[typing.List[int]]]":
        return _UniffiConverterOptionalSequenceSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_offer_chains,self._uniffi_clone_pointer(),)
        )





    def payer_note(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_note,self._uniffi_clone_pointer(),)
        )





    def payer_signing_pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payer_signing_pubkey,self._uniffi_clone_pointer(),)
        )





    def payment_hash(self, ) -> "PaymentHash":
        return _UniffiConverterTypePaymentHash.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_payment_hash,self._uniffi_clone_pointer(),)
        )





    def quantity(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_quantity,self._uniffi_clone_pointer(),)
        )





    def relative_expiry(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_relative_expiry,self._uniffi_clone_pointer(),)
        )





    def signable_hash(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signable_hash,self._uniffi_clone_pointer(),)
        )





    def signing_pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_bolt12invoice_signing_pubkey,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBolt12Invoice:

    @staticmethod
    def lift(value: int):
        return Bolt12Invoice._make_instance_(value)

    @staticmethod
    def check_lower(value: Bolt12Invoice):
        if not isinstance(value, Bolt12Invoice):
            raise TypeError("Expected Bolt12Invoice instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bolt12InvoiceProtocol):
        if not isinstance(value, Bolt12Invoice):
            raise TypeError("Expected Bolt12Invoice instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bolt12InvoiceProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Bolt12PaymentProtocol(typing.Protocol):
    def blinded_paths_for_async_recipient(self, recipient_id: "bytes"):
        raise NotImplementedError
    def initiate_refund(self, amount_msat: "int",expiry_secs: "int",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def receive(self, amount_msat: "int",description: "str",expiry_secs: "typing.Optional[int]",quantity: "typing.Optional[int]"):
        raise NotImplementedError
    def receive_async(self, ):
        raise NotImplementedError
    def receive_variable_amount(self, description: "str",expiry_secs: "typing.Optional[int]"):
        raise NotImplementedError
    def request_refund_payment(self, refund: "Refund"):
        raise NotImplementedError
    def send(self, offer: "Offer",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_using_amount(self, offer: "Offer",amount_msat: "int",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def set_paths_to_static_invoice_server(self, paths: "bytes"):
        raise NotImplementedError


class Bolt12Payment:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_bolt12payment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_bolt12payment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def blinded_paths_for_async_recipient(self, recipient_id: "bytes") -> "bytes":
        _UniffiConverterBytes.check_lower(recipient_id)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_blinded_paths_for_async_recipient,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(recipient_id))
        )





    def initiate_refund(self, amount_msat: "int",expiry_secs: "int",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]") -> "Refund":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(quantity)
        
        _UniffiConverterOptionalString.check_lower(payer_note)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypeRefund.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_initiate_refund,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(quantity),
        _UniffiConverterOptionalString.lower(payer_note),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def receive(self, amount_msat: "int",description: "str",expiry_secs: "typing.Optional[int]",quantity: "typing.Optional[int]") -> "Offer":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterOptionalUInt32.check_lower(expiry_secs)
        
        _UniffiConverterOptionalUInt64.check_lower(quantity)
        
        return _UniffiConverterTypeOffer.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterString.lower(description),
        _UniffiConverterOptionalUInt32.lower(expiry_secs),
        _UniffiConverterOptionalUInt64.lower(quantity))
        )





    def receive_async(self, ) -> "Offer":
        return _UniffiConverterTypeOffer.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_async,self._uniffi_clone_pointer(),)
        )





    def receive_variable_amount(self, description: "str",expiry_secs: "typing.Optional[int]") -> "Offer":
        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterOptionalUInt32.check_lower(expiry_secs)
        
        return _UniffiConverterTypeOffer.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_receive_variable_amount,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(description),
        _UniffiConverterOptionalUInt32.lower(expiry_secs))
        )





    def request_refund_payment(self, refund: "Refund") -> "Bolt12Invoice":
        _UniffiConverterTypeRefund.check_lower(refund)
        
        return _UniffiConverterTypeBolt12Invoice.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_request_refund_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRefund.lower(refund))
        )





    def send(self, offer: "Offer",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterTypeOffer.check_lower(offer)
        
        _UniffiConverterOptionalUInt64.check_lower(quantity)
        
        _UniffiConverterOptionalString.check_lower(payer_note)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOffer.lower(offer),
        _UniffiConverterOptionalUInt64.lower(quantity),
        _UniffiConverterOptionalString.lower(payer_note),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def send_using_amount(self, offer: "Offer",amount_msat: "int",quantity: "typing.Optional[int]",payer_note: "typing.Optional[str]",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterTypeOffer.check_lower(offer)
        
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterOptionalUInt64.check_lower(quantity)
        
        _UniffiConverterOptionalString.check_lower(payer_note)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_send_using_amount,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOffer.lower(offer),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterOptionalUInt64.lower(quantity),
        _UniffiConverterOptionalString.lower(payer_note),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def set_paths_to_static_invoice_server(self, paths: "bytes") -> None:
        _UniffiConverterBytes.check_lower(paths)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_bolt12payment_set_paths_to_static_invoice_server,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(paths))







class _UniffiConverterTypeBolt12Payment:

    @staticmethod
    def lift(value: int):
        return Bolt12Payment._make_instance_(value)

    @staticmethod
    def check_lower(value: Bolt12Payment):
        if not isinstance(value, Bolt12Payment):
            raise TypeError("Expected Bolt12Payment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bolt12PaymentProtocol):
        if not isinstance(value, Bolt12Payment):
            raise TypeError("Expected Bolt12Payment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bolt12PaymentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BuilderProtocol(typing.Protocol):
    def build(self, ):
        raise NotImplementedError
    def build_with_fs_store(self, ):
        raise NotImplementedError
    def build_with_vss_store(self, vss_url: "str",store_id: "str",lnurl_auth_server_url: "str",fixed_headers: "dict[str, str]"):
        raise NotImplementedError
    def build_with_vss_store_and_fixed_headers(self, vss_url: "str",store_id: "str",fixed_headers: "dict[str, str]"):
        raise NotImplementedError
    def build_with_vss_store_and_header_provider(self, vss_url: "str",store_id: "str",header_provider: "VssHeaderProvider"):
        raise NotImplementedError
    def set_announcement_addresses(self, announcement_addresses: "typing.List[SocketAddress]"):
        raise NotImplementedError
    def set_async_payments_role(self, role: "typing.Optional[AsyncPaymentsRole]"):
        raise NotImplementedError
    def set_chain_source_bitcoind_rest(self, rest_host: "str",rest_port: "int",rpc_host: "str",rpc_port: "int",rpc_user: "str",rpc_password: "str"):
        raise NotImplementedError
    def set_chain_source_bitcoind_rpc(self, rpc_host: "str",rpc_port: "int",rpc_user: "str",rpc_password: "str"):
        raise NotImplementedError
    def set_chain_source_electrum(self, server_url: "str",config: "typing.Optional[ElectrumSyncConfig]"):
        raise NotImplementedError
    def set_chain_source_esplora(self, server_url: "str",config: "typing.Optional[EsploraSyncConfig]"):
        raise NotImplementedError
    def set_channel_data_migration(self, migration: "ChannelDataMigration"):
        raise NotImplementedError
    def set_custom_logger(self, log_writer: "LogWriter"):
        raise NotImplementedError
    def set_entropy_bip39_mnemonic(self, mnemonic: "Mnemonic",passphrase: "typing.Optional[str]"):
        raise NotImplementedError
    def set_entropy_seed_bytes(self, seed_bytes: "typing.List[int]"):
        raise NotImplementedError
    def set_entropy_seed_path(self, seed_path: "str"):
        raise NotImplementedError
    def set_filesystem_logger(self, log_file_path: "typing.Optional[str]",max_log_level: "typing.Optional[LogLevel]"):
        raise NotImplementedError
    def set_gossip_source_p2p(self, ):
        raise NotImplementedError
    def set_gossip_source_rgs(self, rgs_server_url: "str"):
        raise NotImplementedError
    def set_liquidity_source_lsps1(self, node_id: "PublicKey",address: "SocketAddress",token: "typing.Optional[str]"):
        raise NotImplementedError
    def set_liquidity_source_lsps2(self, node_id: "PublicKey",address: "SocketAddress",token: "typing.Optional[str]"):
        raise NotImplementedError
    def set_listening_addresses(self, listening_addresses: "typing.List[SocketAddress]"):
        raise NotImplementedError
    def set_log_facade_logger(self, ):
        raise NotImplementedError
    def set_network(self, network: "Network"):
        raise NotImplementedError
    def set_node_alias(self, node_alias: "str"):
        raise NotImplementedError
    def set_pathfinding_scores_source(self, url: "str"):
        raise NotImplementedError
    def set_storage_dir_path(self, storage_dir_path: "str"):
        raise NotImplementedError


class Builder:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_constructor_builder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_builder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_builder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_config(cls, config: "Config"):
        _UniffiConverterTypeConfig.check_lower(config)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_constructor_builder_from_config,
        _UniffiConverterTypeConfig.lower(config))
        return cls._make_instance_(pointer)



    def build(self, ) -> "Node":
        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_build,self._uniffi_clone_pointer(),)
        )





    def build_with_fs_store(self, ) -> "Node":
        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_fs_store,self._uniffi_clone_pointer(),)
        )





    def build_with_vss_store(self, vss_url: "str",store_id: "str",lnurl_auth_server_url: "str",fixed_headers: "dict[str, str]") -> "Node":
        _UniffiConverterString.check_lower(vss_url)
        
        _UniffiConverterString.check_lower(store_id)
        
        _UniffiConverterString.check_lower(lnurl_auth_server_url)
        
        _UniffiConverterMapStringString.check_lower(fixed_headers)
        
        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(vss_url),
        _UniffiConverterString.lower(store_id),
        _UniffiConverterString.lower(lnurl_auth_server_url),
        _UniffiConverterMapStringString.lower(fixed_headers))
        )





    def build_with_vss_store_and_fixed_headers(self, vss_url: "str",store_id: "str",fixed_headers: "dict[str, str]") -> "Node":
        _UniffiConverterString.check_lower(vss_url)
        
        _UniffiConverterString.check_lower(store_id)
        
        _UniffiConverterMapStringString.check_lower(fixed_headers)
        
        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_fixed_headers,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(vss_url),
        _UniffiConverterString.lower(store_id),
        _UniffiConverterMapStringString.lower(fixed_headers))
        )





    def build_with_vss_store_and_header_provider(self, vss_url: "str",store_id: "str",header_provider: "VssHeaderProvider") -> "Node":
        _UniffiConverterString.check_lower(vss_url)
        
        _UniffiConverterString.check_lower(store_id)
        
        _UniffiConverterTypeVssHeaderProvider.check_lower(header_provider)
        
        return _UniffiConverterTypeNode.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_build_with_vss_store_and_header_provider,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(vss_url),
        _UniffiConverterString.lower(store_id),
        _UniffiConverterTypeVssHeaderProvider.lower(header_provider))
        )





    def set_announcement_addresses(self, announcement_addresses: "typing.List[SocketAddress]") -> None:
        _UniffiConverterSequenceTypeSocketAddress.check_lower(announcement_addresses)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_set_announcement_addresses,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeSocketAddress.lower(announcement_addresses))






    def set_async_payments_role(self, role: "typing.Optional[AsyncPaymentsRole]") -> None:
        _UniffiConverterOptionalTypeAsyncPaymentsRole.check_lower(role)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_set_async_payments_role,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalTypeAsyncPaymentsRole.lower(role))






    def set_chain_source_bitcoind_rest(self, rest_host: "str",rest_port: "int",rpc_host: "str",rpc_port: "int",rpc_user: "str",rpc_password: "str") -> None:
        _UniffiConverterString.check_lower(rest_host)
        
        _UniffiConverterUInt16.check_lower(rest_port)
        
        _UniffiConverterString.check_lower(rpc_host)
        
        _UniffiConverterUInt16.check_lower(rpc_port)
        
        _UniffiConverterString.check_lower(rpc_user)
        
        _UniffiConverterString.check_lower(rpc_password)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rest,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(rest_host),
        _UniffiConverterUInt16.lower(rest_port),
        _UniffiConverterString.lower(rpc_host),
        _UniffiConverterUInt16.lower(rpc_port),
        _UniffiConverterString.lower(rpc_user),
        _UniffiConverterString.lower(rpc_password))






    def set_chain_source_bitcoind_rpc(self, rpc_host: "str",rpc_port: "int",rpc_user: "str",rpc_password: "str") -> None:
        _UniffiConverterString.check_lower(rpc_host)
        
        _UniffiConverterUInt16.check_lower(rpc_port)
        
        _UniffiConverterString.check_lower(rpc_user)
        
        _UniffiConverterString.check_lower(rpc_password)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_bitcoind_rpc,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(rpc_host),
        _UniffiConverterUInt16.lower(rpc_port),
        _UniffiConverterString.lower(rpc_user),
        _UniffiConverterString.lower(rpc_password))






    def set_chain_source_electrum(self, server_url: "str",config: "typing.Optional[ElectrumSyncConfig]") -> None:
        _UniffiConverterString.check_lower(server_url)
        
        _UniffiConverterOptionalTypeElectrumSyncConfig.check_lower(config)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_electrum,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(server_url),
        _UniffiConverterOptionalTypeElectrumSyncConfig.lower(config))






    def set_chain_source_esplora(self, server_url: "str",config: "typing.Optional[EsploraSyncConfig]") -> None:
        _UniffiConverterString.check_lower(server_url)
        
        _UniffiConverterOptionalTypeEsploraSyncConfig.check_lower(config)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_chain_source_esplora,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(server_url),
        _UniffiConverterOptionalTypeEsploraSyncConfig.lower(config))






    def set_channel_data_migration(self, migration: "ChannelDataMigration") -> None:
        _UniffiConverterTypeChannelDataMigration.check_lower(migration)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_channel_data_migration,self._uniffi_clone_pointer(),
        _UniffiConverterTypeChannelDataMigration.lower(migration))






    def set_custom_logger(self, log_writer: "LogWriter") -> None:
        _UniffiConverterTypeLogWriter.check_lower(log_writer)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_custom_logger,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLogWriter.lower(log_writer))






    def set_entropy_bip39_mnemonic(self, mnemonic: "Mnemonic",passphrase: "typing.Optional[str]") -> None:
        _UniffiConverterTypeMnemonic.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(passphrase)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_bip39_mnemonic,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMnemonic.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase))






    def set_entropy_seed_bytes(self, seed_bytes: "typing.List[int]") -> None:
        _UniffiConverterSequenceUInt8.check_lower(seed_bytes)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_bytes,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt8.lower(seed_bytes))






    def set_entropy_seed_path(self, seed_path: "str") -> None:
        _UniffiConverterString.check_lower(seed_path)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_entropy_seed_path,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(seed_path))






    def set_filesystem_logger(self, log_file_path: "typing.Optional[str]",max_log_level: "typing.Optional[LogLevel]") -> None:
        _UniffiConverterOptionalString.check_lower(log_file_path)
        
        _UniffiConverterOptionalTypeLogLevel.check_lower(max_log_level)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_filesystem_logger,self._uniffi_clone_pointer(),
        _UniffiConverterOptionalString.lower(log_file_path),
        _UniffiConverterOptionalTypeLogLevel.lower(max_log_level))






    def set_gossip_source_p2p(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_p2p,self._uniffi_clone_pointer(),)






    def set_gossip_source_rgs(self, rgs_server_url: "str") -> None:
        _UniffiConverterString.check_lower(rgs_server_url)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_gossip_source_rgs,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(rgs_server_url))






    def set_liquidity_source_lsps1(self, node_id: "PublicKey",address: "SocketAddress",token: "typing.Optional[str]") -> None:
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypeSocketAddress.check_lower(address)
        
        _UniffiConverterOptionalString.check_lower(token)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps1,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypeSocketAddress.lower(address),
        _UniffiConverterOptionalString.lower(token))






    def set_liquidity_source_lsps2(self, node_id: "PublicKey",address: "SocketAddress",token: "typing.Optional[str]") -> None:
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypeSocketAddress.check_lower(address)
        
        _UniffiConverterOptionalString.check_lower(token)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_liquidity_source_lsps2,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypeSocketAddress.lower(address),
        _UniffiConverterOptionalString.lower(token))






    def set_listening_addresses(self, listening_addresses: "typing.List[SocketAddress]") -> None:
        _UniffiConverterSequenceTypeSocketAddress.check_lower(listening_addresses)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_set_listening_addresses,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeSocketAddress.lower(listening_addresses))






    def set_log_facade_logger(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_log_facade_logger,self._uniffi_clone_pointer(),)






    def set_network(self, network: "Network") -> None:
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_network,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNetwork.lower(network))






    def set_node_alias(self, node_alias: "str") -> None:
        _UniffiConverterString.check_lower(node_alias)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeBuildError,_UniffiLib.uniffi_ldk_node_fn_method_builder_set_node_alias,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(node_alias))






    def set_pathfinding_scores_source(self, url: "str") -> None:
        _UniffiConverterString.check_lower(url)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_pathfinding_scores_source,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(url))






    def set_storage_dir_path(self, storage_dir_path: "str") -> None:
        _UniffiConverterString.check_lower(storage_dir_path)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_builder_set_storage_dir_path,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(storage_dir_path))







class _UniffiConverterTypeBuilder:

    @staticmethod
    def lift(value: int):
        return Builder._make_instance_(value)

    @staticmethod
    def check_lower(value: Builder):
        if not isinstance(value, Builder):
            raise TypeError("Expected Builder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BuilderProtocol):
        if not isinstance(value, Builder):
            raise TypeError("Expected Builder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FeeRateProtocol(typing.Protocol):
    def to_sat_per_kwu(self, ):
        raise NotImplementedError
    def to_sat_per_vb_ceil(self, ):
        raise NotImplementedError
    def to_sat_per_vb_floor(self, ):
        raise NotImplementedError


class FeeRate:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_feerate, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_feerate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_sat_per_kwu(cls, sat_kwu: "int"):
        _UniffiConverterUInt64.check_lower(sat_kwu)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_kwu,
        _UniffiConverterUInt64.lower(sat_kwu))
        return cls._make_instance_(pointer)

    @classmethod
    def from_sat_per_vb_unchecked(cls, sat_vb: "int"):
        _UniffiConverterUInt64.check_lower(sat_vb)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_constructor_feerate_from_sat_per_vb_unchecked,
        _UniffiConverterUInt64.lower(sat_vb))
        return cls._make_instance_(pointer)



    def to_sat_per_kwu(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_kwu,self._uniffi_clone_pointer(),)
        )





    def to_sat_per_vb_ceil(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_ceil,self._uniffi_clone_pointer(),)
        )





    def to_sat_per_vb_floor(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_feerate_to_sat_per_vb_floor,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeFeeRate:

    @staticmethod
    def lift(value: int):
        return FeeRate._make_instance_(value)

    @staticmethod
    def check_lower(value: FeeRate):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FeeRateProtocol):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FeeRateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class LogWriter(typing.Protocol):
    def log(self, record: "LogRecord"):
        raise NotImplementedError


class LogWriterImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_logwriter, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_logwriter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def log(self, record: "LogRecord") -> None:
        _UniffiConverterTypeLogRecord.check_lower(record)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_logwriter_log,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLogRecord.lower(record))




# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplLogWriter:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_LOG_WRITER_METHOD0
    def log(
            uniffi_handle,
            record,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeLogWriter._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeLogRecord.lift(record), )
            method = uniffi_obj.log
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeLogWriter._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceLogWriter(
        log,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_ldk_node_fn_init_callback_vtable_logwriter(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeLogWriter:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return LogWriterImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: LogWriter):
        pass

    @staticmethod
    def lower(value: LogWriter):
        return _UniffiConverterTypeLogWriter._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: LogWriter, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class Lsps1LiquidityProtocol(typing.Protocol):
    def check_order_status(self, order_id: "Lsps1OrderId"):
        raise NotImplementedError
    def request_channel(self, lsp_balance_sat: "int",client_balance_sat: "int",channel_expiry_blocks: "int",announce_channel: "bool"):
        raise NotImplementedError


class Lsps1Liquidity:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_lsps1liquidity, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_lsps1liquidity, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def check_order_status(self, order_id: "Lsps1OrderId") -> "Lsps1OrderStatus":
        _UniffiConverterTypeLsps1OrderId.check_lower(order_id)
        
        return _UniffiConverterTypeLsps1OrderStatus.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_check_order_status,self._uniffi_clone_pointer(),
        _UniffiConverterTypeLsps1OrderId.lower(order_id))
        )





    def request_channel(self, lsp_balance_sat: "int",client_balance_sat: "int",channel_expiry_blocks: "int",announce_channel: "bool") -> "Lsps1OrderStatus":
        _UniffiConverterUInt64.check_lower(lsp_balance_sat)
        
        _UniffiConverterUInt64.check_lower(client_balance_sat)
        
        _UniffiConverterUInt32.check_lower(channel_expiry_blocks)
        
        _UniffiConverterBool.check_lower(announce_channel)
        
        return _UniffiConverterTypeLsps1OrderStatus.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_lsps1liquidity_request_channel,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(lsp_balance_sat),
        _UniffiConverterUInt64.lower(client_balance_sat),
        _UniffiConverterUInt32.lower(channel_expiry_blocks),
        _UniffiConverterBool.lower(announce_channel))
        )






class _UniffiConverterTypeLsps1Liquidity:

    @staticmethod
    def lift(value: int):
        return Lsps1Liquidity._make_instance_(value)

    @staticmethod
    def check_lower(value: Lsps1Liquidity):
        if not isinstance(value, Lsps1Liquidity):
            raise TypeError("Expected Lsps1Liquidity instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Lsps1LiquidityProtocol):
        if not isinstance(value, Lsps1Liquidity):
            raise TypeError("Expected Lsps1Liquidity instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Lsps1LiquidityProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NetworkGraphProtocol(typing.Protocol):
    def channel(self, short_channel_id: "int"):
        raise NotImplementedError
    def list_channels(self, ):
        raise NotImplementedError
    def list_nodes(self, ):
        raise NotImplementedError
    def node(self, node_id: "NodeId"):
        raise NotImplementedError


class NetworkGraph:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_networkgraph, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_networkgraph, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def channel(self, short_channel_id: "int") -> "typing.Optional[ChannelInfo]":
        _UniffiConverterUInt64.check_lower(short_channel_id)
        
        return _UniffiConverterOptionalTypeChannelInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_channel,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(short_channel_id))
        )





    def list_channels(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_channels,self._uniffi_clone_pointer(),)
        )





    def list_nodes(self, ) -> "typing.List[NodeId]":
        return _UniffiConverterSequenceTypeNodeId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_list_nodes,self._uniffi_clone_pointer(),)
        )





    def node(self, node_id: "NodeId") -> "typing.Optional[NodeInfo]":
        _UniffiConverterTypeNodeId.check_lower(node_id)
        
        return _UniffiConverterOptionalTypeNodeInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_networkgraph_node,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNodeId.lower(node_id))
        )






class _UniffiConverterTypeNetworkGraph:

    @staticmethod
    def lift(value: int):
        return NetworkGraph._make_instance_(value)

    @staticmethod
    def check_lower(value: NetworkGraph):
        if not isinstance(value, NetworkGraph):
            raise TypeError("Expected NetworkGraph instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NetworkGraphProtocol):
        if not isinstance(value, NetworkGraph):
            raise TypeError("Expected NetworkGraph instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NetworkGraphProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class NodeProtocol(typing.Protocol):
    def announcement_addresses(self, ):
        raise NotImplementedError
    def bolt11_payment(self, ):
        raise NotImplementedError
    def bolt12_payment(self, ):
        raise NotImplementedError
    def close_channel(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey"):
        raise NotImplementedError
    def config(self, ):
        raise NotImplementedError
    def connect(self, node_id: "PublicKey",address: "SocketAddress",persist: "bool"):
        raise NotImplementedError
    def current_sync_intervals(self, ):
        raise NotImplementedError
    def disconnect(self, node_id: "PublicKey"):
        raise NotImplementedError
    def event_handled(self, ):
        raise NotImplementedError
    def export_pathfinding_scores(self, ):
        raise NotImplementedError
    def force_close_channel(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",reason: "typing.Optional[str]"):
        raise NotImplementedError
    def get_address_balance(self, address_str: "str"):
        raise NotImplementedError
    def get_transaction_details(self, txid: "Txid"):
        raise NotImplementedError
    def list_balances(self, ):
        raise NotImplementedError
    def list_channels(self, ):
        raise NotImplementedError
    def list_payments(self, ):
        raise NotImplementedError
    def list_peers(self, ):
        raise NotImplementedError
    def listening_addresses(self, ):
        raise NotImplementedError
    def lsps1_liquidity(self, ):
        raise NotImplementedError
    def network_graph(self, ):
        raise NotImplementedError
    def next_event(self, ):
        raise NotImplementedError
    def next_event_async(self, ):
        raise NotImplementedError
    def node_alias(self, ):
        raise NotImplementedError
    def node_id(self, ):
        raise NotImplementedError
    def onchain_payment(self, ):
        raise NotImplementedError
    def open_announced_channel(self, node_id: "PublicKey",address: "SocketAddress",channel_amount_sats: "int",push_to_counterparty_msat: "typing.Optional[int]",channel_config: "typing.Optional[ChannelConfig]"):
        raise NotImplementedError
    def open_channel(self, node_id: "PublicKey",address: "SocketAddress",channel_amount_sats: "int",push_to_counterparty_msat: "typing.Optional[int]",channel_config: "typing.Optional[ChannelConfig]"):
        raise NotImplementedError
    def payment(self, payment_id: "PaymentId"):
        raise NotImplementedError
    def remove_payment(self, payment_id: "PaymentId"):
        raise NotImplementedError
    def sign_message(self, msg: "typing.List[int]"):
        raise NotImplementedError
    def splice_in(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",splice_amount_sats: "int"):
        raise NotImplementedError
    def splice_out(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",address: "Address",splice_amount_sats: "int"):
        raise NotImplementedError
    def spontaneous_payment(self, ):
        raise NotImplementedError
    def start(self, ):
        raise NotImplementedError
    def status(self, ):
        raise NotImplementedError
    def stop(self, ):
        raise NotImplementedError
    def sync_wallets(self, ):
        raise NotImplementedError
    def unified_qr_payment(self, ):
        raise NotImplementedError
    def update_channel_config(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",channel_config: "ChannelConfig"):
        raise NotImplementedError
    def update_sync_intervals(self, intervals: "RuntimeSyncIntervals"):
        raise NotImplementedError
    def verify_signature(self, msg: "typing.List[int]",sig: "str",pkey: "PublicKey"):
        raise NotImplementedError
    def wait_next_event(self, ):
        raise NotImplementedError


class Node:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_node, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_node, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def announcement_addresses(self, ) -> "typing.Optional[typing.List[SocketAddress]]":
        return _UniffiConverterOptionalSequenceTypeSocketAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_announcement_addresses,self._uniffi_clone_pointer(),)
        )





    def bolt11_payment(self, ) -> "Bolt11Payment":
        return _UniffiConverterTypeBolt11Payment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_bolt11_payment,self._uniffi_clone_pointer(),)
        )





    def bolt12_payment(self, ) -> "Bolt12Payment":
        return _UniffiConverterTypeBolt12Payment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_bolt12_payment,self._uniffi_clone_pointer(),)
        )





    def close_channel(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey") -> None:
        _UniffiConverterTypeUserChannelId.check_lower(user_channel_id)
        
        _UniffiConverterTypePublicKey.check_lower(counterparty_node_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_close_channel,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserChannelId.lower(user_channel_id),
        _UniffiConverterTypePublicKey.lower(counterparty_node_id))






    def config(self, ) -> "Config":
        return _UniffiConverterTypeConfig.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_config,self._uniffi_clone_pointer(),)
        )





    def connect(self, node_id: "PublicKey",address: "SocketAddress",persist: "bool") -> None:
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypeSocketAddress.check_lower(address)
        
        _UniffiConverterBool.check_lower(persist)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_connect,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypeSocketAddress.lower(address),
        _UniffiConverterBool.lower(persist))






    def current_sync_intervals(self, ) -> "RuntimeSyncIntervals":
        return _UniffiConverterTypeRuntimeSyncIntervals.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_current_sync_intervals,self._uniffi_clone_pointer(),)
        )





    def disconnect(self, node_id: "PublicKey") -> None:
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_disconnect,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id))






    def event_handled(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_event_handled,self._uniffi_clone_pointer(),)






    def export_pathfinding_scores(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_export_pathfinding_scores,self._uniffi_clone_pointer(),)
        )





    def force_close_channel(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",reason: "typing.Optional[str]") -> None:
        _UniffiConverterTypeUserChannelId.check_lower(user_channel_id)
        
        _UniffiConverterTypePublicKey.check_lower(counterparty_node_id)
        
        _UniffiConverterOptionalString.check_lower(reason)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_force_close_channel,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserChannelId.lower(user_channel_id),
        _UniffiConverterTypePublicKey.lower(counterparty_node_id),
        _UniffiConverterOptionalString.lower(reason))






    def get_address_balance(self, address_str: "str") -> "int":
        _UniffiConverterString.check_lower(address_str)
        
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_get_address_balance,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(address_str))
        )





    def get_transaction_details(self, txid: "Txid") -> "typing.Optional[TransactionDetails]":
        _UniffiConverterTypeTxid.check_lower(txid)
        
        return _UniffiConverterOptionalTypeTransactionDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_get_transaction_details,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTxid.lower(txid))
        )





    def list_balances(self, ) -> "BalanceDetails":
        return _UniffiConverterTypeBalanceDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_list_balances,self._uniffi_clone_pointer(),)
        )





    def list_channels(self, ) -> "typing.List[ChannelDetails]":
        return _UniffiConverterSequenceTypeChannelDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_list_channels,self._uniffi_clone_pointer(),)
        )





    def list_payments(self, ) -> "typing.List[PaymentDetails]":
        return _UniffiConverterSequenceTypePaymentDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_list_payments,self._uniffi_clone_pointer(),)
        )





    def list_peers(self, ) -> "typing.List[PeerDetails]":
        return _UniffiConverterSequenceTypePeerDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_list_peers,self._uniffi_clone_pointer(),)
        )





    def listening_addresses(self, ) -> "typing.Optional[typing.List[SocketAddress]]":
        return _UniffiConverterOptionalSequenceTypeSocketAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_listening_addresses,self._uniffi_clone_pointer(),)
        )





    def lsps1_liquidity(self, ) -> "Lsps1Liquidity":
        return _UniffiConverterTypeLsps1Liquidity.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_lsps1_liquidity,self._uniffi_clone_pointer(),)
        )





    def network_graph(self, ) -> "NetworkGraph":
        return _UniffiConverterTypeNetworkGraph.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_network_graph,self._uniffi_clone_pointer(),)
        )





    def next_event(self, ) -> "typing.Optional[Event]":
        return _UniffiConverterOptionalTypeEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_next_event,self._uniffi_clone_pointer(),)
        )




    async def next_event_async(self, ) -> "Event":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ldk_node_fn_method_node_next_event_async(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ldk_node_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ldk_node_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ldk_node_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter

    None,

        )




    def node_alias(self, ) -> "typing.Optional[NodeAlias]":
        return _UniffiConverterOptionalTypeNodeAlias.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_node_alias,self._uniffi_clone_pointer(),)
        )





    def node_id(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_node_id,self._uniffi_clone_pointer(),)
        )





    def onchain_payment(self, ) -> "OnchainPayment":
        return _UniffiConverterTypeOnchainPayment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_onchain_payment,self._uniffi_clone_pointer(),)
        )





    def open_announced_channel(self, node_id: "PublicKey",address: "SocketAddress",channel_amount_sats: "int",push_to_counterparty_msat: "typing.Optional[int]",channel_config: "typing.Optional[ChannelConfig]") -> "UserChannelId":
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypeSocketAddress.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(channel_amount_sats)
        
        _UniffiConverterOptionalUInt64.check_lower(push_to_counterparty_msat)
        
        _UniffiConverterOptionalTypeChannelConfig.check_lower(channel_config)
        
        return _UniffiConverterTypeUserChannelId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_open_announced_channel,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypeSocketAddress.lower(address),
        _UniffiConverterUInt64.lower(channel_amount_sats),
        _UniffiConverterOptionalUInt64.lower(push_to_counterparty_msat),
        _UniffiConverterOptionalTypeChannelConfig.lower(channel_config))
        )





    def open_channel(self, node_id: "PublicKey",address: "SocketAddress",channel_amount_sats: "int",push_to_counterparty_msat: "typing.Optional[int]",channel_config: "typing.Optional[ChannelConfig]") -> "UserChannelId":
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypeSocketAddress.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(channel_amount_sats)
        
        _UniffiConverterOptionalUInt64.check_lower(push_to_counterparty_msat)
        
        _UniffiConverterOptionalTypeChannelConfig.check_lower(channel_config)
        
        return _UniffiConverterTypeUserChannelId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_open_channel,self._uniffi_clone_pointer(),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypeSocketAddress.lower(address),
        _UniffiConverterUInt64.lower(channel_amount_sats),
        _UniffiConverterOptionalUInt64.lower(push_to_counterparty_msat),
        _UniffiConverterOptionalTypeChannelConfig.lower(channel_config))
        )





    def payment(self, payment_id: "PaymentId") -> "typing.Optional[PaymentDetails]":
        _UniffiConverterTypePaymentId.check_lower(payment_id)
        
        return _UniffiConverterOptionalTypePaymentDetails.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypePaymentId.lower(payment_id))
        )





    def remove_payment(self, payment_id: "PaymentId") -> None:
        _UniffiConverterTypePaymentId.check_lower(payment_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_remove_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypePaymentId.lower(payment_id))






    def sign_message(self, msg: "typing.List[int]") -> "str":
        _UniffiConverterSequenceUInt8.check_lower(msg)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_sign_message,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt8.lower(msg))
        )





    def splice_in(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",splice_amount_sats: "int") -> None:
        _UniffiConverterTypeUserChannelId.check_lower(user_channel_id)
        
        _UniffiConverterTypePublicKey.check_lower(counterparty_node_id)
        
        _UniffiConverterUInt64.check_lower(splice_amount_sats)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_splice_in,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserChannelId.lower(user_channel_id),
        _UniffiConverterTypePublicKey.lower(counterparty_node_id),
        _UniffiConverterUInt64.lower(splice_amount_sats))






    def splice_out(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",address: "Address",splice_amount_sats: "int") -> None:
        _UniffiConverterTypeUserChannelId.check_lower(user_channel_id)
        
        _UniffiConverterTypePublicKey.check_lower(counterparty_node_id)
        
        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(splice_amount_sats)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_splice_out,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserChannelId.lower(user_channel_id),
        _UniffiConverterTypePublicKey.lower(counterparty_node_id),
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterUInt64.lower(splice_amount_sats))






    def spontaneous_payment(self, ) -> "SpontaneousPayment":
        return _UniffiConverterTypeSpontaneousPayment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_spontaneous_payment,self._uniffi_clone_pointer(),)
        )





    def start(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_start,self._uniffi_clone_pointer(),)






    def status(self, ) -> "NodeStatus":
        return _UniffiConverterTypeNodeStatus.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_status,self._uniffi_clone_pointer(),)
        )





    def stop(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_stop,self._uniffi_clone_pointer(),)






    def sync_wallets(self, ) -> None:
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_sync_wallets,self._uniffi_clone_pointer(),)






    def unified_qr_payment(self, ) -> "UnifiedQrPayment":
        return _UniffiConverterTypeUnifiedQrPayment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_unified_qr_payment,self._uniffi_clone_pointer(),)
        )





    def update_channel_config(self, user_channel_id: "UserChannelId",counterparty_node_id: "PublicKey",channel_config: "ChannelConfig") -> None:
        _UniffiConverterTypeUserChannelId.check_lower(user_channel_id)
        
        _UniffiConverterTypePublicKey.check_lower(counterparty_node_id)
        
        _UniffiConverterTypeChannelConfig.check_lower(channel_config)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_update_channel_config,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserChannelId.lower(user_channel_id),
        _UniffiConverterTypePublicKey.lower(counterparty_node_id),
        _UniffiConverterTypeChannelConfig.lower(channel_config))






    def update_sync_intervals(self, intervals: "RuntimeSyncIntervals") -> None:
        _UniffiConverterTypeRuntimeSyncIntervals.check_lower(intervals)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_node_update_sync_intervals,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRuntimeSyncIntervals.lower(intervals))






    def verify_signature(self, msg: "typing.List[int]",sig: "str",pkey: "PublicKey") -> "bool":
        _UniffiConverterSequenceUInt8.check_lower(msg)
        
        _UniffiConverterString.check_lower(sig)
        
        _UniffiConverterTypePublicKey.check_lower(pkey)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_verify_signature,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceUInt8.lower(msg),
        _UniffiConverterString.lower(sig),
        _UniffiConverterTypePublicKey.lower(pkey))
        )





    def wait_next_event(self, ) -> "Event":
        return _UniffiConverterTypeEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_node_wait_next_event,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNode:

    @staticmethod
    def lift(value: int):
        return Node._make_instance_(value)

    @staticmethod
    def check_lower(value: Node):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeProtocol):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class OfferProtocol(typing.Protocol):
    def absolute_expiry_seconds(self, ):
        raise NotImplementedError
    def amount(self, ):
        raise NotImplementedError
    def chains(self, ):
        raise NotImplementedError
    def expects_quantity(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def is_expired(self, ):
        raise NotImplementedError
    def is_valid_quantity(self, quantity: "int"):
        raise NotImplementedError
    def issuer(self, ):
        raise NotImplementedError
    def issuer_signing_pubkey(self, ):
        raise NotImplementedError
    def metadata(self, ):
        raise NotImplementedError
    def offer_description(self, ):
        raise NotImplementedError
    def supports_chain(self, chain: "Network"):
        raise NotImplementedError


class Offer:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_offer, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_offer, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_str(cls, offer_str: "str"):
        _UniffiConverterString.check_lower(offer_str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_constructor_offer_from_str,
        _UniffiConverterString.lower(offer_str))
        return cls._make_instance_(pointer)



    def absolute_expiry_seconds(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_absolute_expiry_seconds,self._uniffi_clone_pointer(),)
        )





    def amount(self, ) -> "typing.Optional[OfferAmount]":
        return _UniffiConverterOptionalTypeOfferAmount.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_amount,self._uniffi_clone_pointer(),)
        )





    def chains(self, ) -> "typing.List[Network]":
        return _UniffiConverterSequenceTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_chains,self._uniffi_clone_pointer(),)
        )





    def expects_quantity(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_expects_quantity,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "OfferId":
        return _UniffiConverterTypeOfferId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_id,self._uniffi_clone_pointer(),)
        )





    def is_expired(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_is_expired,self._uniffi_clone_pointer(),)
        )





    def is_valid_quantity(self, quantity: "int") -> "bool":
        _UniffiConverterUInt64.check_lower(quantity)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_is_valid_quantity,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(quantity))
        )





    def issuer(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer,self._uniffi_clone_pointer(),)
        )





    def issuer_signing_pubkey(self, ) -> "typing.Optional[PublicKey]":
        return _UniffiConverterOptionalTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_issuer_signing_pubkey,self._uniffi_clone_pointer(),)
        )





    def metadata(self, ) -> "typing.Optional[typing.List[int]]":
        return _UniffiConverterOptionalSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_metadata,self._uniffi_clone_pointer(),)
        )





    def offer_description(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_offer_description,self._uniffi_clone_pointer(),)
        )





    def supports_chain(self, chain: "Network") -> "bool":
        _UniffiConverterTypeNetwork.check_lower(chain)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_supports_chain,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNetwork.lower(chain))
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Offer):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOffer.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Offer):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_offer_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOffer.lower(other)))



class _UniffiConverterTypeOffer:

    @staticmethod
    def lift(value: int):
        return Offer._make_instance_(value)

    @staticmethod
    def check_lower(value: Offer):
        if not isinstance(value, Offer):
            raise TypeError("Expected Offer instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: OfferProtocol):
        if not isinstance(value, Offer):
            raise TypeError("Expected Offer instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: OfferProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class OnchainPaymentProtocol(typing.Protocol):
    def accelerate_by_cpfp(self, txid: "Txid",fee_rate: "typing.Optional[FeeRate]",destination_address: "typing.Optional[Address]"):
        raise NotImplementedError
    def bump_fee_by_rbf(self, txid: "Txid",fee_rate: "FeeRate"):
        raise NotImplementedError
    def calculate_cpfp_fee_rate(self, parent_txid: "Txid",urgent: "bool"):
        raise NotImplementedError
    def calculate_total_fee(self, address: "Address",amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",utxos_to_spend: "typing.Optional[typing.List[SpendableUtxo]]"):
        raise NotImplementedError
    def list_spendable_outputs(self, ):
        raise NotImplementedError
    def new_address(self, ):
        raise NotImplementedError
    def select_utxos_with_algorithm(self, target_amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",algorithm: "CoinSelectionAlgorithm",utxos: "typing.Optional[typing.List[SpendableUtxo]]"):
        raise NotImplementedError
    def send_all_to_address(self, address: "Address",retain_reserve: "bool",fee_rate: "typing.Optional[FeeRate]"):
        raise NotImplementedError
    def send_to_address(self, address: "Address",amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",utxos_to_spend: "typing.Optional[typing.List[SpendableUtxo]]"):
        raise NotImplementedError


class OnchainPayment:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_onchainpayment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_onchainpayment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def accelerate_by_cpfp(self, txid: "Txid",fee_rate: "typing.Optional[FeeRate]",destination_address: "typing.Optional[Address]") -> "Txid":
        _UniffiConverterTypeTxid.check_lower(txid)
        
        _UniffiConverterOptionalTypeFeeRate.check_lower(fee_rate)
        
        _UniffiConverterOptionalTypeAddress.check_lower(destination_address)
        
        return _UniffiConverterTypeTxid.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_accelerate_by_cpfp,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTxid.lower(txid),
        _UniffiConverterOptionalTypeFeeRate.lower(fee_rate),
        _UniffiConverterOptionalTypeAddress.lower(destination_address))
        )





    def bump_fee_by_rbf(self, txid: "Txid",fee_rate: "FeeRate") -> "Txid":
        _UniffiConverterTypeTxid.check_lower(txid)
        
        _UniffiConverterTypeFeeRate.check_lower(fee_rate)
        
        return _UniffiConverterTypeTxid.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_bump_fee_by_rbf,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTxid.lower(txid),
        _UniffiConverterTypeFeeRate.lower(fee_rate))
        )





    def calculate_cpfp_fee_rate(self, parent_txid: "Txid",urgent: "bool") -> "FeeRate":
        _UniffiConverterTypeTxid.check_lower(parent_txid)
        
        _UniffiConverterBool.check_lower(urgent)
        
        return _UniffiConverterTypeFeeRate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_cpfp_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTxid.lower(parent_txid),
        _UniffiConverterBool.lower(urgent))
        )





    def calculate_total_fee(self, address: "Address",amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",utxos_to_spend: "typing.Optional[typing.List[SpendableUtxo]]") -> "int":
        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(amount_sats)
        
        _UniffiConverterOptionalTypeFeeRate.check_lower(fee_rate)
        
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.check_lower(utxos_to_spend)
        
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_calculate_total_fee,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterUInt64.lower(amount_sats),
        _UniffiConverterOptionalTypeFeeRate.lower(fee_rate),
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.lower(utxos_to_spend))
        )





    def list_spendable_outputs(self, ) -> "typing.List[SpendableUtxo]":
        return _UniffiConverterSequenceTypeSpendableUtxo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_list_spendable_outputs,self._uniffi_clone_pointer(),)
        )





    def new_address(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_new_address,self._uniffi_clone_pointer(),)
        )





    def select_utxos_with_algorithm(self, target_amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",algorithm: "CoinSelectionAlgorithm",utxos: "typing.Optional[typing.List[SpendableUtxo]]") -> "typing.List[SpendableUtxo]":
        _UniffiConverterUInt64.check_lower(target_amount_sats)
        
        _UniffiConverterOptionalTypeFeeRate.check_lower(fee_rate)
        
        _UniffiConverterTypeCoinSelectionAlgorithm.check_lower(algorithm)
        
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.check_lower(utxos)
        
        return _UniffiConverterSequenceTypeSpendableUtxo.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_select_utxos_with_algorithm,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(target_amount_sats),
        _UniffiConverterOptionalTypeFeeRate.lower(fee_rate),
        _UniffiConverterTypeCoinSelectionAlgorithm.lower(algorithm),
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.lower(utxos))
        )





    def send_all_to_address(self, address: "Address",retain_reserve: "bool",fee_rate: "typing.Optional[FeeRate]") -> "Txid":
        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterBool.check_lower(retain_reserve)
        
        _UniffiConverterOptionalTypeFeeRate.check_lower(fee_rate)
        
        return _UniffiConverterTypeTxid.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_all_to_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterBool.lower(retain_reserve),
        _UniffiConverterOptionalTypeFeeRate.lower(fee_rate))
        )





    def send_to_address(self, address: "Address",amount_sats: "int",fee_rate: "typing.Optional[FeeRate]",utxos_to_spend: "typing.Optional[typing.List[SpendableUtxo]]") -> "Txid":
        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(amount_sats)
        
        _UniffiConverterOptionalTypeFeeRate.check_lower(fee_rate)
        
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.check_lower(utxos_to_spend)
        
        return _UniffiConverterTypeTxid.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_onchainpayment_send_to_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterUInt64.lower(amount_sats),
        _UniffiConverterOptionalTypeFeeRate.lower(fee_rate),
        _UniffiConverterOptionalSequenceTypeSpendableUtxo.lower(utxos_to_spend))
        )






class _UniffiConverterTypeOnchainPayment:

    @staticmethod
    def lift(value: int):
        return OnchainPayment._make_instance_(value)

    @staticmethod
    def check_lower(value: OnchainPayment):
        if not isinstance(value, OnchainPayment):
            raise TypeError("Expected OnchainPayment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: OnchainPaymentProtocol):
        if not isinstance(value, OnchainPayment):
            raise TypeError("Expected OnchainPayment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: OnchainPaymentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class RefundProtocol(typing.Protocol):
    def absolute_expiry_seconds(self, ):
        raise NotImplementedError
    def amount_msats(self, ):
        raise NotImplementedError
    def chain(self, ):
        raise NotImplementedError
    def is_expired(self, ):
        raise NotImplementedError
    def issuer(self, ):
        raise NotImplementedError
    def payer_metadata(self, ):
        raise NotImplementedError
    def payer_note(self, ):
        raise NotImplementedError
    def payer_signing_pubkey(self, ):
        raise NotImplementedError
    def quantity(self, ):
        raise NotImplementedError
    def refund_description(self, ):
        raise NotImplementedError


class Refund:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_refund, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_refund, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_str(cls, refund_str: "str"):
        _UniffiConverterString.check_lower(refund_str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_constructor_refund_from_str,
        _UniffiConverterString.lower(refund_str))
        return cls._make_instance_(pointer)



    def absolute_expiry_seconds(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_absolute_expiry_seconds,self._uniffi_clone_pointer(),)
        )





    def amount_msats(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_amount_msats,self._uniffi_clone_pointer(),)
        )





    def chain(self, ) -> "typing.Optional[Network]":
        return _UniffiConverterOptionalTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_chain,self._uniffi_clone_pointer(),)
        )





    def is_expired(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_is_expired,self._uniffi_clone_pointer(),)
        )





    def issuer(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_issuer,self._uniffi_clone_pointer(),)
        )





    def payer_metadata(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_metadata,self._uniffi_clone_pointer(),)
        )





    def payer_note(self, ) -> "typing.Optional[str]":
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_note,self._uniffi_clone_pointer(),)
        )





    def payer_signing_pubkey(self, ) -> "PublicKey":
        return _UniffiConverterTypePublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_payer_signing_pubkey,self._uniffi_clone_pointer(),)
        )





    def quantity(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_quantity,self._uniffi_clone_pointer(),)
        )





    def refund_description(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_refund_description,self._uniffi_clone_pointer(),)
        )





    def __repr__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_debug,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Refund):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRefund.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, Refund):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_method_refund_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeRefund.lower(other)))



class _UniffiConverterTypeRefund:

    @staticmethod
    def lift(value: int):
        return Refund._make_instance_(value)

    @staticmethod
    def check_lower(value: Refund):
        if not isinstance(value, Refund):
            raise TypeError("Expected Refund instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: RefundProtocol):
        if not isinstance(value, Refund):
            raise TypeError("Expected Refund instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: RefundProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SpontaneousPaymentProtocol(typing.Protocol):
    def send(self, amount_msat: "int",node_id: "PublicKey",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_probes(self, amount_msat: "int",node_id: "PublicKey"):
        raise NotImplementedError
    def send_with_custom_tlvs(self, amount_msat: "int",node_id: "PublicKey",route_parameters: "typing.Optional[RouteParametersConfig]",custom_tlvs: "typing.List[CustomTlvRecord]"):
        raise NotImplementedError
    def send_with_preimage(self, amount_msat: "int",node_id: "PublicKey",preimage: "PaymentPreimage",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError
    def send_with_preimage_and_custom_tlvs(self, amount_msat: "int",node_id: "PublicKey",custom_tlvs: "typing.List[CustomTlvRecord]",preimage: "PaymentPreimage",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError


class SpontaneousPayment:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_spontaneouspayment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_spontaneouspayment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def send(self, amount_msat: "int",node_id: "PublicKey",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def send_probes(self, amount_msat: "int",node_id: "PublicKey") -> None:
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_probes,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypePublicKey.lower(node_id))






    def send_with_custom_tlvs(self, amount_msat: "int",node_id: "PublicKey",route_parameters: "typing.Optional[RouteParametersConfig]",custom_tlvs: "typing.List[CustomTlvRecord]") -> "PaymentId":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        _UniffiConverterSequenceTypeCustomTlvRecord.check_lower(custom_tlvs)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_custom_tlvs,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters),
        _UniffiConverterSequenceTypeCustomTlvRecord.lower(custom_tlvs))
        )





    def send_with_preimage(self, amount_msat: "int",node_id: "PublicKey",preimage: "PaymentPreimage",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterTypePaymentPreimage.check_lower(preimage)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterTypePaymentPreimage.lower(preimage),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )





    def send_with_preimage_and_custom_tlvs(self, amount_msat: "int",node_id: "PublicKey",custom_tlvs: "typing.List[CustomTlvRecord]",preimage: "PaymentPreimage",route_parameters: "typing.Optional[RouteParametersConfig]") -> "PaymentId":
        _UniffiConverterUInt64.check_lower(amount_msat)
        
        _UniffiConverterTypePublicKey.check_lower(node_id)
        
        _UniffiConverterSequenceTypeCustomTlvRecord.check_lower(custom_tlvs)
        
        _UniffiConverterTypePaymentPreimage.check_lower(preimage)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypePaymentId.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_spontaneouspayment_send_with_preimage_and_custom_tlvs,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_msat),
        _UniffiConverterTypePublicKey.lower(node_id),
        _UniffiConverterSequenceTypeCustomTlvRecord.lower(custom_tlvs),
        _UniffiConverterTypePaymentPreimage.lower(preimage),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )






class _UniffiConverterTypeSpontaneousPayment:

    @staticmethod
    def lift(value: int):
        return SpontaneousPayment._make_instance_(value)

    @staticmethod
    def check_lower(value: SpontaneousPayment):
        if not isinstance(value, SpontaneousPayment):
            raise TypeError("Expected SpontaneousPayment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SpontaneousPaymentProtocol):
        if not isinstance(value, SpontaneousPayment):
            raise TypeError("Expected SpontaneousPayment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SpontaneousPaymentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class UnifiedQrPaymentProtocol(typing.Protocol):
    def receive(self, amount_sats: "int",message: "str",expiry_sec: "int"):
        raise NotImplementedError
    def send(self, uri_str: "str",route_parameters: "typing.Optional[RouteParametersConfig]"):
        raise NotImplementedError


class UnifiedQrPayment:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_unifiedqrpayment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_unifiedqrpayment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def receive(self, amount_sats: "int",message: "str",expiry_sec: "int") -> "str":
        _UniffiConverterUInt64.check_lower(amount_sats)
        
        _UniffiConverterString.check_lower(message)
        
        _UniffiConverterUInt32.check_lower(expiry_sec)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_receive,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(amount_sats),
        _UniffiConverterString.lower(message),
        _UniffiConverterUInt32.lower(expiry_sec))
        )





    def send(self, uri_str: "str",route_parameters: "typing.Optional[RouteParametersConfig]") -> "QrPaymentResult":
        _UniffiConverterString.check_lower(uri_str)
        
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(route_parameters)
        
        return _UniffiConverterTypeQrPaymentResult.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_method_unifiedqrpayment_send,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(uri_str),
        _UniffiConverterOptionalTypeRouteParametersConfig.lower(route_parameters))
        )






class _UniffiConverterTypeUnifiedQrPayment:

    @staticmethod
    def lift(value: int):
        return UnifiedQrPayment._make_instance_(value)

    @staticmethod
    def check_lower(value: UnifiedQrPayment):
        if not isinstance(value, UnifiedQrPayment):
            raise TypeError("Expected UnifiedQrPayment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UnifiedQrPaymentProtocol):
        if not isinstance(value, UnifiedQrPayment):
            raise TypeError("Expected UnifiedQrPayment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UnifiedQrPaymentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class VssHeaderProviderProtocol(typing.Protocol):
    def get_headers(self, request: "typing.List[int]"):
        raise NotImplementedError


class VssHeaderProvider:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_free_vssheaderprovider, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_clone_vssheaderprovider, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def get_headers(self, request: "typing.List[int]") -> "dict[str, str]":
        _UniffiConverterSequenceUInt8.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ldk_node_fn_method_vssheaderprovider_get_headers(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceUInt8.lower(request)
            ),
            _UniffiLib.ffi_ldk_node_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ldk_node_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ldk_node_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterMapStringString.lift,
            
    # Error FFI converter
_UniffiConverterTypeVssHeaderProviderError,

        )





class _UniffiConverterTypeVssHeaderProvider:

    @staticmethod
    def lift(value: int):
        return VssHeaderProvider._make_instance_(value)

    @staticmethod
    def check_lower(value: VssHeaderProvider):
        if not isinstance(value, VssHeaderProvider):
            raise TypeError("Expected VssHeaderProvider instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: VssHeaderProviderProtocol):
        if not isinstance(value, VssHeaderProvider):
            raise TypeError("Expected VssHeaderProvider instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: VssHeaderProviderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AnchorChannelsConfig:
    trusted_peers_no_reserve: "typing.List[PublicKey]"
    per_channel_reserve_sats: "int"
    def __init__(self, *, trusted_peers_no_reserve: "typing.List[PublicKey]", per_channel_reserve_sats: "int"):
        self.trusted_peers_no_reserve = trusted_peers_no_reserve
        self.per_channel_reserve_sats = per_channel_reserve_sats

    def __str__(self):
        return "AnchorChannelsConfig(trusted_peers_no_reserve={}, per_channel_reserve_sats={})".format(self.trusted_peers_no_reserve, self.per_channel_reserve_sats)

    def __eq__(self, other):
        if self.trusted_peers_no_reserve != other.trusted_peers_no_reserve:
            return False
        if self.per_channel_reserve_sats != other.per_channel_reserve_sats:
            return False
        return True

class _UniffiConverterTypeAnchorChannelsConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AnchorChannelsConfig(
            trusted_peers_no_reserve=_UniffiConverterSequenceTypePublicKey.read(buf),
            per_channel_reserve_sats=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePublicKey.check_lower(value.trusted_peers_no_reserve)
        _UniffiConverterUInt64.check_lower(value.per_channel_reserve_sats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePublicKey.write(value.trusted_peers_no_reserve, buf)
        _UniffiConverterUInt64.write(value.per_channel_reserve_sats, buf)


class BackgroundSyncConfig:
    onchain_wallet_sync_interval_secs: "int"
    lightning_wallet_sync_interval_secs: "int"
    fee_rate_cache_update_interval_secs: "int"
    def __init__(self, *, onchain_wallet_sync_interval_secs: "int", lightning_wallet_sync_interval_secs: "int", fee_rate_cache_update_interval_secs: "int"):
        self.onchain_wallet_sync_interval_secs = onchain_wallet_sync_interval_secs
        self.lightning_wallet_sync_interval_secs = lightning_wallet_sync_interval_secs
        self.fee_rate_cache_update_interval_secs = fee_rate_cache_update_interval_secs

    def __str__(self):
        return "BackgroundSyncConfig(onchain_wallet_sync_interval_secs={}, lightning_wallet_sync_interval_secs={}, fee_rate_cache_update_interval_secs={})".format(self.onchain_wallet_sync_interval_secs, self.lightning_wallet_sync_interval_secs, self.fee_rate_cache_update_interval_secs)

    def __eq__(self, other):
        if self.onchain_wallet_sync_interval_secs != other.onchain_wallet_sync_interval_secs:
            return False
        if self.lightning_wallet_sync_interval_secs != other.lightning_wallet_sync_interval_secs:
            return False
        if self.fee_rate_cache_update_interval_secs != other.fee_rate_cache_update_interval_secs:
            return False
        return True

class _UniffiConverterTypeBackgroundSyncConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BackgroundSyncConfig(
            onchain_wallet_sync_interval_secs=_UniffiConverterUInt64.read(buf),
            lightning_wallet_sync_interval_secs=_UniffiConverterUInt64.read(buf),
            fee_rate_cache_update_interval_secs=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.onchain_wallet_sync_interval_secs)
        _UniffiConverterUInt64.check_lower(value.lightning_wallet_sync_interval_secs)
        _UniffiConverterUInt64.check_lower(value.fee_rate_cache_update_interval_secs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.onchain_wallet_sync_interval_secs, buf)
        _UniffiConverterUInt64.write(value.lightning_wallet_sync_interval_secs, buf)
        _UniffiConverterUInt64.write(value.fee_rate_cache_update_interval_secs, buf)


class BalanceDetails:
    total_onchain_balance_sats: "int"
    spendable_onchain_balance_sats: "int"
    total_anchor_channels_reserve_sats: "int"
    total_lightning_balance_sats: "int"
    lightning_balances: "typing.List[LightningBalance]"
    pending_balances_from_channel_closures: "typing.List[PendingSweepBalance]"
    def __init__(self, *, total_onchain_balance_sats: "int", spendable_onchain_balance_sats: "int", total_anchor_channels_reserve_sats: "int", total_lightning_balance_sats: "int", lightning_balances: "typing.List[LightningBalance]", pending_balances_from_channel_closures: "typing.List[PendingSweepBalance]"):
        self.total_onchain_balance_sats = total_onchain_balance_sats
        self.spendable_onchain_balance_sats = spendable_onchain_balance_sats
        self.total_anchor_channels_reserve_sats = total_anchor_channels_reserve_sats
        self.total_lightning_balance_sats = total_lightning_balance_sats
        self.lightning_balances = lightning_balances
        self.pending_balances_from_channel_closures = pending_balances_from_channel_closures

    def __str__(self):
        return "BalanceDetails(total_onchain_balance_sats={}, spendable_onchain_balance_sats={}, total_anchor_channels_reserve_sats={}, total_lightning_balance_sats={}, lightning_balances={}, pending_balances_from_channel_closures={})".format(self.total_onchain_balance_sats, self.spendable_onchain_balance_sats, self.total_anchor_channels_reserve_sats, self.total_lightning_balance_sats, self.lightning_balances, self.pending_balances_from_channel_closures)

    def __eq__(self, other):
        if self.total_onchain_balance_sats != other.total_onchain_balance_sats:
            return False
        if self.spendable_onchain_balance_sats != other.spendable_onchain_balance_sats:
            return False
        if self.total_anchor_channels_reserve_sats != other.total_anchor_channels_reserve_sats:
            return False
        if self.total_lightning_balance_sats != other.total_lightning_balance_sats:
            return False
        if self.lightning_balances != other.lightning_balances:
            return False
        if self.pending_balances_from_channel_closures != other.pending_balances_from_channel_closures:
            return False
        return True

class _UniffiConverterTypeBalanceDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BalanceDetails(
            total_onchain_balance_sats=_UniffiConverterUInt64.read(buf),
            spendable_onchain_balance_sats=_UniffiConverterUInt64.read(buf),
            total_anchor_channels_reserve_sats=_UniffiConverterUInt64.read(buf),
            total_lightning_balance_sats=_UniffiConverterUInt64.read(buf),
            lightning_balances=_UniffiConverterSequenceTypeLightningBalance.read(buf),
            pending_balances_from_channel_closures=_UniffiConverterSequenceTypePendingSweepBalance.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.total_onchain_balance_sats)
        _UniffiConverterUInt64.check_lower(value.spendable_onchain_balance_sats)
        _UniffiConverterUInt64.check_lower(value.total_anchor_channels_reserve_sats)
        _UniffiConverterUInt64.check_lower(value.total_lightning_balance_sats)
        _UniffiConverterSequenceTypeLightningBalance.check_lower(value.lightning_balances)
        _UniffiConverterSequenceTypePendingSweepBalance.check_lower(value.pending_balances_from_channel_closures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.total_onchain_balance_sats, buf)
        _UniffiConverterUInt64.write(value.spendable_onchain_balance_sats, buf)
        _UniffiConverterUInt64.write(value.total_anchor_channels_reserve_sats, buf)
        _UniffiConverterUInt64.write(value.total_lightning_balance_sats, buf)
        _UniffiConverterSequenceTypeLightningBalance.write(value.lightning_balances, buf)
        _UniffiConverterSequenceTypePendingSweepBalance.write(value.pending_balances_from_channel_closures, buf)


class BestBlock:
    block_hash: "BlockHash"
    height: "int"
    def __init__(self, *, block_hash: "BlockHash", height: "int"):
        self.block_hash = block_hash
        self.height = height

    def __str__(self):
        return "BestBlock(block_hash={}, height={})".format(self.block_hash, self.height)

    def __eq__(self, other):
        if self.block_hash != other.block_hash:
            return False
        if self.height != other.height:
            return False
        return True

class _UniffiConverterTypeBestBlock(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BestBlock(
            block_hash=_UniffiConverterTypeBlockHash.read(buf),
            height=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBlockHash.check_lower(value.block_hash)
        _UniffiConverterUInt32.check_lower(value.height)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBlockHash.write(value.block_hash, buf)
        _UniffiConverterUInt32.write(value.height, buf)


class ChannelConfig:
    forwarding_fee_proportional_millionths: "int"
    forwarding_fee_base_msat: "int"
    cltv_expiry_delta: "int"
    max_dust_htlc_exposure: "MaxDustHtlcExposure"
    force_close_avoidance_max_fee_satoshis: "int"
    accept_underpaying_htlcs: "bool"
    def __init__(self, *, forwarding_fee_proportional_millionths: "int", forwarding_fee_base_msat: "int", cltv_expiry_delta: "int", max_dust_htlc_exposure: "MaxDustHtlcExposure", force_close_avoidance_max_fee_satoshis: "int", accept_underpaying_htlcs: "bool"):
        self.forwarding_fee_proportional_millionths = forwarding_fee_proportional_millionths
        self.forwarding_fee_base_msat = forwarding_fee_base_msat
        self.cltv_expiry_delta = cltv_expiry_delta
        self.max_dust_htlc_exposure = max_dust_htlc_exposure
        self.force_close_avoidance_max_fee_satoshis = force_close_avoidance_max_fee_satoshis
        self.accept_underpaying_htlcs = accept_underpaying_htlcs

    def __str__(self):
        return "ChannelConfig(forwarding_fee_proportional_millionths={}, forwarding_fee_base_msat={}, cltv_expiry_delta={}, max_dust_htlc_exposure={}, force_close_avoidance_max_fee_satoshis={}, accept_underpaying_htlcs={})".format(self.forwarding_fee_proportional_millionths, self.forwarding_fee_base_msat, self.cltv_expiry_delta, self.max_dust_htlc_exposure, self.force_close_avoidance_max_fee_satoshis, self.accept_underpaying_htlcs)

    def __eq__(self, other):
        if self.forwarding_fee_proportional_millionths != other.forwarding_fee_proportional_millionths:
            return False
        if self.forwarding_fee_base_msat != other.forwarding_fee_base_msat:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.max_dust_htlc_exposure != other.max_dust_htlc_exposure:
            return False
        if self.force_close_avoidance_max_fee_satoshis != other.force_close_avoidance_max_fee_satoshis:
            return False
        if self.accept_underpaying_htlcs != other.accept_underpaying_htlcs:
            return False
        return True

class _UniffiConverterTypeChannelConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelConfig(
            forwarding_fee_proportional_millionths=_UniffiConverterUInt32.read(buf),
            forwarding_fee_base_msat=_UniffiConverterUInt32.read(buf),
            cltv_expiry_delta=_UniffiConverterUInt16.read(buf),
            max_dust_htlc_exposure=_UniffiConverterTypeMaxDustHtlcExposure.read(buf),
            force_close_avoidance_max_fee_satoshis=_UniffiConverterUInt64.read(buf),
            accept_underpaying_htlcs=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.forwarding_fee_proportional_millionths)
        _UniffiConverterUInt32.check_lower(value.forwarding_fee_base_msat)
        _UniffiConverterUInt16.check_lower(value.cltv_expiry_delta)
        _UniffiConverterTypeMaxDustHtlcExposure.check_lower(value.max_dust_htlc_exposure)
        _UniffiConverterUInt64.check_lower(value.force_close_avoidance_max_fee_satoshis)
        _UniffiConverterBool.check_lower(value.accept_underpaying_htlcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.forwarding_fee_proportional_millionths, buf)
        _UniffiConverterUInt32.write(value.forwarding_fee_base_msat, buf)
        _UniffiConverterUInt16.write(value.cltv_expiry_delta, buf)
        _UniffiConverterTypeMaxDustHtlcExposure.write(value.max_dust_htlc_exposure, buf)
        _UniffiConverterUInt64.write(value.force_close_avoidance_max_fee_satoshis, buf)
        _UniffiConverterBool.write(value.accept_underpaying_htlcs, buf)


class ChannelDataMigration:
    channel_manager: "typing.Optional[typing.List[int]]"
    channel_monitors: "typing.List[typing.List[int]]"
    def __init__(self, *, channel_manager: "typing.Optional[typing.List[int]]", channel_monitors: "typing.List[typing.List[int]]"):
        self.channel_manager = channel_manager
        self.channel_monitors = channel_monitors

    def __str__(self):
        return "ChannelDataMigration(channel_manager={}, channel_monitors={})".format(self.channel_manager, self.channel_monitors)

    def __eq__(self, other):
        if self.channel_manager != other.channel_manager:
            return False
        if self.channel_monitors != other.channel_monitors:
            return False
        return True

class _UniffiConverterTypeChannelDataMigration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelDataMigration(
            channel_manager=_UniffiConverterOptionalSequenceUInt8.read(buf),
            channel_monitors=_UniffiConverterSequenceSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceUInt8.check_lower(value.channel_manager)
        _UniffiConverterSequenceSequenceUInt8.check_lower(value.channel_monitors)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceUInt8.write(value.channel_manager, buf)
        _UniffiConverterSequenceSequenceUInt8.write(value.channel_monitors, buf)


class ChannelDetails:
    channel_id: "ChannelId"
    counterparty_node_id: "PublicKey"
    funding_txo: "typing.Optional[OutPoint]"
    short_channel_id: "typing.Optional[int]"
    outbound_scid_alias: "typing.Optional[int]"
    inbound_scid_alias: "typing.Optional[int]"
    channel_value_sats: "int"
    unspendable_punishment_reserve: "typing.Optional[int]"
    user_channel_id: "UserChannelId"
    feerate_sat_per_1000_weight: "int"
    outbound_capacity_msat: "int"
    inbound_capacity_msat: "int"
    confirmations_required: "typing.Optional[int]"
    confirmations: "typing.Optional[int]"
    is_outbound: "bool"
    is_channel_ready: "bool"
    is_usable: "bool"
    is_announced: "bool"
    cltv_expiry_delta: "typing.Optional[int]"
    counterparty_unspendable_punishment_reserve: "int"
    counterparty_outbound_htlc_minimum_msat: "typing.Optional[int]"
    counterparty_outbound_htlc_maximum_msat: "typing.Optional[int]"
    counterparty_forwarding_info_fee_base_msat: "typing.Optional[int]"
    counterparty_forwarding_info_fee_proportional_millionths: "typing.Optional[int]"
    counterparty_forwarding_info_cltv_expiry_delta: "typing.Optional[int]"
    next_outbound_htlc_limit_msat: "int"
    next_outbound_htlc_minimum_msat: "int"
    force_close_spend_delay: "typing.Optional[int]"
    inbound_htlc_minimum_msat: "int"
    inbound_htlc_maximum_msat: "typing.Optional[int]"
    config: "ChannelConfig"
    def __init__(self, *, channel_id: "ChannelId", counterparty_node_id: "PublicKey", funding_txo: "typing.Optional[OutPoint]", short_channel_id: "typing.Optional[int]", outbound_scid_alias: "typing.Optional[int]", inbound_scid_alias: "typing.Optional[int]", channel_value_sats: "int", unspendable_punishment_reserve: "typing.Optional[int]", user_channel_id: "UserChannelId", feerate_sat_per_1000_weight: "int", outbound_capacity_msat: "int", inbound_capacity_msat: "int", confirmations_required: "typing.Optional[int]", confirmations: "typing.Optional[int]", is_outbound: "bool", is_channel_ready: "bool", is_usable: "bool", is_announced: "bool", cltv_expiry_delta: "typing.Optional[int]", counterparty_unspendable_punishment_reserve: "int", counterparty_outbound_htlc_minimum_msat: "typing.Optional[int]", counterparty_outbound_htlc_maximum_msat: "typing.Optional[int]", counterparty_forwarding_info_fee_base_msat: "typing.Optional[int]", counterparty_forwarding_info_fee_proportional_millionths: "typing.Optional[int]", counterparty_forwarding_info_cltv_expiry_delta: "typing.Optional[int]", next_outbound_htlc_limit_msat: "int", next_outbound_htlc_minimum_msat: "int", force_close_spend_delay: "typing.Optional[int]", inbound_htlc_minimum_msat: "int", inbound_htlc_maximum_msat: "typing.Optional[int]", config: "ChannelConfig"):
        self.channel_id = channel_id
        self.counterparty_node_id = counterparty_node_id
        self.funding_txo = funding_txo
        self.short_channel_id = short_channel_id
        self.outbound_scid_alias = outbound_scid_alias
        self.inbound_scid_alias = inbound_scid_alias
        self.channel_value_sats = channel_value_sats
        self.unspendable_punishment_reserve = unspendable_punishment_reserve
        self.user_channel_id = user_channel_id
        self.feerate_sat_per_1000_weight = feerate_sat_per_1000_weight
        self.outbound_capacity_msat = outbound_capacity_msat
        self.inbound_capacity_msat = inbound_capacity_msat
        self.confirmations_required = confirmations_required
        self.confirmations = confirmations
        self.is_outbound = is_outbound
        self.is_channel_ready = is_channel_ready
        self.is_usable = is_usable
        self.is_announced = is_announced
        self.cltv_expiry_delta = cltv_expiry_delta
        self.counterparty_unspendable_punishment_reserve = counterparty_unspendable_punishment_reserve
        self.counterparty_outbound_htlc_minimum_msat = counterparty_outbound_htlc_minimum_msat
        self.counterparty_outbound_htlc_maximum_msat = counterparty_outbound_htlc_maximum_msat
        self.counterparty_forwarding_info_fee_base_msat = counterparty_forwarding_info_fee_base_msat
        self.counterparty_forwarding_info_fee_proportional_millionths = counterparty_forwarding_info_fee_proportional_millionths
        self.counterparty_forwarding_info_cltv_expiry_delta = counterparty_forwarding_info_cltv_expiry_delta
        self.next_outbound_htlc_limit_msat = next_outbound_htlc_limit_msat
        self.next_outbound_htlc_minimum_msat = next_outbound_htlc_minimum_msat
        self.force_close_spend_delay = force_close_spend_delay
        self.inbound_htlc_minimum_msat = inbound_htlc_minimum_msat
        self.inbound_htlc_maximum_msat = inbound_htlc_maximum_msat
        self.config = config

    def __str__(self):
        return "ChannelDetails(channel_id={}, counterparty_node_id={}, funding_txo={}, short_channel_id={}, outbound_scid_alias={}, inbound_scid_alias={}, channel_value_sats={}, unspendable_punishment_reserve={}, user_channel_id={}, feerate_sat_per_1000_weight={}, outbound_capacity_msat={}, inbound_capacity_msat={}, confirmations_required={}, confirmations={}, is_outbound={}, is_channel_ready={}, is_usable={}, is_announced={}, cltv_expiry_delta={}, counterparty_unspendable_punishment_reserve={}, counterparty_outbound_htlc_minimum_msat={}, counterparty_outbound_htlc_maximum_msat={}, counterparty_forwarding_info_fee_base_msat={}, counterparty_forwarding_info_fee_proportional_millionths={}, counterparty_forwarding_info_cltv_expiry_delta={}, next_outbound_htlc_limit_msat={}, next_outbound_htlc_minimum_msat={}, force_close_spend_delay={}, inbound_htlc_minimum_msat={}, inbound_htlc_maximum_msat={}, config={})".format(self.channel_id, self.counterparty_node_id, self.funding_txo, self.short_channel_id, self.outbound_scid_alias, self.inbound_scid_alias, self.channel_value_sats, self.unspendable_punishment_reserve, self.user_channel_id, self.feerate_sat_per_1000_weight, self.outbound_capacity_msat, self.inbound_capacity_msat, self.confirmations_required, self.confirmations, self.is_outbound, self.is_channel_ready, self.is_usable, self.is_announced, self.cltv_expiry_delta, self.counterparty_unspendable_punishment_reserve, self.counterparty_outbound_htlc_minimum_msat, self.counterparty_outbound_htlc_maximum_msat, self.counterparty_forwarding_info_fee_base_msat, self.counterparty_forwarding_info_fee_proportional_millionths, self.counterparty_forwarding_info_cltv_expiry_delta, self.next_outbound_htlc_limit_msat, self.next_outbound_htlc_minimum_msat, self.force_close_spend_delay, self.inbound_htlc_minimum_msat, self.inbound_htlc_maximum_msat, self.config)

    def __eq__(self, other):
        if self.channel_id != other.channel_id:
            return False
        if self.counterparty_node_id != other.counterparty_node_id:
            return False
        if self.funding_txo != other.funding_txo:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.outbound_scid_alias != other.outbound_scid_alias:
            return False
        if self.inbound_scid_alias != other.inbound_scid_alias:
            return False
        if self.channel_value_sats != other.channel_value_sats:
            return False
        if self.unspendable_punishment_reserve != other.unspendable_punishment_reserve:
            return False
        if self.user_channel_id != other.user_channel_id:
            return False
        if self.feerate_sat_per_1000_weight != other.feerate_sat_per_1000_weight:
            return False
        if self.outbound_capacity_msat != other.outbound_capacity_msat:
            return False
        if self.inbound_capacity_msat != other.inbound_capacity_msat:
            return False
        if self.confirmations_required != other.confirmations_required:
            return False
        if self.confirmations != other.confirmations:
            return False
        if self.is_outbound != other.is_outbound:
            return False
        if self.is_channel_ready != other.is_channel_ready:
            return False
        if self.is_usable != other.is_usable:
            return False
        if self.is_announced != other.is_announced:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.counterparty_unspendable_punishment_reserve != other.counterparty_unspendable_punishment_reserve:
            return False
        if self.counterparty_outbound_htlc_minimum_msat != other.counterparty_outbound_htlc_minimum_msat:
            return False
        if self.counterparty_outbound_htlc_maximum_msat != other.counterparty_outbound_htlc_maximum_msat:
            return False
        if self.counterparty_forwarding_info_fee_base_msat != other.counterparty_forwarding_info_fee_base_msat:
            return False
        if self.counterparty_forwarding_info_fee_proportional_millionths != other.counterparty_forwarding_info_fee_proportional_millionths:
            return False
        if self.counterparty_forwarding_info_cltv_expiry_delta != other.counterparty_forwarding_info_cltv_expiry_delta:
            return False
        if self.next_outbound_htlc_limit_msat != other.next_outbound_htlc_limit_msat:
            return False
        if self.next_outbound_htlc_minimum_msat != other.next_outbound_htlc_minimum_msat:
            return False
        if self.force_close_spend_delay != other.force_close_spend_delay:
            return False
        if self.inbound_htlc_minimum_msat != other.inbound_htlc_minimum_msat:
            return False
        if self.inbound_htlc_maximum_msat != other.inbound_htlc_maximum_msat:
            return False
        if self.config != other.config:
            return False
        return True

class _UniffiConverterTypeChannelDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelDetails(
            channel_id=_UniffiConverterTypeChannelId.read(buf),
            counterparty_node_id=_UniffiConverterTypePublicKey.read(buf),
            funding_txo=_UniffiConverterOptionalTypeOutPoint.read(buf),
            short_channel_id=_UniffiConverterOptionalUInt64.read(buf),
            outbound_scid_alias=_UniffiConverterOptionalUInt64.read(buf),
            inbound_scid_alias=_UniffiConverterOptionalUInt64.read(buf),
            channel_value_sats=_UniffiConverterUInt64.read(buf),
            unspendable_punishment_reserve=_UniffiConverterOptionalUInt64.read(buf),
            user_channel_id=_UniffiConverterTypeUserChannelId.read(buf),
            feerate_sat_per_1000_weight=_UniffiConverterUInt32.read(buf),
            outbound_capacity_msat=_UniffiConverterUInt64.read(buf),
            inbound_capacity_msat=_UniffiConverterUInt64.read(buf),
            confirmations_required=_UniffiConverterOptionalUInt32.read(buf),
            confirmations=_UniffiConverterOptionalUInt32.read(buf),
            is_outbound=_UniffiConverterBool.read(buf),
            is_channel_ready=_UniffiConverterBool.read(buf),
            is_usable=_UniffiConverterBool.read(buf),
            is_announced=_UniffiConverterBool.read(buf),
            cltv_expiry_delta=_UniffiConverterOptionalUInt16.read(buf),
            counterparty_unspendable_punishment_reserve=_UniffiConverterUInt64.read(buf),
            counterparty_outbound_htlc_minimum_msat=_UniffiConverterOptionalUInt64.read(buf),
            counterparty_outbound_htlc_maximum_msat=_UniffiConverterOptionalUInt64.read(buf),
            counterparty_forwarding_info_fee_base_msat=_UniffiConverterOptionalUInt32.read(buf),
            counterparty_forwarding_info_fee_proportional_millionths=_UniffiConverterOptionalUInt32.read(buf),
            counterparty_forwarding_info_cltv_expiry_delta=_UniffiConverterOptionalUInt16.read(buf),
            next_outbound_htlc_limit_msat=_UniffiConverterUInt64.read(buf),
            next_outbound_htlc_minimum_msat=_UniffiConverterUInt64.read(buf),
            force_close_spend_delay=_UniffiConverterOptionalUInt16.read(buf),
            inbound_htlc_minimum_msat=_UniffiConverterUInt64.read(buf),
            inbound_htlc_maximum_msat=_UniffiConverterOptionalUInt64.read(buf),
            config=_UniffiConverterTypeChannelConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeChannelId.check_lower(value.channel_id)
        _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
        _UniffiConverterOptionalTypeOutPoint.check_lower(value.funding_txo)
        _UniffiConverterOptionalUInt64.check_lower(value.short_channel_id)
        _UniffiConverterOptionalUInt64.check_lower(value.outbound_scid_alias)
        _UniffiConverterOptionalUInt64.check_lower(value.inbound_scid_alias)
        _UniffiConverterUInt64.check_lower(value.channel_value_sats)
        _UniffiConverterOptionalUInt64.check_lower(value.unspendable_punishment_reserve)
        _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
        _UniffiConverterUInt32.check_lower(value.feerate_sat_per_1000_weight)
        _UniffiConverterUInt64.check_lower(value.outbound_capacity_msat)
        _UniffiConverterUInt64.check_lower(value.inbound_capacity_msat)
        _UniffiConverterOptionalUInt32.check_lower(value.confirmations_required)
        _UniffiConverterOptionalUInt32.check_lower(value.confirmations)
        _UniffiConverterBool.check_lower(value.is_outbound)
        _UniffiConverterBool.check_lower(value.is_channel_ready)
        _UniffiConverterBool.check_lower(value.is_usable)
        _UniffiConverterBool.check_lower(value.is_announced)
        _UniffiConverterOptionalUInt16.check_lower(value.cltv_expiry_delta)
        _UniffiConverterUInt64.check_lower(value.counterparty_unspendable_punishment_reserve)
        _UniffiConverterOptionalUInt64.check_lower(value.counterparty_outbound_htlc_minimum_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.counterparty_outbound_htlc_maximum_msat)
        _UniffiConverterOptionalUInt32.check_lower(value.counterparty_forwarding_info_fee_base_msat)
        _UniffiConverterOptionalUInt32.check_lower(value.counterparty_forwarding_info_fee_proportional_millionths)
        _UniffiConverterOptionalUInt16.check_lower(value.counterparty_forwarding_info_cltv_expiry_delta)
        _UniffiConverterUInt64.check_lower(value.next_outbound_htlc_limit_msat)
        _UniffiConverterUInt64.check_lower(value.next_outbound_htlc_minimum_msat)
        _UniffiConverterOptionalUInt16.check_lower(value.force_close_spend_delay)
        _UniffiConverterUInt64.check_lower(value.inbound_htlc_minimum_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.inbound_htlc_maximum_msat)
        _UniffiConverterTypeChannelConfig.check_lower(value.config)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeChannelId.write(value.channel_id, buf)
        _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
        _UniffiConverterOptionalTypeOutPoint.write(value.funding_txo, buf)
        _UniffiConverterOptionalUInt64.write(value.short_channel_id, buf)
        _UniffiConverterOptionalUInt64.write(value.outbound_scid_alias, buf)
        _UniffiConverterOptionalUInt64.write(value.inbound_scid_alias, buf)
        _UniffiConverterUInt64.write(value.channel_value_sats, buf)
        _UniffiConverterOptionalUInt64.write(value.unspendable_punishment_reserve, buf)
        _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
        _UniffiConverterUInt32.write(value.feerate_sat_per_1000_weight, buf)
        _UniffiConverterUInt64.write(value.outbound_capacity_msat, buf)
        _UniffiConverterUInt64.write(value.inbound_capacity_msat, buf)
        _UniffiConverterOptionalUInt32.write(value.confirmations_required, buf)
        _UniffiConverterOptionalUInt32.write(value.confirmations, buf)
        _UniffiConverterBool.write(value.is_outbound, buf)
        _UniffiConverterBool.write(value.is_channel_ready, buf)
        _UniffiConverterBool.write(value.is_usable, buf)
        _UniffiConverterBool.write(value.is_announced, buf)
        _UniffiConverterOptionalUInt16.write(value.cltv_expiry_delta, buf)
        _UniffiConverterUInt64.write(value.counterparty_unspendable_punishment_reserve, buf)
        _UniffiConverterOptionalUInt64.write(value.counterparty_outbound_htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.counterparty_outbound_htlc_maximum_msat, buf)
        _UniffiConverterOptionalUInt32.write(value.counterparty_forwarding_info_fee_base_msat, buf)
        _UniffiConverterOptionalUInt32.write(value.counterparty_forwarding_info_fee_proportional_millionths, buf)
        _UniffiConverterOptionalUInt16.write(value.counterparty_forwarding_info_cltv_expiry_delta, buf)
        _UniffiConverterUInt64.write(value.next_outbound_htlc_limit_msat, buf)
        _UniffiConverterUInt64.write(value.next_outbound_htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt16.write(value.force_close_spend_delay, buf)
        _UniffiConverterUInt64.write(value.inbound_htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.inbound_htlc_maximum_msat, buf)
        _UniffiConverterTypeChannelConfig.write(value.config, buf)


class ChannelInfo:
    node_one: "NodeId"
    one_to_two: "typing.Optional[ChannelUpdateInfo]"
    node_two: "NodeId"
    two_to_one: "typing.Optional[ChannelUpdateInfo]"
    capacity_sats: "typing.Optional[int]"
    def __init__(self, *, node_one: "NodeId", one_to_two: "typing.Optional[ChannelUpdateInfo]", node_two: "NodeId", two_to_one: "typing.Optional[ChannelUpdateInfo]", capacity_sats: "typing.Optional[int]"):
        self.node_one = node_one
        self.one_to_two = one_to_two
        self.node_two = node_two
        self.two_to_one = two_to_one
        self.capacity_sats = capacity_sats

    def __str__(self):
        return "ChannelInfo(node_one={}, one_to_two={}, node_two={}, two_to_one={}, capacity_sats={})".format(self.node_one, self.one_to_two, self.node_two, self.two_to_one, self.capacity_sats)

    def __eq__(self, other):
        if self.node_one != other.node_one:
            return False
        if self.one_to_two != other.one_to_two:
            return False
        if self.node_two != other.node_two:
            return False
        if self.two_to_one != other.two_to_one:
            return False
        if self.capacity_sats != other.capacity_sats:
            return False
        return True

class _UniffiConverterTypeChannelInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelInfo(
            node_one=_UniffiConverterTypeNodeId.read(buf),
            one_to_two=_UniffiConverterOptionalTypeChannelUpdateInfo.read(buf),
            node_two=_UniffiConverterTypeNodeId.read(buf),
            two_to_one=_UniffiConverterOptionalTypeChannelUpdateInfo.read(buf),
            capacity_sats=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeNodeId.check_lower(value.node_one)
        _UniffiConverterOptionalTypeChannelUpdateInfo.check_lower(value.one_to_two)
        _UniffiConverterTypeNodeId.check_lower(value.node_two)
        _UniffiConverterOptionalTypeChannelUpdateInfo.check_lower(value.two_to_one)
        _UniffiConverterOptionalUInt64.check_lower(value.capacity_sats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeNodeId.write(value.node_one, buf)
        _UniffiConverterOptionalTypeChannelUpdateInfo.write(value.one_to_two, buf)
        _UniffiConverterTypeNodeId.write(value.node_two, buf)
        _UniffiConverterOptionalTypeChannelUpdateInfo.write(value.two_to_one, buf)
        _UniffiConverterOptionalUInt64.write(value.capacity_sats, buf)


class ChannelUpdateInfo:
    last_update: "int"
    enabled: "bool"
    cltv_expiry_delta: "int"
    htlc_minimum_msat: "int"
    htlc_maximum_msat: "int"
    fees: "RoutingFees"
    def __init__(self, *, last_update: "int", enabled: "bool", cltv_expiry_delta: "int", htlc_minimum_msat: "int", htlc_maximum_msat: "int", fees: "RoutingFees"):
        self.last_update = last_update
        self.enabled = enabled
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat
        self.fees = fees

    def __str__(self):
        return "ChannelUpdateInfo(last_update={}, enabled={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={}, fees={})".format(self.last_update, self.enabled, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat, self.fees)

    def __eq__(self, other):
        if self.last_update != other.last_update:
            return False
        if self.enabled != other.enabled:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        if self.fees != other.fees:
            return False
        return True

class _UniffiConverterTypeChannelUpdateInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChannelUpdateInfo(
            last_update=_UniffiConverterUInt32.read(buf),
            enabled=_UniffiConverterBool.read(buf),
            cltv_expiry_delta=_UniffiConverterUInt16.read(buf),
            htlc_minimum_msat=_UniffiConverterUInt64.read(buf),
            htlc_maximum_msat=_UniffiConverterUInt64.read(buf),
            fees=_UniffiConverterTypeRoutingFees.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.last_update)
        _UniffiConverterBool.check_lower(value.enabled)
        _UniffiConverterUInt16.check_lower(value.cltv_expiry_delta)
        _UniffiConverterUInt64.check_lower(value.htlc_minimum_msat)
        _UniffiConverterUInt64.check_lower(value.htlc_maximum_msat)
        _UniffiConverterTypeRoutingFees.check_lower(value.fees)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.last_update, buf)
        _UniffiConverterBool.write(value.enabled, buf)
        _UniffiConverterUInt16.write(value.cltv_expiry_delta, buf)
        _UniffiConverterUInt64.write(value.htlc_minimum_msat, buf)
        _UniffiConverterUInt64.write(value.htlc_maximum_msat, buf)
        _UniffiConverterTypeRoutingFees.write(value.fees, buf)


class Config:
    storage_dir_path: "str"
    network: "Network"
    listening_addresses: "typing.Optional[typing.List[SocketAddress]]"
    announcement_addresses: "typing.Optional[typing.List[SocketAddress]]"
    node_alias: "typing.Optional[NodeAlias]"
    trusted_peers_0conf: "typing.List[PublicKey]"
    probing_liquidity_limit_multiplier: "int"
    anchor_channels_config: "typing.Optional[AnchorChannelsConfig]"
    route_parameters: "typing.Optional[RouteParametersConfig]"
    include_untrusted_pending_in_spendable: "bool"
    def __init__(self, *, storage_dir_path: "str", network: "Network", listening_addresses: "typing.Optional[typing.List[SocketAddress]]", announcement_addresses: "typing.Optional[typing.List[SocketAddress]]", node_alias: "typing.Optional[NodeAlias]", trusted_peers_0conf: "typing.List[PublicKey]", probing_liquidity_limit_multiplier: "int", anchor_channels_config: "typing.Optional[AnchorChannelsConfig]", route_parameters: "typing.Optional[RouteParametersConfig]", include_untrusted_pending_in_spendable: "bool"):
        self.storage_dir_path = storage_dir_path
        self.network = network
        self.listening_addresses = listening_addresses
        self.announcement_addresses = announcement_addresses
        self.node_alias = node_alias
        self.trusted_peers_0conf = trusted_peers_0conf
        self.probing_liquidity_limit_multiplier = probing_liquidity_limit_multiplier
        self.anchor_channels_config = anchor_channels_config
        self.route_parameters = route_parameters
        self.include_untrusted_pending_in_spendable = include_untrusted_pending_in_spendable

    def __str__(self):
        return "Config(storage_dir_path={}, network={}, listening_addresses={}, announcement_addresses={}, node_alias={}, trusted_peers_0conf={}, probing_liquidity_limit_multiplier={}, anchor_channels_config={}, route_parameters={}, include_untrusted_pending_in_spendable={})".format(self.storage_dir_path, self.network, self.listening_addresses, self.announcement_addresses, self.node_alias, self.trusted_peers_0conf, self.probing_liquidity_limit_multiplier, self.anchor_channels_config, self.route_parameters, self.include_untrusted_pending_in_spendable)

    def __eq__(self, other):
        if self.storage_dir_path != other.storage_dir_path:
            return False
        if self.network != other.network:
            return False
        if self.listening_addresses != other.listening_addresses:
            return False
        if self.announcement_addresses != other.announcement_addresses:
            return False
        if self.node_alias != other.node_alias:
            return False
        if self.trusted_peers_0conf != other.trusted_peers_0conf:
            return False
        if self.probing_liquidity_limit_multiplier != other.probing_liquidity_limit_multiplier:
            return False
        if self.anchor_channels_config != other.anchor_channels_config:
            return False
        if self.route_parameters != other.route_parameters:
            return False
        if self.include_untrusted_pending_in_spendable != other.include_untrusted_pending_in_spendable:
            return False
        return True

class _UniffiConverterTypeConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Config(
            storage_dir_path=_UniffiConverterString.read(buf),
            network=_UniffiConverterTypeNetwork.read(buf),
            listening_addresses=_UniffiConverterOptionalSequenceTypeSocketAddress.read(buf),
            announcement_addresses=_UniffiConverterOptionalSequenceTypeSocketAddress.read(buf),
            node_alias=_UniffiConverterOptionalTypeNodeAlias.read(buf),
            trusted_peers_0conf=_UniffiConverterSequenceTypePublicKey.read(buf),
            probing_liquidity_limit_multiplier=_UniffiConverterUInt64.read(buf),
            anchor_channels_config=_UniffiConverterOptionalTypeAnchorChannelsConfig.read(buf),
            route_parameters=_UniffiConverterOptionalTypeRouteParametersConfig.read(buf),
            include_untrusted_pending_in_spendable=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.storage_dir_path)
        _UniffiConverterTypeNetwork.check_lower(value.network)
        _UniffiConverterOptionalSequenceTypeSocketAddress.check_lower(value.listening_addresses)
        _UniffiConverterOptionalSequenceTypeSocketAddress.check_lower(value.announcement_addresses)
        _UniffiConverterOptionalTypeNodeAlias.check_lower(value.node_alias)
        _UniffiConverterSequenceTypePublicKey.check_lower(value.trusted_peers_0conf)
        _UniffiConverterUInt64.check_lower(value.probing_liquidity_limit_multiplier)
        _UniffiConverterOptionalTypeAnchorChannelsConfig.check_lower(value.anchor_channels_config)
        _UniffiConverterOptionalTypeRouteParametersConfig.check_lower(value.route_parameters)
        _UniffiConverterBool.check_lower(value.include_untrusted_pending_in_spendable)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.storage_dir_path, buf)
        _UniffiConverterTypeNetwork.write(value.network, buf)
        _UniffiConverterOptionalSequenceTypeSocketAddress.write(value.listening_addresses, buf)
        _UniffiConverterOptionalSequenceTypeSocketAddress.write(value.announcement_addresses, buf)
        _UniffiConverterOptionalTypeNodeAlias.write(value.node_alias, buf)
        _UniffiConverterSequenceTypePublicKey.write(value.trusted_peers_0conf, buf)
        _UniffiConverterUInt64.write(value.probing_liquidity_limit_multiplier, buf)
        _UniffiConverterOptionalTypeAnchorChannelsConfig.write(value.anchor_channels_config, buf)
        _UniffiConverterOptionalTypeRouteParametersConfig.write(value.route_parameters, buf)
        _UniffiConverterBool.write(value.include_untrusted_pending_in_spendable, buf)


class CustomTlvRecord:
    type_num: "int"
    value: "typing.List[int]"
    def __init__(self, *, type_num: "int", value: "typing.List[int]"):
        self.type_num = type_num
        self.value = value

    def __str__(self):
        return "CustomTlvRecord(type_num={}, value={})".format(self.type_num, self.value)

    def __eq__(self, other):
        if self.type_num != other.type_num:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeCustomTlvRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CustomTlvRecord(
            type_num=_UniffiConverterUInt64.read(buf),
            value=_UniffiConverterSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.type_num)
        _UniffiConverterSequenceUInt8.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.type_num, buf)
        _UniffiConverterSequenceUInt8.write(value.value, buf)


class ElectrumSyncConfig:
    background_sync_config: "typing.Optional[BackgroundSyncConfig]"
    def __init__(self, *, background_sync_config: "typing.Optional[BackgroundSyncConfig]"):
        self.background_sync_config = background_sync_config

    def __str__(self):
        return "ElectrumSyncConfig(background_sync_config={})".format(self.background_sync_config)

    def __eq__(self, other):
        if self.background_sync_config != other.background_sync_config:
            return False
        return True

class _UniffiConverterTypeElectrumSyncConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ElectrumSyncConfig(
            background_sync_config=_UniffiConverterOptionalTypeBackgroundSyncConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeBackgroundSyncConfig.check_lower(value.background_sync_config)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeBackgroundSyncConfig.write(value.background_sync_config, buf)


class EsploraSyncConfig:
    background_sync_config: "typing.Optional[BackgroundSyncConfig]"
    def __init__(self, *, background_sync_config: "typing.Optional[BackgroundSyncConfig]"):
        self.background_sync_config = background_sync_config

    def __str__(self):
        return "EsploraSyncConfig(background_sync_config={})".format(self.background_sync_config)

    def __eq__(self, other):
        if self.background_sync_config != other.background_sync_config:
            return False
        return True

class _UniffiConverterTypeEsploraSyncConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EsploraSyncConfig(
            background_sync_config=_UniffiConverterOptionalTypeBackgroundSyncConfig.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeBackgroundSyncConfig.check_lower(value.background_sync_config)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeBackgroundSyncConfig.write(value.background_sync_config, buf)


class LogRecord:
    level: "LogLevel"
    args: "str"
    module_path: "str"
    line: "int"
    def __init__(self, *, level: "LogLevel", args: "str", module_path: "str", line: "int"):
        self.level = level
        self.args = args
        self.module_path = module_path
        self.line = line

    def __str__(self):
        return "LogRecord(level={}, args={}, module_path={}, line={})".format(self.level, self.args, self.module_path, self.line)

    def __eq__(self, other):
        if self.level != other.level:
            return False
        if self.args != other.args:
            return False
        if self.module_path != other.module_path:
            return False
        if self.line != other.line:
            return False
        return True

class _UniffiConverterTypeLogRecord(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LogRecord(
            level=_UniffiConverterTypeLogLevel.read(buf),
            args=_UniffiConverterString.read(buf),
            module_path=_UniffiConverterString.read(buf),
            line=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLogLevel.check_lower(value.level)
        _UniffiConverterString.check_lower(value.args)
        _UniffiConverterString.check_lower(value.module_path)
        _UniffiConverterUInt32.check_lower(value.line)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLogLevel.write(value.level, buf)
        _UniffiConverterString.write(value.args, buf)
        _UniffiConverterString.write(value.module_path, buf)
        _UniffiConverterUInt32.write(value.line, buf)


class LspFeeLimits:
    max_total_opening_fee_msat: "typing.Optional[int]"
    max_proportional_opening_fee_ppm_msat: "typing.Optional[int]"
    def __init__(self, *, max_total_opening_fee_msat: "typing.Optional[int]", max_proportional_opening_fee_ppm_msat: "typing.Optional[int]"):
        self.max_total_opening_fee_msat = max_total_opening_fee_msat
        self.max_proportional_opening_fee_ppm_msat = max_proportional_opening_fee_ppm_msat

    def __str__(self):
        return "LspFeeLimits(max_total_opening_fee_msat={}, max_proportional_opening_fee_ppm_msat={})".format(self.max_total_opening_fee_msat, self.max_proportional_opening_fee_ppm_msat)

    def __eq__(self, other):
        if self.max_total_opening_fee_msat != other.max_total_opening_fee_msat:
            return False
        if self.max_proportional_opening_fee_ppm_msat != other.max_proportional_opening_fee_ppm_msat:
            return False
        return True

class _UniffiConverterTypeLspFeeLimits(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LspFeeLimits(
            max_total_opening_fee_msat=_UniffiConverterOptionalUInt64.read(buf),
            max_proportional_opening_fee_ppm_msat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.max_total_opening_fee_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.max_proportional_opening_fee_ppm_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.max_total_opening_fee_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.max_proportional_opening_fee_ppm_msat, buf)


class Lsps1Bolt11PaymentInfo:
    state: "Lsps1PaymentState"
    expires_at: "LspsDateTime"
    fee_total_sat: "int"
    order_total_sat: "int"
    invoice: "Bolt11Invoice"
    def __init__(self, *, state: "Lsps1PaymentState", expires_at: "LspsDateTime", fee_total_sat: "int", order_total_sat: "int", invoice: "Bolt11Invoice"):
        self.state = state
        self.expires_at = expires_at
        self.fee_total_sat = fee_total_sat
        self.order_total_sat = order_total_sat
        self.invoice = invoice

    def __str__(self):
        return "Lsps1Bolt11PaymentInfo(state={}, expires_at={}, fee_total_sat={}, order_total_sat={}, invoice={})".format(self.state, self.expires_at, self.fee_total_sat, self.order_total_sat, self.invoice)

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.fee_total_sat != other.fee_total_sat:
            return False
        if self.order_total_sat != other.order_total_sat:
            return False
        if self.invoice != other.invoice:
            return False
        return True

class _UniffiConverterTypeLsps1Bolt11PaymentInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1Bolt11PaymentInfo(
            state=_UniffiConverterTypeLsps1PaymentState.read(buf),
            expires_at=_UniffiConverterTypeLspsDateTime.read(buf),
            fee_total_sat=_UniffiConverterUInt64.read(buf),
            order_total_sat=_UniffiConverterUInt64.read(buf),
            invoice=_UniffiConverterTypeBolt11Invoice.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLsps1PaymentState.check_lower(value.state)
        _UniffiConverterTypeLspsDateTime.check_lower(value.expires_at)
        _UniffiConverterUInt64.check_lower(value.fee_total_sat)
        _UniffiConverterUInt64.check_lower(value.order_total_sat)
        _UniffiConverterTypeBolt11Invoice.check_lower(value.invoice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLsps1PaymentState.write(value.state, buf)
        _UniffiConverterTypeLspsDateTime.write(value.expires_at, buf)
        _UniffiConverterUInt64.write(value.fee_total_sat, buf)
        _UniffiConverterUInt64.write(value.order_total_sat, buf)
        _UniffiConverterTypeBolt11Invoice.write(value.invoice, buf)


class Lsps1ChannelInfo:
    funded_at: "LspsDateTime"
    funding_outpoint: "OutPoint"
    expires_at: "LspsDateTime"
    def __init__(self, *, funded_at: "LspsDateTime", funding_outpoint: "OutPoint", expires_at: "LspsDateTime"):
        self.funded_at = funded_at
        self.funding_outpoint = funding_outpoint
        self.expires_at = expires_at

    def __str__(self):
        return "Lsps1ChannelInfo(funded_at={}, funding_outpoint={}, expires_at={})".format(self.funded_at, self.funding_outpoint, self.expires_at)

    def __eq__(self, other):
        if self.funded_at != other.funded_at:
            return False
        if self.funding_outpoint != other.funding_outpoint:
            return False
        if self.expires_at != other.expires_at:
            return False
        return True

class _UniffiConverterTypeLsps1ChannelInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1ChannelInfo(
            funded_at=_UniffiConverterTypeLspsDateTime.read(buf),
            funding_outpoint=_UniffiConverterTypeOutPoint.read(buf),
            expires_at=_UniffiConverterTypeLspsDateTime.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLspsDateTime.check_lower(value.funded_at)
        _UniffiConverterTypeOutPoint.check_lower(value.funding_outpoint)
        _UniffiConverterTypeLspsDateTime.check_lower(value.expires_at)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLspsDateTime.write(value.funded_at, buf)
        _UniffiConverterTypeOutPoint.write(value.funding_outpoint, buf)
        _UniffiConverterTypeLspsDateTime.write(value.expires_at, buf)


class Lsps1OnchainPaymentInfo:
    state: "Lsps1PaymentState"
    expires_at: "LspsDateTime"
    fee_total_sat: "int"
    order_total_sat: "int"
    address: "Address"
    min_onchain_payment_confirmations: "typing.Optional[int]"
    min_fee_for_0conf: "FeeRate"
    refund_onchain_address: "typing.Optional[Address]"
    def __init__(self, *, state: "Lsps1PaymentState", expires_at: "LspsDateTime", fee_total_sat: "int", order_total_sat: "int", address: "Address", min_onchain_payment_confirmations: "typing.Optional[int]", min_fee_for_0conf: "FeeRate", refund_onchain_address: "typing.Optional[Address]"):
        self.state = state
        self.expires_at = expires_at
        self.fee_total_sat = fee_total_sat
        self.order_total_sat = order_total_sat
        self.address = address
        self.min_onchain_payment_confirmations = min_onchain_payment_confirmations
        self.min_fee_for_0conf = min_fee_for_0conf
        self.refund_onchain_address = refund_onchain_address

    def __str__(self):
        return "Lsps1OnchainPaymentInfo(state={}, expires_at={}, fee_total_sat={}, order_total_sat={}, address={}, min_onchain_payment_confirmations={}, min_fee_for_0conf={}, refund_onchain_address={})".format(self.state, self.expires_at, self.fee_total_sat, self.order_total_sat, self.address, self.min_onchain_payment_confirmations, self.min_fee_for_0conf, self.refund_onchain_address)

    def __eq__(self, other):
        if self.state != other.state:
            return False
        if self.expires_at != other.expires_at:
            return False
        if self.fee_total_sat != other.fee_total_sat:
            return False
        if self.order_total_sat != other.order_total_sat:
            return False
        if self.address != other.address:
            return False
        if self.min_onchain_payment_confirmations != other.min_onchain_payment_confirmations:
            return False
        if self.min_fee_for_0conf != other.min_fee_for_0conf:
            return False
        if self.refund_onchain_address != other.refund_onchain_address:
            return False
        return True

class _UniffiConverterTypeLsps1OnchainPaymentInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1OnchainPaymentInfo(
            state=_UniffiConverterTypeLsps1PaymentState.read(buf),
            expires_at=_UniffiConverterTypeLspsDateTime.read(buf),
            fee_total_sat=_UniffiConverterUInt64.read(buf),
            order_total_sat=_UniffiConverterUInt64.read(buf),
            address=_UniffiConverterTypeAddress.read(buf),
            min_onchain_payment_confirmations=_UniffiConverterOptionalUInt16.read(buf),
            min_fee_for_0conf=_UniffiConverterTypeFeeRate.read(buf),
            refund_onchain_address=_UniffiConverterOptionalTypeAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLsps1PaymentState.check_lower(value.state)
        _UniffiConverterTypeLspsDateTime.check_lower(value.expires_at)
        _UniffiConverterUInt64.check_lower(value.fee_total_sat)
        _UniffiConverterUInt64.check_lower(value.order_total_sat)
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterOptionalUInt16.check_lower(value.min_onchain_payment_confirmations)
        _UniffiConverterTypeFeeRate.check_lower(value.min_fee_for_0conf)
        _UniffiConverterOptionalTypeAddress.check_lower(value.refund_onchain_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLsps1PaymentState.write(value.state, buf)
        _UniffiConverterTypeLspsDateTime.write(value.expires_at, buf)
        _UniffiConverterUInt64.write(value.fee_total_sat, buf)
        _UniffiConverterUInt64.write(value.order_total_sat, buf)
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterOptionalUInt16.write(value.min_onchain_payment_confirmations, buf)
        _UniffiConverterTypeFeeRate.write(value.min_fee_for_0conf, buf)
        _UniffiConverterOptionalTypeAddress.write(value.refund_onchain_address, buf)


class Lsps1OrderParams:
    lsp_balance_sat: "int"
    client_balance_sat: "int"
    required_channel_confirmations: "int"
    funding_confirms_within_blocks: "int"
    channel_expiry_blocks: "int"
    token: "typing.Optional[str]"
    announce_channel: "bool"
    def __init__(self, *, lsp_balance_sat: "int", client_balance_sat: "int", required_channel_confirmations: "int", funding_confirms_within_blocks: "int", channel_expiry_blocks: "int", token: "typing.Optional[str]", announce_channel: "bool"):
        self.lsp_balance_sat = lsp_balance_sat
        self.client_balance_sat = client_balance_sat
        self.required_channel_confirmations = required_channel_confirmations
        self.funding_confirms_within_blocks = funding_confirms_within_blocks
        self.channel_expiry_blocks = channel_expiry_blocks
        self.token = token
        self.announce_channel = announce_channel

    def __str__(self):
        return "Lsps1OrderParams(lsp_balance_sat={}, client_balance_sat={}, required_channel_confirmations={}, funding_confirms_within_blocks={}, channel_expiry_blocks={}, token={}, announce_channel={})".format(self.lsp_balance_sat, self.client_balance_sat, self.required_channel_confirmations, self.funding_confirms_within_blocks, self.channel_expiry_blocks, self.token, self.announce_channel)

    def __eq__(self, other):
        if self.lsp_balance_sat != other.lsp_balance_sat:
            return False
        if self.client_balance_sat != other.client_balance_sat:
            return False
        if self.required_channel_confirmations != other.required_channel_confirmations:
            return False
        if self.funding_confirms_within_blocks != other.funding_confirms_within_blocks:
            return False
        if self.channel_expiry_blocks != other.channel_expiry_blocks:
            return False
        if self.token != other.token:
            return False
        if self.announce_channel != other.announce_channel:
            return False
        return True

class _UniffiConverterTypeLsps1OrderParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1OrderParams(
            lsp_balance_sat=_UniffiConverterUInt64.read(buf),
            client_balance_sat=_UniffiConverterUInt64.read(buf),
            required_channel_confirmations=_UniffiConverterUInt16.read(buf),
            funding_confirms_within_blocks=_UniffiConverterUInt16.read(buf),
            channel_expiry_blocks=_UniffiConverterUInt32.read(buf),
            token=_UniffiConverterOptionalString.read(buf),
            announce_channel=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.lsp_balance_sat)
        _UniffiConverterUInt64.check_lower(value.client_balance_sat)
        _UniffiConverterUInt16.check_lower(value.required_channel_confirmations)
        _UniffiConverterUInt16.check_lower(value.funding_confirms_within_blocks)
        _UniffiConverterUInt32.check_lower(value.channel_expiry_blocks)
        _UniffiConverterOptionalString.check_lower(value.token)
        _UniffiConverterBool.check_lower(value.announce_channel)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.lsp_balance_sat, buf)
        _UniffiConverterUInt64.write(value.client_balance_sat, buf)
        _UniffiConverterUInt16.write(value.required_channel_confirmations, buf)
        _UniffiConverterUInt16.write(value.funding_confirms_within_blocks, buf)
        _UniffiConverterUInt32.write(value.channel_expiry_blocks, buf)
        _UniffiConverterOptionalString.write(value.token, buf)
        _UniffiConverterBool.write(value.announce_channel, buf)


class Lsps1OrderStatus:
    order_id: "Lsps1OrderId"
    order_params: "Lsps1OrderParams"
    payment_options: "Lsps1PaymentInfo"
    channel_state: "typing.Optional[Lsps1ChannelInfo]"
    def __init__(self, *, order_id: "Lsps1OrderId", order_params: "Lsps1OrderParams", payment_options: "Lsps1PaymentInfo", channel_state: "typing.Optional[Lsps1ChannelInfo]"):
        self.order_id = order_id
        self.order_params = order_params
        self.payment_options = payment_options
        self.channel_state = channel_state

    def __str__(self):
        return "Lsps1OrderStatus(order_id={}, order_params={}, payment_options={}, channel_state={})".format(self.order_id, self.order_params, self.payment_options, self.channel_state)

    def __eq__(self, other):
        if self.order_id != other.order_id:
            return False
        if self.order_params != other.order_params:
            return False
        if self.payment_options != other.payment_options:
            return False
        if self.channel_state != other.channel_state:
            return False
        return True

class _UniffiConverterTypeLsps1OrderStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1OrderStatus(
            order_id=_UniffiConverterTypeLsps1OrderId.read(buf),
            order_params=_UniffiConverterTypeLsps1OrderParams.read(buf),
            payment_options=_UniffiConverterTypeLsps1PaymentInfo.read(buf),
            channel_state=_UniffiConverterOptionalTypeLsps1ChannelInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLsps1OrderId.check_lower(value.order_id)
        _UniffiConverterTypeLsps1OrderParams.check_lower(value.order_params)
        _UniffiConverterTypeLsps1PaymentInfo.check_lower(value.payment_options)
        _UniffiConverterOptionalTypeLsps1ChannelInfo.check_lower(value.channel_state)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLsps1OrderId.write(value.order_id, buf)
        _UniffiConverterTypeLsps1OrderParams.write(value.order_params, buf)
        _UniffiConverterTypeLsps1PaymentInfo.write(value.payment_options, buf)
        _UniffiConverterOptionalTypeLsps1ChannelInfo.write(value.channel_state, buf)


class Lsps1PaymentInfo:
    bolt11: "typing.Optional[Lsps1Bolt11PaymentInfo]"
    onchain: "typing.Optional[Lsps1OnchainPaymentInfo]"
    def __init__(self, *, bolt11: "typing.Optional[Lsps1Bolt11PaymentInfo]", onchain: "typing.Optional[Lsps1OnchainPaymentInfo]"):
        self.bolt11 = bolt11
        self.onchain = onchain

    def __str__(self):
        return "Lsps1PaymentInfo(bolt11={}, onchain={})".format(self.bolt11, self.onchain)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        if self.onchain != other.onchain:
            return False
        return True

class _UniffiConverterTypeLsps1PaymentInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps1PaymentInfo(
            bolt11=_UniffiConverterOptionalTypeLsps1Bolt11PaymentInfo.read(buf),
            onchain=_UniffiConverterOptionalTypeLsps1OnchainPaymentInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeLsps1Bolt11PaymentInfo.check_lower(value.bolt11)
        _UniffiConverterOptionalTypeLsps1OnchainPaymentInfo.check_lower(value.onchain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeLsps1Bolt11PaymentInfo.write(value.bolt11, buf)
        _UniffiConverterOptionalTypeLsps1OnchainPaymentInfo.write(value.onchain, buf)


class Lsps2ServiceConfig:
    require_token: "typing.Optional[str]"
    advertise_service: "bool"
    channel_opening_fee_ppm: "int"
    channel_over_provisioning_ppm: "int"
    min_channel_opening_fee_msat: "int"
    min_channel_lifetime: "int"
    max_client_to_self_delay: "int"
    min_payment_size_msat: "int"
    max_payment_size_msat: "int"
    client_trusts_lsp: "bool"
    def __init__(self, *, require_token: "typing.Optional[str]", advertise_service: "bool", channel_opening_fee_ppm: "int", channel_over_provisioning_ppm: "int", min_channel_opening_fee_msat: "int", min_channel_lifetime: "int", max_client_to_self_delay: "int", min_payment_size_msat: "int", max_payment_size_msat: "int", client_trusts_lsp: "bool"):
        self.require_token = require_token
        self.advertise_service = advertise_service
        self.channel_opening_fee_ppm = channel_opening_fee_ppm
        self.channel_over_provisioning_ppm = channel_over_provisioning_ppm
        self.min_channel_opening_fee_msat = min_channel_opening_fee_msat
        self.min_channel_lifetime = min_channel_lifetime
        self.max_client_to_self_delay = max_client_to_self_delay
        self.min_payment_size_msat = min_payment_size_msat
        self.max_payment_size_msat = max_payment_size_msat
        self.client_trusts_lsp = client_trusts_lsp

    def __str__(self):
        return "Lsps2ServiceConfig(require_token={}, advertise_service={}, channel_opening_fee_ppm={}, channel_over_provisioning_ppm={}, min_channel_opening_fee_msat={}, min_channel_lifetime={}, max_client_to_self_delay={}, min_payment_size_msat={}, max_payment_size_msat={}, client_trusts_lsp={})".format(self.require_token, self.advertise_service, self.channel_opening_fee_ppm, self.channel_over_provisioning_ppm, self.min_channel_opening_fee_msat, self.min_channel_lifetime, self.max_client_to_self_delay, self.min_payment_size_msat, self.max_payment_size_msat, self.client_trusts_lsp)

    def __eq__(self, other):
        if self.require_token != other.require_token:
            return False
        if self.advertise_service != other.advertise_service:
            return False
        if self.channel_opening_fee_ppm != other.channel_opening_fee_ppm:
            return False
        if self.channel_over_provisioning_ppm != other.channel_over_provisioning_ppm:
            return False
        if self.min_channel_opening_fee_msat != other.min_channel_opening_fee_msat:
            return False
        if self.min_channel_lifetime != other.min_channel_lifetime:
            return False
        if self.max_client_to_self_delay != other.max_client_to_self_delay:
            return False
        if self.min_payment_size_msat != other.min_payment_size_msat:
            return False
        if self.max_payment_size_msat != other.max_payment_size_msat:
            return False
        if self.client_trusts_lsp != other.client_trusts_lsp:
            return False
        return True

class _UniffiConverterTypeLsps2ServiceConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Lsps2ServiceConfig(
            require_token=_UniffiConverterOptionalString.read(buf),
            advertise_service=_UniffiConverterBool.read(buf),
            channel_opening_fee_ppm=_UniffiConverterUInt32.read(buf),
            channel_over_provisioning_ppm=_UniffiConverterUInt32.read(buf),
            min_channel_opening_fee_msat=_UniffiConverterUInt64.read(buf),
            min_channel_lifetime=_UniffiConverterUInt32.read(buf),
            max_client_to_self_delay=_UniffiConverterUInt32.read(buf),
            min_payment_size_msat=_UniffiConverterUInt64.read(buf),
            max_payment_size_msat=_UniffiConverterUInt64.read(buf),
            client_trusts_lsp=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.require_token)
        _UniffiConverterBool.check_lower(value.advertise_service)
        _UniffiConverterUInt32.check_lower(value.channel_opening_fee_ppm)
        _UniffiConverterUInt32.check_lower(value.channel_over_provisioning_ppm)
        _UniffiConverterUInt64.check_lower(value.min_channel_opening_fee_msat)
        _UniffiConverterUInt32.check_lower(value.min_channel_lifetime)
        _UniffiConverterUInt32.check_lower(value.max_client_to_self_delay)
        _UniffiConverterUInt64.check_lower(value.min_payment_size_msat)
        _UniffiConverterUInt64.check_lower(value.max_payment_size_msat)
        _UniffiConverterBool.check_lower(value.client_trusts_lsp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.require_token, buf)
        _UniffiConverterBool.write(value.advertise_service, buf)
        _UniffiConverterUInt32.write(value.channel_opening_fee_ppm, buf)
        _UniffiConverterUInt32.write(value.channel_over_provisioning_ppm, buf)
        _UniffiConverterUInt64.write(value.min_channel_opening_fee_msat, buf)
        _UniffiConverterUInt32.write(value.min_channel_lifetime, buf)
        _UniffiConverterUInt32.write(value.max_client_to_self_delay, buf)
        _UniffiConverterUInt64.write(value.min_payment_size_msat, buf)
        _UniffiConverterUInt64.write(value.max_payment_size_msat, buf)
        _UniffiConverterBool.write(value.client_trusts_lsp, buf)


class NodeAnnouncementInfo:
    last_update: "int"
    alias: "str"
    addresses: "typing.List[SocketAddress]"
    def __init__(self, *, last_update: "int", alias: "str", addresses: "typing.List[SocketAddress]"):
        self.last_update = last_update
        self.alias = alias
        self.addresses = addresses

    def __str__(self):
        return "NodeAnnouncementInfo(last_update={}, alias={}, addresses={})".format(self.last_update, self.alias, self.addresses)

    def __eq__(self, other):
        if self.last_update != other.last_update:
            return False
        if self.alias != other.alias:
            return False
        if self.addresses != other.addresses:
            return False
        return True

class _UniffiConverterTypeNodeAnnouncementInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeAnnouncementInfo(
            last_update=_UniffiConverterUInt32.read(buf),
            alias=_UniffiConverterString.read(buf),
            addresses=_UniffiConverterSequenceTypeSocketAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.last_update)
        _UniffiConverterString.check_lower(value.alias)
        _UniffiConverterSequenceTypeSocketAddress.check_lower(value.addresses)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.last_update, buf)
        _UniffiConverterString.write(value.alias, buf)
        _UniffiConverterSequenceTypeSocketAddress.write(value.addresses, buf)


class NodeInfo:
    channels: "typing.List[int]"
    announcement_info: "typing.Optional[NodeAnnouncementInfo]"
    def __init__(self, *, channels: "typing.List[int]", announcement_info: "typing.Optional[NodeAnnouncementInfo]"):
        self.channels = channels
        self.announcement_info = announcement_info

    def __str__(self):
        return "NodeInfo(channels={}, announcement_info={})".format(self.channels, self.announcement_info)

    def __eq__(self, other):
        if self.channels != other.channels:
            return False
        if self.announcement_info != other.announcement_info:
            return False
        return True

class _UniffiConverterTypeNodeInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeInfo(
            channels=_UniffiConverterSequenceUInt64.read(buf),
            announcement_info=_UniffiConverterOptionalTypeNodeAnnouncementInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceUInt64.check_lower(value.channels)
        _UniffiConverterOptionalTypeNodeAnnouncementInfo.check_lower(value.announcement_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceUInt64.write(value.channels, buf)
        _UniffiConverterOptionalTypeNodeAnnouncementInfo.write(value.announcement_info, buf)


class NodeStatus:
    is_running: "bool"
    current_best_block: "BestBlock"
    latest_lightning_wallet_sync_timestamp: "typing.Optional[int]"
    latest_onchain_wallet_sync_timestamp: "typing.Optional[int]"
    latest_fee_rate_cache_update_timestamp: "typing.Optional[int]"
    latest_rgs_snapshot_timestamp: "typing.Optional[int]"
    latest_pathfinding_scores_sync_timestamp: "typing.Optional[int]"
    latest_node_announcement_broadcast_timestamp: "typing.Optional[int]"
    latest_channel_monitor_archival_height: "typing.Optional[int]"
    def __init__(self, *, is_running: "bool", current_best_block: "BestBlock", latest_lightning_wallet_sync_timestamp: "typing.Optional[int]", latest_onchain_wallet_sync_timestamp: "typing.Optional[int]", latest_fee_rate_cache_update_timestamp: "typing.Optional[int]", latest_rgs_snapshot_timestamp: "typing.Optional[int]", latest_pathfinding_scores_sync_timestamp: "typing.Optional[int]", latest_node_announcement_broadcast_timestamp: "typing.Optional[int]", latest_channel_monitor_archival_height: "typing.Optional[int]"):
        self.is_running = is_running
        self.current_best_block = current_best_block
        self.latest_lightning_wallet_sync_timestamp = latest_lightning_wallet_sync_timestamp
        self.latest_onchain_wallet_sync_timestamp = latest_onchain_wallet_sync_timestamp
        self.latest_fee_rate_cache_update_timestamp = latest_fee_rate_cache_update_timestamp
        self.latest_rgs_snapshot_timestamp = latest_rgs_snapshot_timestamp
        self.latest_pathfinding_scores_sync_timestamp = latest_pathfinding_scores_sync_timestamp
        self.latest_node_announcement_broadcast_timestamp = latest_node_announcement_broadcast_timestamp
        self.latest_channel_monitor_archival_height = latest_channel_monitor_archival_height

    def __str__(self):
        return "NodeStatus(is_running={}, current_best_block={}, latest_lightning_wallet_sync_timestamp={}, latest_onchain_wallet_sync_timestamp={}, latest_fee_rate_cache_update_timestamp={}, latest_rgs_snapshot_timestamp={}, latest_pathfinding_scores_sync_timestamp={}, latest_node_announcement_broadcast_timestamp={}, latest_channel_monitor_archival_height={})".format(self.is_running, self.current_best_block, self.latest_lightning_wallet_sync_timestamp, self.latest_onchain_wallet_sync_timestamp, self.latest_fee_rate_cache_update_timestamp, self.latest_rgs_snapshot_timestamp, self.latest_pathfinding_scores_sync_timestamp, self.latest_node_announcement_broadcast_timestamp, self.latest_channel_monitor_archival_height)

    def __eq__(self, other):
        if self.is_running != other.is_running:
            return False
        if self.current_best_block != other.current_best_block:
            return False
        if self.latest_lightning_wallet_sync_timestamp != other.latest_lightning_wallet_sync_timestamp:
            return False
        if self.latest_onchain_wallet_sync_timestamp != other.latest_onchain_wallet_sync_timestamp:
            return False
        if self.latest_fee_rate_cache_update_timestamp != other.latest_fee_rate_cache_update_timestamp:
            return False
        if self.latest_rgs_snapshot_timestamp != other.latest_rgs_snapshot_timestamp:
            return False
        if self.latest_pathfinding_scores_sync_timestamp != other.latest_pathfinding_scores_sync_timestamp:
            return False
        if self.latest_node_announcement_broadcast_timestamp != other.latest_node_announcement_broadcast_timestamp:
            return False
        if self.latest_channel_monitor_archival_height != other.latest_channel_monitor_archival_height:
            return False
        return True

class _UniffiConverterTypeNodeStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NodeStatus(
            is_running=_UniffiConverterBool.read(buf),
            current_best_block=_UniffiConverterTypeBestBlock.read(buf),
            latest_lightning_wallet_sync_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_onchain_wallet_sync_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_fee_rate_cache_update_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_rgs_snapshot_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_pathfinding_scores_sync_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_node_announcement_broadcast_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            latest_channel_monitor_archival_height=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.is_running)
        _UniffiConverterTypeBestBlock.check_lower(value.current_best_block)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_lightning_wallet_sync_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_onchain_wallet_sync_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_fee_rate_cache_update_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_rgs_snapshot_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_pathfinding_scores_sync_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.latest_node_announcement_broadcast_timestamp)
        _UniffiConverterOptionalUInt32.check_lower(value.latest_channel_monitor_archival_height)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.is_running, buf)
        _UniffiConverterTypeBestBlock.write(value.current_best_block, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_lightning_wallet_sync_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_onchain_wallet_sync_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_fee_rate_cache_update_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_rgs_snapshot_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_pathfinding_scores_sync_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.latest_node_announcement_broadcast_timestamp, buf)
        _UniffiConverterOptionalUInt32.write(value.latest_channel_monitor_archival_height, buf)


class OutPoint:
    txid: "Txid"
    vout: "int"
    def __init__(self, *, txid: "Txid", vout: "int"):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class _UniffiConverterTypeOutPoint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=_UniffiConverterTypeTxid.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTxid.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTxid.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)


class PaymentDetails:
    id: "PaymentId"
    kind: "PaymentKind"
    amount_msat: "typing.Optional[int]"
    fee_paid_msat: "typing.Optional[int]"
    direction: "PaymentDirection"
    status: "PaymentStatus"
    latest_update_timestamp: "int"
    def __init__(self, *, id: "PaymentId", kind: "PaymentKind", amount_msat: "typing.Optional[int]", fee_paid_msat: "typing.Optional[int]", direction: "PaymentDirection", status: "PaymentStatus", latest_update_timestamp: "int"):
        self.id = id
        self.kind = kind
        self.amount_msat = amount_msat
        self.fee_paid_msat = fee_paid_msat
        self.direction = direction
        self.status = status
        self.latest_update_timestamp = latest_update_timestamp

    def __str__(self):
        return "PaymentDetails(id={}, kind={}, amount_msat={}, fee_paid_msat={}, direction={}, status={}, latest_update_timestamp={})".format(self.id, self.kind, self.amount_msat, self.fee_paid_msat, self.direction, self.status, self.latest_update_timestamp)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.kind != other.kind:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.fee_paid_msat != other.fee_paid_msat:
            return False
        if self.direction != other.direction:
            return False
        if self.status != other.status:
            return False
        if self.latest_update_timestamp != other.latest_update_timestamp:
            return False
        return True

class _UniffiConverterTypePaymentDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentDetails(
            id=_UniffiConverterTypePaymentId.read(buf),
            kind=_UniffiConverterTypePaymentKind.read(buf),
            amount_msat=_UniffiConverterOptionalUInt64.read(buf),
            fee_paid_msat=_UniffiConverterOptionalUInt64.read(buf),
            direction=_UniffiConverterTypePaymentDirection.read(buf),
            status=_UniffiConverterTypePaymentStatus.read(buf),
            latest_update_timestamp=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePaymentId.check_lower(value.id)
        _UniffiConverterTypePaymentKind.check_lower(value.kind)
        _UniffiConverterOptionalUInt64.check_lower(value.amount_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.fee_paid_msat)
        _UniffiConverterTypePaymentDirection.check_lower(value.direction)
        _UniffiConverterTypePaymentStatus.check_lower(value.status)
        _UniffiConverterUInt64.check_lower(value.latest_update_timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePaymentId.write(value.id, buf)
        _UniffiConverterTypePaymentKind.write(value.kind, buf)
        _UniffiConverterOptionalUInt64.write(value.amount_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.fee_paid_msat, buf)
        _UniffiConverterTypePaymentDirection.write(value.direction, buf)
        _UniffiConverterTypePaymentStatus.write(value.status, buf)
        _UniffiConverterUInt64.write(value.latest_update_timestamp, buf)


class PeerDetails:
    node_id: "PublicKey"
    address: "SocketAddress"
    is_persisted: "bool"
    is_connected: "bool"
    def __init__(self, *, node_id: "PublicKey", address: "SocketAddress", is_persisted: "bool", is_connected: "bool"):
        self.node_id = node_id
        self.address = address
        self.is_persisted = is_persisted
        self.is_connected = is_connected

    def __str__(self):
        return "PeerDetails(node_id={}, address={}, is_persisted={}, is_connected={})".format(self.node_id, self.address, self.is_persisted, self.is_connected)

    def __eq__(self, other):
        if self.node_id != other.node_id:
            return False
        if self.address != other.address:
            return False
        if self.is_persisted != other.is_persisted:
            return False
        if self.is_connected != other.is_connected:
            return False
        return True

class _UniffiConverterTypePeerDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PeerDetails(
            node_id=_UniffiConverterTypePublicKey.read(buf),
            address=_UniffiConverterTypeSocketAddress.read(buf),
            is_persisted=_UniffiConverterBool.read(buf),
            is_connected=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.node_id)
        _UniffiConverterTypeSocketAddress.check_lower(value.address)
        _UniffiConverterBool.check_lower(value.is_persisted)
        _UniffiConverterBool.check_lower(value.is_connected)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.node_id, buf)
        _UniffiConverterTypeSocketAddress.write(value.address, buf)
        _UniffiConverterBool.write(value.is_persisted, buf)
        _UniffiConverterBool.write(value.is_connected, buf)


class RouteHintHop:
    src_node_id: "PublicKey"
    short_channel_id: "int"
    cltv_expiry_delta: "int"
    htlc_minimum_msat: "typing.Optional[int]"
    htlc_maximum_msat: "typing.Optional[int]"
    fees: "RoutingFees"
    def __init__(self, *, src_node_id: "PublicKey", short_channel_id: "int", cltv_expiry_delta: "int", htlc_minimum_msat: "typing.Optional[int]", htlc_maximum_msat: "typing.Optional[int]", fees: "RoutingFees"):
        self.src_node_id = src_node_id
        self.short_channel_id = short_channel_id
        self.cltv_expiry_delta = cltv_expiry_delta
        self.htlc_minimum_msat = htlc_minimum_msat
        self.htlc_maximum_msat = htlc_maximum_msat
        self.fees = fees

    def __str__(self):
        return "RouteHintHop(src_node_id={}, short_channel_id={}, cltv_expiry_delta={}, htlc_minimum_msat={}, htlc_maximum_msat={}, fees={})".format(self.src_node_id, self.short_channel_id, self.cltv_expiry_delta, self.htlc_minimum_msat, self.htlc_maximum_msat, self.fees)

    def __eq__(self, other):
        if self.src_node_id != other.src_node_id:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.cltv_expiry_delta != other.cltv_expiry_delta:
            return False
        if self.htlc_minimum_msat != other.htlc_minimum_msat:
            return False
        if self.htlc_maximum_msat != other.htlc_maximum_msat:
            return False
        if self.fees != other.fees:
            return False
        return True

class _UniffiConverterTypeRouteHintHop(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteHintHop(
            src_node_id=_UniffiConverterTypePublicKey.read(buf),
            short_channel_id=_UniffiConverterUInt64.read(buf),
            cltv_expiry_delta=_UniffiConverterUInt16.read(buf),
            htlc_minimum_msat=_UniffiConverterOptionalUInt64.read(buf),
            htlc_maximum_msat=_UniffiConverterOptionalUInt64.read(buf),
            fees=_UniffiConverterTypeRoutingFees.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePublicKey.check_lower(value.src_node_id)
        _UniffiConverterUInt64.check_lower(value.short_channel_id)
        _UniffiConverterUInt16.check_lower(value.cltv_expiry_delta)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_minimum_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.htlc_maximum_msat)
        _UniffiConverterTypeRoutingFees.check_lower(value.fees)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePublicKey.write(value.src_node_id, buf)
        _UniffiConverterUInt64.write(value.short_channel_id, buf)
        _UniffiConverterUInt16.write(value.cltv_expiry_delta, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_minimum_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.htlc_maximum_msat, buf)
        _UniffiConverterTypeRoutingFees.write(value.fees, buf)


class RouteParametersConfig:
    max_total_routing_fee_msat: "typing.Optional[int]"
    max_total_cltv_expiry_delta: "int"
    max_path_count: "int"
    max_channel_saturation_power_of_half: "int"
    def __init__(self, *, max_total_routing_fee_msat: "typing.Optional[int]", max_total_cltv_expiry_delta: "int", max_path_count: "int", max_channel_saturation_power_of_half: "int"):
        self.max_total_routing_fee_msat = max_total_routing_fee_msat
        self.max_total_cltv_expiry_delta = max_total_cltv_expiry_delta
        self.max_path_count = max_path_count
        self.max_channel_saturation_power_of_half = max_channel_saturation_power_of_half

    def __str__(self):
        return "RouteParametersConfig(max_total_routing_fee_msat={}, max_total_cltv_expiry_delta={}, max_path_count={}, max_channel_saturation_power_of_half={})".format(self.max_total_routing_fee_msat, self.max_total_cltv_expiry_delta, self.max_path_count, self.max_channel_saturation_power_of_half)

    def __eq__(self, other):
        if self.max_total_routing_fee_msat != other.max_total_routing_fee_msat:
            return False
        if self.max_total_cltv_expiry_delta != other.max_total_cltv_expiry_delta:
            return False
        if self.max_path_count != other.max_path_count:
            return False
        if self.max_channel_saturation_power_of_half != other.max_channel_saturation_power_of_half:
            return False
        return True

class _UniffiConverterTypeRouteParametersConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RouteParametersConfig(
            max_total_routing_fee_msat=_UniffiConverterOptionalUInt64.read(buf),
            max_total_cltv_expiry_delta=_UniffiConverterUInt32.read(buf),
            max_path_count=_UniffiConverterUInt8.read(buf),
            max_channel_saturation_power_of_half=_UniffiConverterUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.max_total_routing_fee_msat)
        _UniffiConverterUInt32.check_lower(value.max_total_cltv_expiry_delta)
        _UniffiConverterUInt8.check_lower(value.max_path_count)
        _UniffiConverterUInt8.check_lower(value.max_channel_saturation_power_of_half)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.max_total_routing_fee_msat, buf)
        _UniffiConverterUInt32.write(value.max_total_cltv_expiry_delta, buf)
        _UniffiConverterUInt8.write(value.max_path_count, buf)
        _UniffiConverterUInt8.write(value.max_channel_saturation_power_of_half, buf)


class RoutingFees:
    base_msat: "int"
    proportional_millionths: "int"
    def __init__(self, *, base_msat: "int", proportional_millionths: "int"):
        self.base_msat = base_msat
        self.proportional_millionths = proportional_millionths

    def __str__(self):
        return "RoutingFees(base_msat={}, proportional_millionths={})".format(self.base_msat, self.proportional_millionths)

    def __eq__(self, other):
        if self.base_msat != other.base_msat:
            return False
        if self.proportional_millionths != other.proportional_millionths:
            return False
        return True

class _UniffiConverterTypeRoutingFees(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RoutingFees(
            base_msat=_UniffiConverterUInt32.read(buf),
            proportional_millionths=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.base_msat)
        _UniffiConverterUInt32.check_lower(value.proportional_millionths)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.base_msat, buf)
        _UniffiConverterUInt32.write(value.proportional_millionths, buf)


class RuntimeSyncIntervals:
    onchain_wallet_sync_interval_secs: "int"
    lightning_wallet_sync_interval_secs: "int"
    fee_rate_cache_update_interval_secs: "int"
    def __init__(self, *, onchain_wallet_sync_interval_secs: "int", lightning_wallet_sync_interval_secs: "int", fee_rate_cache_update_interval_secs: "int"):
        self.onchain_wallet_sync_interval_secs = onchain_wallet_sync_interval_secs
        self.lightning_wallet_sync_interval_secs = lightning_wallet_sync_interval_secs
        self.fee_rate_cache_update_interval_secs = fee_rate_cache_update_interval_secs

    def __str__(self):
        return "RuntimeSyncIntervals(onchain_wallet_sync_interval_secs={}, lightning_wallet_sync_interval_secs={}, fee_rate_cache_update_interval_secs={})".format(self.onchain_wallet_sync_interval_secs, self.lightning_wallet_sync_interval_secs, self.fee_rate_cache_update_interval_secs)

    def __eq__(self, other):
        if self.onchain_wallet_sync_interval_secs != other.onchain_wallet_sync_interval_secs:
            return False
        if self.lightning_wallet_sync_interval_secs != other.lightning_wallet_sync_interval_secs:
            return False
        if self.fee_rate_cache_update_interval_secs != other.fee_rate_cache_update_interval_secs:
            return False
        return True

class _UniffiConverterTypeRuntimeSyncIntervals(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RuntimeSyncIntervals(
            onchain_wallet_sync_interval_secs=_UniffiConverterUInt64.read(buf),
            lightning_wallet_sync_interval_secs=_UniffiConverterUInt64.read(buf),
            fee_rate_cache_update_interval_secs=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.onchain_wallet_sync_interval_secs)
        _UniffiConverterUInt64.check_lower(value.lightning_wallet_sync_interval_secs)
        _UniffiConverterUInt64.check_lower(value.fee_rate_cache_update_interval_secs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.onchain_wallet_sync_interval_secs, buf)
        _UniffiConverterUInt64.write(value.lightning_wallet_sync_interval_secs, buf)
        _UniffiConverterUInt64.write(value.fee_rate_cache_update_interval_secs, buf)


class SpendableUtxo:
    outpoint: "OutPoint"
    value_sats: "int"
    def __init__(self, *, outpoint: "OutPoint", value_sats: "int"):
        self.outpoint = outpoint
        self.value_sats = value_sats

    def __str__(self):
        return "SpendableUtxo(outpoint={}, value_sats={})".format(self.outpoint, self.value_sats)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.value_sats != other.value_sats:
            return False
        return True

class _UniffiConverterTypeSpendableUtxo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SpendableUtxo(
            outpoint=_UniffiConverterTypeOutPoint.read(buf),
            value_sats=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.outpoint)
        _UniffiConverterUInt64.check_lower(value.value_sats)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.outpoint, buf)
        _UniffiConverterUInt64.write(value.value_sats, buf)


class TransactionDetails:
    amount_sats: "int"
    inputs: "typing.List[TxInput]"
    outputs: "typing.List[TxOutput]"
    def __init__(self, *, amount_sats: "int", inputs: "typing.List[TxInput]", outputs: "typing.List[TxOutput]"):
        self.amount_sats = amount_sats
        self.inputs = inputs
        self.outputs = outputs

    def __str__(self):
        return "TransactionDetails(amount_sats={}, inputs={}, outputs={})".format(self.amount_sats, self.inputs, self.outputs)

    def __eq__(self, other):
        if self.amount_sats != other.amount_sats:
            return False
        if self.inputs != other.inputs:
            return False
        if self.outputs != other.outputs:
            return False
        return True

class _UniffiConverterTypeTransactionDetails(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionDetails(
            amount_sats=_UniffiConverterInt64.read(buf),
            inputs=_UniffiConverterSequenceTypeTxInput.read(buf),
            outputs=_UniffiConverterSequenceTypeTxOutput.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt64.check_lower(value.amount_sats)
        _UniffiConverterSequenceTypeTxInput.check_lower(value.inputs)
        _UniffiConverterSequenceTypeTxOutput.check_lower(value.outputs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt64.write(value.amount_sats, buf)
        _UniffiConverterSequenceTypeTxInput.write(value.inputs, buf)
        _UniffiConverterSequenceTypeTxOutput.write(value.outputs, buf)


class TxInput:
    txid: "Txid"
    vout: "int"
    scriptsig: "str"
    witness: "typing.List[str]"
    sequence: "int"
    def __init__(self, *, txid: "Txid", vout: "int", scriptsig: "str", witness: "typing.List[str]", sequence: "int"):
        self.txid = txid
        self.vout = vout
        self.scriptsig = scriptsig
        self.witness = witness
        self.sequence = sequence

    def __str__(self):
        return "TxInput(txid={}, vout={}, scriptsig={}, witness={}, sequence={})".format(self.txid, self.vout, self.scriptsig, self.witness, self.sequence)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        if self.scriptsig != other.scriptsig:
            return False
        if self.witness != other.witness:
            return False
        if self.sequence != other.sequence:
            return False
        return True

class _UniffiConverterTypeTxInput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxInput(
            txid=_UniffiConverterTypeTxid.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
            scriptsig=_UniffiConverterString.read(buf),
            witness=_UniffiConverterSequenceString.read(buf),
            sequence=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTxid.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)
        _UniffiConverterString.check_lower(value.scriptsig)
        _UniffiConverterSequenceString.check_lower(value.witness)
        _UniffiConverterUInt32.check_lower(value.sequence)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTxid.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)
        _UniffiConverterString.write(value.scriptsig, buf)
        _UniffiConverterSequenceString.write(value.witness, buf)
        _UniffiConverterUInt32.write(value.sequence, buf)


class TxOutput:
    scriptpubkey: "str"
    scriptpubkey_type: "typing.Optional[str]"
    scriptpubkey_address: "typing.Optional[str]"
    value: "int"
    n: "int"
    def __init__(self, *, scriptpubkey: "str", scriptpubkey_type: "typing.Optional[str]", scriptpubkey_address: "typing.Optional[str]", value: "int", n: "int"):
        self.scriptpubkey = scriptpubkey
        self.scriptpubkey_type = scriptpubkey_type
        self.scriptpubkey_address = scriptpubkey_address
        self.value = value
        self.n = n

    def __str__(self):
        return "TxOutput(scriptpubkey={}, scriptpubkey_type={}, scriptpubkey_address={}, value={}, n={})".format(self.scriptpubkey, self.scriptpubkey_type, self.scriptpubkey_address, self.value, self.n)

    def __eq__(self, other):
        if self.scriptpubkey != other.scriptpubkey:
            return False
        if self.scriptpubkey_type != other.scriptpubkey_type:
            return False
        if self.scriptpubkey_address != other.scriptpubkey_address:
            return False
        if self.value != other.value:
            return False
        if self.n != other.n:
            return False
        return True

class _UniffiConverterTypeTxOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxOutput(
            scriptpubkey=_UniffiConverterString.read(buf),
            scriptpubkey_type=_UniffiConverterOptionalString.read(buf),
            scriptpubkey_address=_UniffiConverterOptionalString.read(buf),
            value=_UniffiConverterInt64.read(buf),
            n=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.scriptpubkey)
        _UniffiConverterOptionalString.check_lower(value.scriptpubkey_type)
        _UniffiConverterOptionalString.check_lower(value.scriptpubkey_address)
        _UniffiConverterInt64.check_lower(value.value)
        _UniffiConverterUInt32.check_lower(value.n)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.scriptpubkey, buf)
        _UniffiConverterOptionalString.write(value.scriptpubkey_type, buf)
        _UniffiConverterOptionalString.write(value.scriptpubkey_address, buf)
        _UniffiConverterInt64.write(value.value, buf)
        _UniffiConverterUInt32.write(value.n, buf)





class AsyncPaymentsRole(enum.Enum):
    CLIENT = 0
    
    SERVER = 1
    


class _UniffiConverterTypeAsyncPaymentsRole(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AsyncPaymentsRole.CLIENT
        if variant == 2:
            return AsyncPaymentsRole.SERVER
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AsyncPaymentsRole.CLIENT:
            return
        if value == AsyncPaymentsRole.SERVER:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AsyncPaymentsRole.CLIENT:
            buf.write_i32(1)
        if value == AsyncPaymentsRole.SERVER:
            buf.write_i32(2)







class BalanceSource(enum.Enum):
    HOLDER_FORCE_CLOSED = 0
    
    COUNTERPARTY_FORCE_CLOSED = 1
    
    COOP_CLOSE = 2
    
    HTLC = 3
    


class _UniffiConverterTypeBalanceSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BalanceSource.HOLDER_FORCE_CLOSED
        if variant == 2:
            return BalanceSource.COUNTERPARTY_FORCE_CLOSED
        if variant == 3:
            return BalanceSource.COOP_CLOSE
        if variant == 4:
            return BalanceSource.HTLC
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BalanceSource.HOLDER_FORCE_CLOSED:
            return
        if value == BalanceSource.COUNTERPARTY_FORCE_CLOSED:
            return
        if value == BalanceSource.COOP_CLOSE:
            return
        if value == BalanceSource.HTLC:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BalanceSource.HOLDER_FORCE_CLOSED:
            buf.write_i32(1)
        if value == BalanceSource.COUNTERPARTY_FORCE_CLOSED:
            buf.write_i32(2)
        if value == BalanceSource.COOP_CLOSE:
            buf.write_i32(3)
        if value == BalanceSource.HTLC:
            buf.write_i32(4)







class Bolt11InvoiceDescription:
    def __init__(self):
        raise RuntimeError("Bolt11InvoiceDescription cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class HASH:
        hash: "str"

        def __init__(self,hash: "str"):
            self.hash = hash

        def __str__(self):
            return "Bolt11InvoiceDescription.HASH(hash={})".format(self.hash)

        def __eq__(self, other):
            if not other.is_hash():
                return False
            if self.hash != other.hash:
                return False
            return True
    
    class DIRECT:
        description: "str"

        def __init__(self,description: "str"):
            self.description = description

        def __str__(self):
            return "Bolt11InvoiceDescription.DIRECT(description={})".format(self.description)

        def __eq__(self, other):
            if not other.is_direct():
                return False
            if self.description != other.description:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_hash(self) -> bool:
        return isinstance(self, Bolt11InvoiceDescription.HASH)
    def is_direct(self) -> bool:
        return isinstance(self, Bolt11InvoiceDescription.DIRECT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Bolt11InvoiceDescription.HASH = type("Bolt11InvoiceDescription.HASH", (Bolt11InvoiceDescription.HASH, Bolt11InvoiceDescription,), {})  # type: ignore
Bolt11InvoiceDescription.DIRECT = type("Bolt11InvoiceDescription.DIRECT", (Bolt11InvoiceDescription.DIRECT, Bolt11InvoiceDescription,), {})  # type: ignore




class _UniffiConverterTypeBolt11InvoiceDescription(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Bolt11InvoiceDescription.HASH(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Bolt11InvoiceDescription.DIRECT(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_hash():
            _UniffiConverterString.check_lower(value.hash)
            return
        if value.is_direct():
            _UniffiConverterString.check_lower(value.description)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_hash():
            buf.write_i32(1)
            _UniffiConverterString.write(value.hash, buf)
        if value.is_direct():
            buf.write_i32(2)
            _UniffiConverterString.write(value.description, buf)




# BuildError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class BuildError(Exception):
    pass

_UniffiTempBuildError = BuildError

class BuildError:  # type: ignore
    class InvalidSeedBytes(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidSeedBytes({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidSeedBytes = InvalidSeedBytes # type: ignore
    class InvalidSeedFile(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidSeedFile({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidSeedFile = InvalidSeedFile # type: ignore
    class InvalidSystemTime(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidSystemTime({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidSystemTime = InvalidSystemTime # type: ignore
    class InvalidChannelMonitor(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidChannelMonitor({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidChannelMonitor = InvalidChannelMonitor # type: ignore
    class InvalidListeningAddresses(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidListeningAddresses({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidListeningAddresses = InvalidListeningAddresses # type: ignore
    class InvalidAnnouncementAddresses(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidAnnouncementAddresses({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidAnnouncementAddresses = InvalidAnnouncementAddresses # type: ignore
    class InvalidNodeAlias(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.InvalidNodeAlias({})".format(repr(str(self)))
    _UniffiTempBuildError.InvalidNodeAlias = InvalidNodeAlias # type: ignore
    class RuntimeSetupFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.RuntimeSetupFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.RuntimeSetupFailed = RuntimeSetupFailed # type: ignore
    class ReadFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.ReadFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.ReadFailed = ReadFailed # type: ignore
    class WriteFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.WriteFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.WriteFailed = WriteFailed # type: ignore
    class StoragePathAccessFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.StoragePathAccessFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.StoragePathAccessFailed = StoragePathAccessFailed # type: ignore
    class KvStoreSetupFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.KvStoreSetupFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.KvStoreSetupFailed = KvStoreSetupFailed # type: ignore
    class WalletSetupFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.WalletSetupFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.WalletSetupFailed = WalletSetupFailed # type: ignore
    class LoggerSetupFailed(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.LoggerSetupFailed({})".format(repr(str(self)))
    _UniffiTempBuildError.LoggerSetupFailed = LoggerSetupFailed # type: ignore
    class NetworkMismatch(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.NetworkMismatch({})".format(repr(str(self)))
    _UniffiTempBuildError.NetworkMismatch = NetworkMismatch # type: ignore
    class AsyncPaymentsConfigMismatch(_UniffiTempBuildError):

        def __repr__(self):
            return "BuildError.AsyncPaymentsConfigMismatch({})".format(repr(str(self)))
    _UniffiTempBuildError.AsyncPaymentsConfigMismatch = AsyncPaymentsConfigMismatch # type: ignore

BuildError = _UniffiTempBuildError # type: ignore
del _UniffiTempBuildError


class _UniffiConverterTypeBuildError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BuildError.InvalidSeedBytes(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return BuildError.InvalidSeedFile(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return BuildError.InvalidSystemTime(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return BuildError.InvalidChannelMonitor(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return BuildError.InvalidListeningAddresses(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return BuildError.InvalidAnnouncementAddresses(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return BuildError.InvalidNodeAlias(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return BuildError.RuntimeSetupFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return BuildError.ReadFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return BuildError.WriteFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return BuildError.StoragePathAccessFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return BuildError.KvStoreSetupFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return BuildError.WalletSetupFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return BuildError.LoggerSetupFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return BuildError.NetworkMismatch(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return BuildError.AsyncPaymentsConfigMismatch(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, BuildError.InvalidSeedBytes):
            return
        if isinstance(value, BuildError.InvalidSeedFile):
            return
        if isinstance(value, BuildError.InvalidSystemTime):
            return
        if isinstance(value, BuildError.InvalidChannelMonitor):
            return
        if isinstance(value, BuildError.InvalidListeningAddresses):
            return
        if isinstance(value, BuildError.InvalidAnnouncementAddresses):
            return
        if isinstance(value, BuildError.InvalidNodeAlias):
            return
        if isinstance(value, BuildError.RuntimeSetupFailed):
            return
        if isinstance(value, BuildError.ReadFailed):
            return
        if isinstance(value, BuildError.WriteFailed):
            return
        if isinstance(value, BuildError.StoragePathAccessFailed):
            return
        if isinstance(value, BuildError.KvStoreSetupFailed):
            return
        if isinstance(value, BuildError.WalletSetupFailed):
            return
        if isinstance(value, BuildError.LoggerSetupFailed):
            return
        if isinstance(value, BuildError.NetworkMismatch):
            return
        if isinstance(value, BuildError.AsyncPaymentsConfigMismatch):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, BuildError.InvalidSeedBytes):
            buf.write_i32(1)
        if isinstance(value, BuildError.InvalidSeedFile):
            buf.write_i32(2)
        if isinstance(value, BuildError.InvalidSystemTime):
            buf.write_i32(3)
        if isinstance(value, BuildError.InvalidChannelMonitor):
            buf.write_i32(4)
        if isinstance(value, BuildError.InvalidListeningAddresses):
            buf.write_i32(5)
        if isinstance(value, BuildError.InvalidAnnouncementAddresses):
            buf.write_i32(6)
        if isinstance(value, BuildError.InvalidNodeAlias):
            buf.write_i32(7)
        if isinstance(value, BuildError.RuntimeSetupFailed):
            buf.write_i32(8)
        if isinstance(value, BuildError.ReadFailed):
            buf.write_i32(9)
        if isinstance(value, BuildError.WriteFailed):
            buf.write_i32(10)
        if isinstance(value, BuildError.StoragePathAccessFailed):
            buf.write_i32(11)
        if isinstance(value, BuildError.KvStoreSetupFailed):
            buf.write_i32(12)
        if isinstance(value, BuildError.WalletSetupFailed):
            buf.write_i32(13)
        if isinstance(value, BuildError.LoggerSetupFailed):
            buf.write_i32(14)
        if isinstance(value, BuildError.NetworkMismatch):
            buf.write_i32(15)
        if isinstance(value, BuildError.AsyncPaymentsConfigMismatch):
            buf.write_i32(16)





class ClosureReason:
    def __init__(self):
        raise RuntimeError("ClosureReason cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COUNTERPARTY_FORCE_CLOSED:
        peer_msg: "UntrustedString"

        def __init__(self,peer_msg: "UntrustedString"):
            self.peer_msg = peer_msg

        def __str__(self):
            return "ClosureReason.COUNTERPARTY_FORCE_CLOSED(peer_msg={})".format(self.peer_msg)

        def __eq__(self, other):
            if not other.is_counterparty_force_closed():
                return False
            if self.peer_msg != other.peer_msg:
                return False
            return True
    
    class HOLDER_FORCE_CLOSED:
        broadcasted_latest_txn: "typing.Optional[bool]"
        message: "str"

        def __init__(self,broadcasted_latest_txn: "typing.Optional[bool]", message: "str"):
            self.broadcasted_latest_txn = broadcasted_latest_txn
            self.message = message

        def __str__(self):
            return "ClosureReason.HOLDER_FORCE_CLOSED(broadcasted_latest_txn={}, message={})".format(self.broadcasted_latest_txn, self.message)

        def __eq__(self, other):
            if not other.is_holder_force_closed():
                return False
            if self.broadcasted_latest_txn != other.broadcasted_latest_txn:
                return False
            if self.message != other.message:
                return False
            return True
    
    class LEGACY_COOPERATIVE_CLOSURE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.LEGACY_COOPERATIVE_CLOSURE()".format()

        def __eq__(self, other):
            if not other.is_legacy_cooperative_closure():
                return False
            return True
    
    class COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE()".format()

        def __eq__(self, other):
            if not other.is_counterparty_initiated_cooperative_closure():
                return False
            return True
    
    class LOCALLY_INITIATED_COOPERATIVE_CLOSURE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE()".format()

        def __eq__(self, other):
            if not other.is_locally_initiated_cooperative_closure():
                return False
            return True
    
    class COMMITMENT_TX_CONFIRMED:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.COMMITMENT_TX_CONFIRMED()".format()

        def __eq__(self, other):
            if not other.is_commitment_tx_confirmed():
                return False
            return True
    
    class FUNDING_TIMED_OUT:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.FUNDING_TIMED_OUT()".format()

        def __eq__(self, other):
            if not other.is_funding_timed_out():
                return False
            return True
    
    class PROCESSING_ERROR:
        err: "str"

        def __init__(self,err: "str"):
            self.err = err

        def __str__(self):
            return "ClosureReason.PROCESSING_ERROR(err={})".format(self.err)

        def __eq__(self, other):
            if not other.is_processing_error():
                return False
            if self.err != other.err:
                return False
            return True
    
    class DISCONNECTED_PEER:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.DISCONNECTED_PEER()".format()

        def __eq__(self, other):
            if not other.is_disconnected_peer():
                return False
            return True
    
    class OUTDATED_CHANNEL_MANAGER:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.OUTDATED_CHANNEL_MANAGER()".format()

        def __eq__(self, other):
            if not other.is_outdated_channel_manager():
                return False
            return True
    
    class COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL()".format()

        def __eq__(self, other):
            if not other.is_counterparty_coop_closed_unfunded_channel():
                return False
            return True
    
    class LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL()".format()

        def __eq__(self, other):
            if not other.is_locally_coop_closed_unfunded_channel():
                return False
            return True
    
    class FUNDING_BATCH_CLOSURE:

        def __init__(self,):
            pass

        def __str__(self):
            return "ClosureReason.FUNDING_BATCH_CLOSURE()".format()

        def __eq__(self, other):
            if not other.is_funding_batch_closure():
                return False
            return True
    
    class HTL_CS_TIMED_OUT:
        payment_hash: "typing.Optional[PaymentHash]"

        def __init__(self,payment_hash: "typing.Optional[PaymentHash]"):
            self.payment_hash = payment_hash

        def __str__(self):
            return "ClosureReason.HTL_CS_TIMED_OUT(payment_hash={})".format(self.payment_hash)

        def __eq__(self, other):
            if not other.is_htl_cs_timed_out():
                return False
            if self.payment_hash != other.payment_hash:
                return False
            return True
    
    class PEER_FEERATE_TOO_LOW:
        peer_feerate_sat_per_kw: "int"
        required_feerate_sat_per_kw: "int"

        def __init__(self,peer_feerate_sat_per_kw: "int", required_feerate_sat_per_kw: "int"):
            self.peer_feerate_sat_per_kw = peer_feerate_sat_per_kw
            self.required_feerate_sat_per_kw = required_feerate_sat_per_kw

        def __str__(self):
            return "ClosureReason.PEER_FEERATE_TOO_LOW(peer_feerate_sat_per_kw={}, required_feerate_sat_per_kw={})".format(self.peer_feerate_sat_per_kw, self.required_feerate_sat_per_kw)

        def __eq__(self, other):
            if not other.is_peer_feerate_too_low():
                return False
            if self.peer_feerate_sat_per_kw != other.peer_feerate_sat_per_kw:
                return False
            if self.required_feerate_sat_per_kw != other.required_feerate_sat_per_kw:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_counterparty_force_closed(self) -> bool:
        return isinstance(self, ClosureReason.COUNTERPARTY_FORCE_CLOSED)
    def is_holder_force_closed(self) -> bool:
        return isinstance(self, ClosureReason.HOLDER_FORCE_CLOSED)
    def is_legacy_cooperative_closure(self) -> bool:
        return isinstance(self, ClosureReason.LEGACY_COOPERATIVE_CLOSURE)
    def is_counterparty_initiated_cooperative_closure(self) -> bool:
        return isinstance(self, ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE)
    def is_locally_initiated_cooperative_closure(self) -> bool:
        return isinstance(self, ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE)
    def is_commitment_tx_confirmed(self) -> bool:
        return isinstance(self, ClosureReason.COMMITMENT_TX_CONFIRMED)
    def is_funding_timed_out(self) -> bool:
        return isinstance(self, ClosureReason.FUNDING_TIMED_OUT)
    def is_processing_error(self) -> bool:
        return isinstance(self, ClosureReason.PROCESSING_ERROR)
    def is_disconnected_peer(self) -> bool:
        return isinstance(self, ClosureReason.DISCONNECTED_PEER)
    def is_outdated_channel_manager(self) -> bool:
        return isinstance(self, ClosureReason.OUTDATED_CHANNEL_MANAGER)
    def is_counterparty_coop_closed_unfunded_channel(self) -> bool:
        return isinstance(self, ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL)
    def is_locally_coop_closed_unfunded_channel(self) -> bool:
        return isinstance(self, ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL)
    def is_funding_batch_closure(self) -> bool:
        return isinstance(self, ClosureReason.FUNDING_BATCH_CLOSURE)
    def is_htl_cs_timed_out(self) -> bool:
        return isinstance(self, ClosureReason.HTL_CS_TIMED_OUT)
    def is_peer_feerate_too_low(self) -> bool:
        return isinstance(self, ClosureReason.PEER_FEERATE_TOO_LOW)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ClosureReason.COUNTERPARTY_FORCE_CLOSED = type("ClosureReason.COUNTERPARTY_FORCE_CLOSED", (ClosureReason.COUNTERPARTY_FORCE_CLOSED, ClosureReason,), {})  # type: ignore
ClosureReason.HOLDER_FORCE_CLOSED = type("ClosureReason.HOLDER_FORCE_CLOSED", (ClosureReason.HOLDER_FORCE_CLOSED, ClosureReason,), {})  # type: ignore
ClosureReason.LEGACY_COOPERATIVE_CLOSURE = type("ClosureReason.LEGACY_COOPERATIVE_CLOSURE", (ClosureReason.LEGACY_COOPERATIVE_CLOSURE, ClosureReason,), {})  # type: ignore
ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE = type("ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE", (ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE, ClosureReason,), {})  # type: ignore
ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE = type("ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE", (ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE, ClosureReason,), {})  # type: ignore
ClosureReason.COMMITMENT_TX_CONFIRMED = type("ClosureReason.COMMITMENT_TX_CONFIRMED", (ClosureReason.COMMITMENT_TX_CONFIRMED, ClosureReason,), {})  # type: ignore
ClosureReason.FUNDING_TIMED_OUT = type("ClosureReason.FUNDING_TIMED_OUT", (ClosureReason.FUNDING_TIMED_OUT, ClosureReason,), {})  # type: ignore
ClosureReason.PROCESSING_ERROR = type("ClosureReason.PROCESSING_ERROR", (ClosureReason.PROCESSING_ERROR, ClosureReason,), {})  # type: ignore
ClosureReason.DISCONNECTED_PEER = type("ClosureReason.DISCONNECTED_PEER", (ClosureReason.DISCONNECTED_PEER, ClosureReason,), {})  # type: ignore
ClosureReason.OUTDATED_CHANNEL_MANAGER = type("ClosureReason.OUTDATED_CHANNEL_MANAGER", (ClosureReason.OUTDATED_CHANNEL_MANAGER, ClosureReason,), {})  # type: ignore
ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL = type("ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL", (ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL, ClosureReason,), {})  # type: ignore
ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL = type("ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL", (ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL, ClosureReason,), {})  # type: ignore
ClosureReason.FUNDING_BATCH_CLOSURE = type("ClosureReason.FUNDING_BATCH_CLOSURE", (ClosureReason.FUNDING_BATCH_CLOSURE, ClosureReason,), {})  # type: ignore
ClosureReason.HTL_CS_TIMED_OUT = type("ClosureReason.HTL_CS_TIMED_OUT", (ClosureReason.HTL_CS_TIMED_OUT, ClosureReason,), {})  # type: ignore
ClosureReason.PEER_FEERATE_TOO_LOW = type("ClosureReason.PEER_FEERATE_TOO_LOW", (ClosureReason.PEER_FEERATE_TOO_LOW, ClosureReason,), {})  # type: ignore




class _UniffiConverterTypeClosureReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClosureReason.COUNTERPARTY_FORCE_CLOSED(
                _UniffiConverterTypeUntrustedString.read(buf),
            )
        if variant == 2:
            return ClosureReason.HOLDER_FORCE_CLOSED(
                _UniffiConverterOptionalBool.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ClosureReason.LEGACY_COOPERATIVE_CLOSURE(
            )
        if variant == 4:
            return ClosureReason.COUNTERPARTY_INITIATED_COOPERATIVE_CLOSURE(
            )
        if variant == 5:
            return ClosureReason.LOCALLY_INITIATED_COOPERATIVE_CLOSURE(
            )
        if variant == 6:
            return ClosureReason.COMMITMENT_TX_CONFIRMED(
            )
        if variant == 7:
            return ClosureReason.FUNDING_TIMED_OUT(
            )
        if variant == 8:
            return ClosureReason.PROCESSING_ERROR(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ClosureReason.DISCONNECTED_PEER(
            )
        if variant == 10:
            return ClosureReason.OUTDATED_CHANNEL_MANAGER(
            )
        if variant == 11:
            return ClosureReason.COUNTERPARTY_COOP_CLOSED_UNFUNDED_CHANNEL(
            )
        if variant == 12:
            return ClosureReason.LOCALLY_COOP_CLOSED_UNFUNDED_CHANNEL(
            )
        if variant == 13:
            return ClosureReason.FUNDING_BATCH_CLOSURE(
            )
        if variant == 14:
            return ClosureReason.HTL_CS_TIMED_OUT(
                _UniffiConverterOptionalTypePaymentHash.read(buf),
            )
        if variant == 15:
            return ClosureReason.PEER_FEERATE_TOO_LOW(
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_counterparty_force_closed():
            _UniffiConverterTypeUntrustedString.check_lower(value.peer_msg)
            return
        if value.is_holder_force_closed():
            _UniffiConverterOptionalBool.check_lower(value.broadcasted_latest_txn)
            _UniffiConverterString.check_lower(value.message)
            return
        if value.is_legacy_cooperative_closure():
            return
        if value.is_counterparty_initiated_cooperative_closure():
            return
        if value.is_locally_initiated_cooperative_closure():
            return
        if value.is_commitment_tx_confirmed():
            return
        if value.is_funding_timed_out():
            return
        if value.is_processing_error():
            _UniffiConverterString.check_lower(value.err)
            return
        if value.is_disconnected_peer():
            return
        if value.is_outdated_channel_manager():
            return
        if value.is_counterparty_coop_closed_unfunded_channel():
            return
        if value.is_locally_coop_closed_unfunded_channel():
            return
        if value.is_funding_batch_closure():
            return
        if value.is_htl_cs_timed_out():
            _UniffiConverterOptionalTypePaymentHash.check_lower(value.payment_hash)
            return
        if value.is_peer_feerate_too_low():
            _UniffiConverterUInt32.check_lower(value.peer_feerate_sat_per_kw)
            _UniffiConverterUInt32.check_lower(value.required_feerate_sat_per_kw)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_counterparty_force_closed():
            buf.write_i32(1)
            _UniffiConverterTypeUntrustedString.write(value.peer_msg, buf)
        if value.is_holder_force_closed():
            buf.write_i32(2)
            _UniffiConverterOptionalBool.write(value.broadcasted_latest_txn, buf)
            _UniffiConverterString.write(value.message, buf)
        if value.is_legacy_cooperative_closure():
            buf.write_i32(3)
        if value.is_counterparty_initiated_cooperative_closure():
            buf.write_i32(4)
        if value.is_locally_initiated_cooperative_closure():
            buf.write_i32(5)
        if value.is_commitment_tx_confirmed():
            buf.write_i32(6)
        if value.is_funding_timed_out():
            buf.write_i32(7)
        if value.is_processing_error():
            buf.write_i32(8)
            _UniffiConverterString.write(value.err, buf)
        if value.is_disconnected_peer():
            buf.write_i32(9)
        if value.is_outdated_channel_manager():
            buf.write_i32(10)
        if value.is_counterparty_coop_closed_unfunded_channel():
            buf.write_i32(11)
        if value.is_locally_coop_closed_unfunded_channel():
            buf.write_i32(12)
        if value.is_funding_batch_closure():
            buf.write_i32(13)
        if value.is_htl_cs_timed_out():
            buf.write_i32(14)
            _UniffiConverterOptionalTypePaymentHash.write(value.payment_hash, buf)
        if value.is_peer_feerate_too_low():
            buf.write_i32(15)
            _UniffiConverterUInt32.write(value.peer_feerate_sat_per_kw, buf)
            _UniffiConverterUInt32.write(value.required_feerate_sat_per_kw, buf)







class CoinSelectionAlgorithm(enum.Enum):
    BRANCH_AND_BOUND = 0
    
    LARGEST_FIRST = 1
    
    OLDEST_FIRST = 2
    
    SINGLE_RANDOM_DRAW = 3
    


class _UniffiConverterTypeCoinSelectionAlgorithm(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CoinSelectionAlgorithm.BRANCH_AND_BOUND
        if variant == 2:
            return CoinSelectionAlgorithm.LARGEST_FIRST
        if variant == 3:
            return CoinSelectionAlgorithm.OLDEST_FIRST
        if variant == 4:
            return CoinSelectionAlgorithm.SINGLE_RANDOM_DRAW
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == CoinSelectionAlgorithm.BRANCH_AND_BOUND:
            return
        if value == CoinSelectionAlgorithm.LARGEST_FIRST:
            return
        if value == CoinSelectionAlgorithm.OLDEST_FIRST:
            return
        if value == CoinSelectionAlgorithm.SINGLE_RANDOM_DRAW:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == CoinSelectionAlgorithm.BRANCH_AND_BOUND:
            buf.write_i32(1)
        if value == CoinSelectionAlgorithm.LARGEST_FIRST:
            buf.write_i32(2)
        if value == CoinSelectionAlgorithm.OLDEST_FIRST:
            buf.write_i32(3)
        if value == CoinSelectionAlgorithm.SINGLE_RANDOM_DRAW:
            buf.write_i32(4)







class ConfirmationStatus:
    def __init__(self):
        raise RuntimeError("ConfirmationStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONFIRMED:
        block_hash: "BlockHash"
        height: "int"
        timestamp: "int"

        def __init__(self,block_hash: "BlockHash", height: "int", timestamp: "int"):
            self.block_hash = block_hash
            self.height = height
            self.timestamp = timestamp

        def __str__(self):
            return "ConfirmationStatus.CONFIRMED(block_hash={}, height={}, timestamp={})".format(self.block_hash, self.height, self.timestamp)

        def __eq__(self, other):
            if not other.is_confirmed():
                return False
            if self.block_hash != other.block_hash:
                return False
            if self.height != other.height:
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    class UNCONFIRMED:

        def __init__(self,):
            pass

        def __str__(self):
            return "ConfirmationStatus.UNCONFIRMED()".format()

        def __eq__(self, other):
            if not other.is_unconfirmed():
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_confirmed(self) -> bool:
        return isinstance(self, ConfirmationStatus.CONFIRMED)
    def is_unconfirmed(self) -> bool:
        return isinstance(self, ConfirmationStatus.UNCONFIRMED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ConfirmationStatus.CONFIRMED = type("ConfirmationStatus.CONFIRMED", (ConfirmationStatus.CONFIRMED, ConfirmationStatus,), {})  # type: ignore
ConfirmationStatus.UNCONFIRMED = type("ConfirmationStatus.UNCONFIRMED", (ConfirmationStatus.UNCONFIRMED, ConfirmationStatus,), {})  # type: ignore




class _UniffiConverterTypeConfirmationStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ConfirmationStatus.CONFIRMED(
                _UniffiConverterTypeBlockHash.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return ConfirmationStatus.UNCONFIRMED(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_confirmed():
            _UniffiConverterTypeBlockHash.check_lower(value.block_hash)
            _UniffiConverterUInt32.check_lower(value.height)
            _UniffiConverterUInt64.check_lower(value.timestamp)
            return
        if value.is_unconfirmed():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_confirmed():
            buf.write_i32(1)
            _UniffiConverterTypeBlockHash.write(value.block_hash, buf)
            _UniffiConverterUInt32.write(value.height, buf)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_unconfirmed():
            buf.write_i32(2)







class Currency(enum.Enum):
    BITCOIN = 0
    
    BITCOIN_TESTNET = 1
    
    REGTEST = 2
    
    SIMNET = 3
    
    SIGNET = 4
    


class _UniffiConverterTypeCurrency(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Currency.BITCOIN
        if variant == 2:
            return Currency.BITCOIN_TESTNET
        if variant == 3:
            return Currency.REGTEST
        if variant == 4:
            return Currency.SIMNET
        if variant == 5:
            return Currency.SIGNET
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Currency.BITCOIN:
            return
        if value == Currency.BITCOIN_TESTNET:
            return
        if value == Currency.REGTEST:
            return
        if value == Currency.SIMNET:
            return
        if value == Currency.SIGNET:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Currency.BITCOIN:
            buf.write_i32(1)
        if value == Currency.BITCOIN_TESTNET:
            buf.write_i32(2)
        if value == Currency.REGTEST:
            buf.write_i32(3)
        if value == Currency.SIMNET:
            buf.write_i32(4)
        if value == Currency.SIGNET:
            buf.write_i32(5)







class Event:
    def __init__(self):
        raise RuntimeError("Event cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PAYMENT_SUCCESSFUL:
        payment_id: "typing.Optional[PaymentId]"
        payment_hash: "PaymentHash"
        payment_preimage: "typing.Optional[PaymentPreimage]"
        fee_paid_msat: "typing.Optional[int]"

        def __init__(self,payment_id: "typing.Optional[PaymentId]", payment_hash: "PaymentHash", payment_preimage: "typing.Optional[PaymentPreimage]", fee_paid_msat: "typing.Optional[int]"):
            self.payment_id = payment_id
            self.payment_hash = payment_hash
            self.payment_preimage = payment_preimage
            self.fee_paid_msat = fee_paid_msat

        def __str__(self):
            return "Event.PAYMENT_SUCCESSFUL(payment_id={}, payment_hash={}, payment_preimage={}, fee_paid_msat={})".format(self.payment_id, self.payment_hash, self.payment_preimage, self.fee_paid_msat)

        def __eq__(self, other):
            if not other.is_payment_successful():
                return False
            if self.payment_id != other.payment_id:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.payment_preimage != other.payment_preimage:
                return False
            if self.fee_paid_msat != other.fee_paid_msat:
                return False
            return True
    
    class PAYMENT_FAILED:
        payment_id: "typing.Optional[PaymentId]"
        payment_hash: "typing.Optional[PaymentHash]"
        reason: "typing.Optional[PaymentFailureReason]"

        def __init__(self,payment_id: "typing.Optional[PaymentId]", payment_hash: "typing.Optional[PaymentHash]", reason: "typing.Optional[PaymentFailureReason]"):
            self.payment_id = payment_id
            self.payment_hash = payment_hash
            self.reason = reason

        def __str__(self):
            return "Event.PAYMENT_FAILED(payment_id={}, payment_hash={}, reason={})".format(self.payment_id, self.payment_hash, self.reason)

        def __eq__(self, other):
            if not other.is_payment_failed():
                return False
            if self.payment_id != other.payment_id:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class PAYMENT_RECEIVED:
        payment_id: "typing.Optional[PaymentId]"
        payment_hash: "PaymentHash"
        amount_msat: "int"
        custom_records: "typing.List[CustomTlvRecord]"

        def __init__(self,payment_id: "typing.Optional[PaymentId]", payment_hash: "PaymentHash", amount_msat: "int", custom_records: "typing.List[CustomTlvRecord]"):
            self.payment_id = payment_id
            self.payment_hash = payment_hash
            self.amount_msat = amount_msat
            self.custom_records = custom_records

        def __str__(self):
            return "Event.PAYMENT_RECEIVED(payment_id={}, payment_hash={}, amount_msat={}, custom_records={})".format(self.payment_id, self.payment_hash, self.amount_msat, self.custom_records)

        def __eq__(self, other):
            if not other.is_payment_received():
                return False
            if self.payment_id != other.payment_id:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.amount_msat != other.amount_msat:
                return False
            if self.custom_records != other.custom_records:
                return False
            return True
    
    class PAYMENT_CLAIMABLE:
        payment_id: "PaymentId"
        payment_hash: "PaymentHash"
        claimable_amount_msat: "int"
        claim_deadline: "typing.Optional[int]"
        custom_records: "typing.List[CustomTlvRecord]"

        def __init__(self,payment_id: "PaymentId", payment_hash: "PaymentHash", claimable_amount_msat: "int", claim_deadline: "typing.Optional[int]", custom_records: "typing.List[CustomTlvRecord]"):
            self.payment_id = payment_id
            self.payment_hash = payment_hash
            self.claimable_amount_msat = claimable_amount_msat
            self.claim_deadline = claim_deadline
            self.custom_records = custom_records

        def __str__(self):
            return "Event.PAYMENT_CLAIMABLE(payment_id={}, payment_hash={}, claimable_amount_msat={}, claim_deadline={}, custom_records={})".format(self.payment_id, self.payment_hash, self.claimable_amount_msat, self.claim_deadline, self.custom_records)

        def __eq__(self, other):
            if not other.is_payment_claimable():
                return False
            if self.payment_id != other.payment_id:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.claimable_amount_msat != other.claimable_amount_msat:
                return False
            if self.claim_deadline != other.claim_deadline:
                return False
            if self.custom_records != other.custom_records:
                return False
            return True
    
    class PAYMENT_FORWARDED:
        prev_channel_id: "ChannelId"
        next_channel_id: "ChannelId"
        prev_user_channel_id: "typing.Optional[UserChannelId]"
        next_user_channel_id: "typing.Optional[UserChannelId]"
        prev_node_id: "typing.Optional[PublicKey]"
        next_node_id: "typing.Optional[PublicKey]"
        total_fee_earned_msat: "typing.Optional[int]"
        skimmed_fee_msat: "typing.Optional[int]"
        claim_from_onchain_tx: "bool"
        outbound_amount_forwarded_msat: "typing.Optional[int]"

        def __init__(self,prev_channel_id: "ChannelId", next_channel_id: "ChannelId", prev_user_channel_id: "typing.Optional[UserChannelId]", next_user_channel_id: "typing.Optional[UserChannelId]", prev_node_id: "typing.Optional[PublicKey]", next_node_id: "typing.Optional[PublicKey]", total_fee_earned_msat: "typing.Optional[int]", skimmed_fee_msat: "typing.Optional[int]", claim_from_onchain_tx: "bool", outbound_amount_forwarded_msat: "typing.Optional[int]"):
            self.prev_channel_id = prev_channel_id
            self.next_channel_id = next_channel_id
            self.prev_user_channel_id = prev_user_channel_id
            self.next_user_channel_id = next_user_channel_id
            self.prev_node_id = prev_node_id
            self.next_node_id = next_node_id
            self.total_fee_earned_msat = total_fee_earned_msat
            self.skimmed_fee_msat = skimmed_fee_msat
            self.claim_from_onchain_tx = claim_from_onchain_tx
            self.outbound_amount_forwarded_msat = outbound_amount_forwarded_msat

        def __str__(self):
            return "Event.PAYMENT_FORWARDED(prev_channel_id={}, next_channel_id={}, prev_user_channel_id={}, next_user_channel_id={}, prev_node_id={}, next_node_id={}, total_fee_earned_msat={}, skimmed_fee_msat={}, claim_from_onchain_tx={}, outbound_amount_forwarded_msat={})".format(self.prev_channel_id, self.next_channel_id, self.prev_user_channel_id, self.next_user_channel_id, self.prev_node_id, self.next_node_id, self.total_fee_earned_msat, self.skimmed_fee_msat, self.claim_from_onchain_tx, self.outbound_amount_forwarded_msat)

        def __eq__(self, other):
            if not other.is_payment_forwarded():
                return False
            if self.prev_channel_id != other.prev_channel_id:
                return False
            if self.next_channel_id != other.next_channel_id:
                return False
            if self.prev_user_channel_id != other.prev_user_channel_id:
                return False
            if self.next_user_channel_id != other.next_user_channel_id:
                return False
            if self.prev_node_id != other.prev_node_id:
                return False
            if self.next_node_id != other.next_node_id:
                return False
            if self.total_fee_earned_msat != other.total_fee_earned_msat:
                return False
            if self.skimmed_fee_msat != other.skimmed_fee_msat:
                return False
            if self.claim_from_onchain_tx != other.claim_from_onchain_tx:
                return False
            if self.outbound_amount_forwarded_msat != other.outbound_amount_forwarded_msat:
                return False
            return True
    
    class CHANNEL_PENDING:
        channel_id: "ChannelId"
        user_channel_id: "UserChannelId"
        former_temporary_channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        funding_txo: "OutPoint"

        def __init__(self,channel_id: "ChannelId", user_channel_id: "UserChannelId", former_temporary_channel_id: "ChannelId", counterparty_node_id: "PublicKey", funding_txo: "OutPoint"):
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.former_temporary_channel_id = former_temporary_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.funding_txo = funding_txo

        def __str__(self):
            return "Event.CHANNEL_PENDING(channel_id={}, user_channel_id={}, former_temporary_channel_id={}, counterparty_node_id={}, funding_txo={})".format(self.channel_id, self.user_channel_id, self.former_temporary_channel_id, self.counterparty_node_id, self.funding_txo)

        def __eq__(self, other):
            if not other.is_channel_pending():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.former_temporary_channel_id != other.former_temporary_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.funding_txo != other.funding_txo:
                return False
            return True
    
    class CHANNEL_READY:
        channel_id: "ChannelId"
        user_channel_id: "UserChannelId"
        counterparty_node_id: "typing.Optional[PublicKey]"
        funding_txo: "typing.Optional[OutPoint]"

        def __init__(self,channel_id: "ChannelId", user_channel_id: "UserChannelId", counterparty_node_id: "typing.Optional[PublicKey]", funding_txo: "typing.Optional[OutPoint]"):
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.funding_txo = funding_txo

        def __str__(self):
            return "Event.CHANNEL_READY(channel_id={}, user_channel_id={}, counterparty_node_id={}, funding_txo={})".format(self.channel_id, self.user_channel_id, self.counterparty_node_id, self.funding_txo)

        def __eq__(self, other):
            if not other.is_channel_ready():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.funding_txo != other.funding_txo:
                return False
            return True
    
    class CHANNEL_CLOSED:
        channel_id: "ChannelId"
        user_channel_id: "UserChannelId"
        counterparty_node_id: "typing.Optional[PublicKey]"
        reason: "typing.Optional[ClosureReason]"

        def __init__(self,channel_id: "ChannelId", user_channel_id: "UserChannelId", counterparty_node_id: "typing.Optional[PublicKey]", reason: "typing.Optional[ClosureReason]"):
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.reason = reason

        def __str__(self):
            return "Event.CHANNEL_CLOSED(channel_id={}, user_channel_id={}, counterparty_node_id={}, reason={})".format(self.channel_id, self.user_channel_id, self.counterparty_node_id, self.reason)

        def __eq__(self, other):
            if not other.is_channel_closed():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.reason != other.reason:
                return False
            return True
    
    class SPLICE_PENDING:
        channel_id: "ChannelId"
        user_channel_id: "UserChannelId"
        counterparty_node_id: "PublicKey"
        new_funding_txo: "OutPoint"

        def __init__(self,channel_id: "ChannelId", user_channel_id: "UserChannelId", counterparty_node_id: "PublicKey", new_funding_txo: "OutPoint"):
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.new_funding_txo = new_funding_txo

        def __str__(self):
            return "Event.SPLICE_PENDING(channel_id={}, user_channel_id={}, counterparty_node_id={}, new_funding_txo={})".format(self.channel_id, self.user_channel_id, self.counterparty_node_id, self.new_funding_txo)

        def __eq__(self, other):
            if not other.is_splice_pending():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.new_funding_txo != other.new_funding_txo:
                return False
            return True
    
    class SPLICE_FAILED:
        channel_id: "ChannelId"
        user_channel_id: "UserChannelId"
        counterparty_node_id: "PublicKey"
        abandoned_funding_txo: "typing.Optional[OutPoint]"

        def __init__(self,channel_id: "ChannelId", user_channel_id: "UserChannelId", counterparty_node_id: "PublicKey", abandoned_funding_txo: "typing.Optional[OutPoint]"):
            self.channel_id = channel_id
            self.user_channel_id = user_channel_id
            self.counterparty_node_id = counterparty_node_id
            self.abandoned_funding_txo = abandoned_funding_txo

        def __str__(self):
            return "Event.SPLICE_FAILED(channel_id={}, user_channel_id={}, counterparty_node_id={}, abandoned_funding_txo={})".format(self.channel_id, self.user_channel_id, self.counterparty_node_id, self.abandoned_funding_txo)

        def __eq__(self, other):
            if not other.is_splice_failed():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.user_channel_id != other.user_channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.abandoned_funding_txo != other.abandoned_funding_txo:
                return False
            return True
    
    class ONCHAIN_TRANSACTION_CONFIRMED:
        txid: "Txid"
        block_hash: "BlockHash"
        block_height: "int"
        confirmation_time: "int"
        details: "TransactionDetails"

        def __init__(self,txid: "Txid", block_hash: "BlockHash", block_height: "int", confirmation_time: "int", details: "TransactionDetails"):
            self.txid = txid
            self.block_hash = block_hash
            self.block_height = block_height
            self.confirmation_time = confirmation_time
            self.details = details

        def __str__(self):
            return "Event.ONCHAIN_TRANSACTION_CONFIRMED(txid={}, block_hash={}, block_height={}, confirmation_time={}, details={})".format(self.txid, self.block_hash, self.block_height, self.confirmation_time, self.details)

        def __eq__(self, other):
            if not other.is_onchain_transaction_confirmed():
                return False
            if self.txid != other.txid:
                return False
            if self.block_hash != other.block_hash:
                return False
            if self.block_height != other.block_height:
                return False
            if self.confirmation_time != other.confirmation_time:
                return False
            if self.details != other.details:
                return False
            return True
    
    class ONCHAIN_TRANSACTION_RECEIVED:
        txid: "Txid"
        details: "TransactionDetails"

        def __init__(self,txid: "Txid", details: "TransactionDetails"):
            self.txid = txid
            self.details = details

        def __str__(self):
            return "Event.ONCHAIN_TRANSACTION_RECEIVED(txid={}, details={})".format(self.txid, self.details)

        def __eq__(self, other):
            if not other.is_onchain_transaction_received():
                return False
            if self.txid != other.txid:
                return False
            if self.details != other.details:
                return False
            return True
    
    class ONCHAIN_TRANSACTION_REPLACED:
        txid: "Txid"
        conflicts: "typing.List[Txid]"

        def __init__(self,txid: "Txid", conflicts: "typing.List[Txid]"):
            self.txid = txid
            self.conflicts = conflicts

        def __str__(self):
            return "Event.ONCHAIN_TRANSACTION_REPLACED(txid={}, conflicts={})".format(self.txid, self.conflicts)

        def __eq__(self, other):
            if not other.is_onchain_transaction_replaced():
                return False
            if self.txid != other.txid:
                return False
            if self.conflicts != other.conflicts:
                return False
            return True
    
    class ONCHAIN_TRANSACTION_REORGED:
        txid: "Txid"

        def __init__(self,txid: "Txid"):
            self.txid = txid

        def __str__(self):
            return "Event.ONCHAIN_TRANSACTION_REORGED(txid={})".format(self.txid)

        def __eq__(self, other):
            if not other.is_onchain_transaction_reorged():
                return False
            if self.txid != other.txid:
                return False
            return True
    
    class ONCHAIN_TRANSACTION_EVICTED:
        txid: "Txid"

        def __init__(self,txid: "Txid"):
            self.txid = txid

        def __str__(self):
            return "Event.ONCHAIN_TRANSACTION_EVICTED(txid={})".format(self.txid)

        def __eq__(self, other):
            if not other.is_onchain_transaction_evicted():
                return False
            if self.txid != other.txid:
                return False
            return True
    
    class SYNC_PROGRESS:
        sync_type: "SyncType"
        progress_percent: "int"
        current_block_height: "int"
        target_block_height: "int"

        def __init__(self,sync_type: "SyncType", progress_percent: "int", current_block_height: "int", target_block_height: "int"):
            self.sync_type = sync_type
            self.progress_percent = progress_percent
            self.current_block_height = current_block_height
            self.target_block_height = target_block_height

        def __str__(self):
            return "Event.SYNC_PROGRESS(sync_type={}, progress_percent={}, current_block_height={}, target_block_height={})".format(self.sync_type, self.progress_percent, self.current_block_height, self.target_block_height)

        def __eq__(self, other):
            if not other.is_sync_progress():
                return False
            if self.sync_type != other.sync_type:
                return False
            if self.progress_percent != other.progress_percent:
                return False
            if self.current_block_height != other.current_block_height:
                return False
            if self.target_block_height != other.target_block_height:
                return False
            return True
    
    class SYNC_COMPLETED:
        sync_type: "SyncType"
        synced_block_height: "int"

        def __init__(self,sync_type: "SyncType", synced_block_height: "int"):
            self.sync_type = sync_type
            self.synced_block_height = synced_block_height

        def __str__(self):
            return "Event.SYNC_COMPLETED(sync_type={}, synced_block_height={})".format(self.sync_type, self.synced_block_height)

        def __eq__(self, other):
            if not other.is_sync_completed():
                return False
            if self.sync_type != other.sync_type:
                return False
            if self.synced_block_height != other.synced_block_height:
                return False
            return True
    
    class BALANCE_CHANGED:
        old_spendable_onchain_balance_sats: "int"
        new_spendable_onchain_balance_sats: "int"
        old_total_onchain_balance_sats: "int"
        new_total_onchain_balance_sats: "int"
        old_total_lightning_balance_sats: "int"
        new_total_lightning_balance_sats: "int"

        def __init__(self,old_spendable_onchain_balance_sats: "int", new_spendable_onchain_balance_sats: "int", old_total_onchain_balance_sats: "int", new_total_onchain_balance_sats: "int", old_total_lightning_balance_sats: "int", new_total_lightning_balance_sats: "int"):
            self.old_spendable_onchain_balance_sats = old_spendable_onchain_balance_sats
            self.new_spendable_onchain_balance_sats = new_spendable_onchain_balance_sats
            self.old_total_onchain_balance_sats = old_total_onchain_balance_sats
            self.new_total_onchain_balance_sats = new_total_onchain_balance_sats
            self.old_total_lightning_balance_sats = old_total_lightning_balance_sats
            self.new_total_lightning_balance_sats = new_total_lightning_balance_sats

        def __str__(self):
            return "Event.BALANCE_CHANGED(old_spendable_onchain_balance_sats={}, new_spendable_onchain_balance_sats={}, old_total_onchain_balance_sats={}, new_total_onchain_balance_sats={}, old_total_lightning_balance_sats={}, new_total_lightning_balance_sats={})".format(self.old_spendable_onchain_balance_sats, self.new_spendable_onchain_balance_sats, self.old_total_onchain_balance_sats, self.new_total_onchain_balance_sats, self.old_total_lightning_balance_sats, self.new_total_lightning_balance_sats)

        def __eq__(self, other):
            if not other.is_balance_changed():
                return False
            if self.old_spendable_onchain_balance_sats != other.old_spendable_onchain_balance_sats:
                return False
            if self.new_spendable_onchain_balance_sats != other.new_spendable_onchain_balance_sats:
                return False
            if self.old_total_onchain_balance_sats != other.old_total_onchain_balance_sats:
                return False
            if self.new_total_onchain_balance_sats != other.new_total_onchain_balance_sats:
                return False
            if self.old_total_lightning_balance_sats != other.old_total_lightning_balance_sats:
                return False
            if self.new_total_lightning_balance_sats != other.new_total_lightning_balance_sats:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_payment_successful(self) -> bool:
        return isinstance(self, Event.PAYMENT_SUCCESSFUL)
    def is_payment_failed(self) -> bool:
        return isinstance(self, Event.PAYMENT_FAILED)
    def is_payment_received(self) -> bool:
        return isinstance(self, Event.PAYMENT_RECEIVED)
    def is_payment_claimable(self) -> bool:
        return isinstance(self, Event.PAYMENT_CLAIMABLE)
    def is_payment_forwarded(self) -> bool:
        return isinstance(self, Event.PAYMENT_FORWARDED)
    def is_channel_pending(self) -> bool:
        return isinstance(self, Event.CHANNEL_PENDING)
    def is_channel_ready(self) -> bool:
        return isinstance(self, Event.CHANNEL_READY)
    def is_channel_closed(self) -> bool:
        return isinstance(self, Event.CHANNEL_CLOSED)
    def is_splice_pending(self) -> bool:
        return isinstance(self, Event.SPLICE_PENDING)
    def is_splice_failed(self) -> bool:
        return isinstance(self, Event.SPLICE_FAILED)
    def is_onchain_transaction_confirmed(self) -> bool:
        return isinstance(self, Event.ONCHAIN_TRANSACTION_CONFIRMED)
    def is_onchain_transaction_received(self) -> bool:
        return isinstance(self, Event.ONCHAIN_TRANSACTION_RECEIVED)
    def is_onchain_transaction_replaced(self) -> bool:
        return isinstance(self, Event.ONCHAIN_TRANSACTION_REPLACED)
    def is_onchain_transaction_reorged(self) -> bool:
        return isinstance(self, Event.ONCHAIN_TRANSACTION_REORGED)
    def is_onchain_transaction_evicted(self) -> bool:
        return isinstance(self, Event.ONCHAIN_TRANSACTION_EVICTED)
    def is_sync_progress(self) -> bool:
        return isinstance(self, Event.SYNC_PROGRESS)
    def is_sync_completed(self) -> bool:
        return isinstance(self, Event.SYNC_COMPLETED)
    def is_balance_changed(self) -> bool:
        return isinstance(self, Event.BALANCE_CHANGED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Event.PAYMENT_SUCCESSFUL = type("Event.PAYMENT_SUCCESSFUL", (Event.PAYMENT_SUCCESSFUL, Event,), {})  # type: ignore
Event.PAYMENT_FAILED = type("Event.PAYMENT_FAILED", (Event.PAYMENT_FAILED, Event,), {})  # type: ignore
Event.PAYMENT_RECEIVED = type("Event.PAYMENT_RECEIVED", (Event.PAYMENT_RECEIVED, Event,), {})  # type: ignore
Event.PAYMENT_CLAIMABLE = type("Event.PAYMENT_CLAIMABLE", (Event.PAYMENT_CLAIMABLE, Event,), {})  # type: ignore
Event.PAYMENT_FORWARDED = type("Event.PAYMENT_FORWARDED", (Event.PAYMENT_FORWARDED, Event,), {})  # type: ignore
Event.CHANNEL_PENDING = type("Event.CHANNEL_PENDING", (Event.CHANNEL_PENDING, Event,), {})  # type: ignore
Event.CHANNEL_READY = type("Event.CHANNEL_READY", (Event.CHANNEL_READY, Event,), {})  # type: ignore
Event.CHANNEL_CLOSED = type("Event.CHANNEL_CLOSED", (Event.CHANNEL_CLOSED, Event,), {})  # type: ignore
Event.SPLICE_PENDING = type("Event.SPLICE_PENDING", (Event.SPLICE_PENDING, Event,), {})  # type: ignore
Event.SPLICE_FAILED = type("Event.SPLICE_FAILED", (Event.SPLICE_FAILED, Event,), {})  # type: ignore
Event.ONCHAIN_TRANSACTION_CONFIRMED = type("Event.ONCHAIN_TRANSACTION_CONFIRMED", (Event.ONCHAIN_TRANSACTION_CONFIRMED, Event,), {})  # type: ignore
Event.ONCHAIN_TRANSACTION_RECEIVED = type("Event.ONCHAIN_TRANSACTION_RECEIVED", (Event.ONCHAIN_TRANSACTION_RECEIVED, Event,), {})  # type: ignore
Event.ONCHAIN_TRANSACTION_REPLACED = type("Event.ONCHAIN_TRANSACTION_REPLACED", (Event.ONCHAIN_TRANSACTION_REPLACED, Event,), {})  # type: ignore
Event.ONCHAIN_TRANSACTION_REORGED = type("Event.ONCHAIN_TRANSACTION_REORGED", (Event.ONCHAIN_TRANSACTION_REORGED, Event,), {})  # type: ignore
Event.ONCHAIN_TRANSACTION_EVICTED = type("Event.ONCHAIN_TRANSACTION_EVICTED", (Event.ONCHAIN_TRANSACTION_EVICTED, Event,), {})  # type: ignore
Event.SYNC_PROGRESS = type("Event.SYNC_PROGRESS", (Event.SYNC_PROGRESS, Event,), {})  # type: ignore
Event.SYNC_COMPLETED = type("Event.SYNC_COMPLETED", (Event.SYNC_COMPLETED, Event,), {})  # type: ignore
Event.BALANCE_CHANGED = type("Event.BALANCE_CHANGED", (Event.BALANCE_CHANGED, Event,), {})  # type: ignore




class _UniffiConverterTypeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Event.PAYMENT_SUCCESSFUL(
                _UniffiConverterOptionalTypePaymentId.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
            )
        if variant == 2:
            return Event.PAYMENT_FAILED(
                _UniffiConverterOptionalTypePaymentId.read(buf),
                _UniffiConverterOptionalTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentFailureReason.read(buf),
            )
        if variant == 3:
            return Event.PAYMENT_RECEIVED(
                _UniffiConverterOptionalTypePaymentId.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterSequenceTypeCustomTlvRecord.read(buf),
            )
        if variant == 4:
            return Event.PAYMENT_CLAIMABLE(
                _UniffiConverterTypePaymentId.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterOptionalUInt32.read(buf),
                _UniffiConverterSequenceTypeCustomTlvRecord.read(buf),
            )
        if variant == 5:
            return Event.PAYMENT_FORWARDED(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterOptionalTypeUserChannelId.read(buf),
                _UniffiConverterOptionalTypeUserChannelId.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterBool.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
            )
        if variant == 6:
            return Event.CHANNEL_PENDING(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeUserChannelId.read(buf),
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterTypeOutPoint.read(buf),
            )
        if variant == 7:
            return Event.CHANNEL_READY(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeUserChannelId.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeOutPoint.read(buf),
            )
        if variant == 8:
            return Event.CHANNEL_CLOSED(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeUserChannelId.read(buf),
                _UniffiConverterOptionalTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeClosureReason.read(buf),
            )
        if variant == 9:
            return Event.SPLICE_PENDING(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeUserChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterTypeOutPoint.read(buf),
            )
        if variant == 10:
            return Event.SPLICE_FAILED(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypeUserChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterOptionalTypeOutPoint.read(buf),
            )
        if variant == 11:
            return Event.ONCHAIN_TRANSACTION_CONFIRMED(
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterTypeBlockHash.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypeTransactionDetails.read(buf),
            )
        if variant == 12:
            return Event.ONCHAIN_TRANSACTION_RECEIVED(
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterTypeTransactionDetails.read(buf),
            )
        if variant == 13:
            return Event.ONCHAIN_TRANSACTION_REPLACED(
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterSequenceTypeTxid.read(buf),
            )
        if variant == 14:
            return Event.ONCHAIN_TRANSACTION_REORGED(
                _UniffiConverterTypeTxid.read(buf),
            )
        if variant == 15:
            return Event.ONCHAIN_TRANSACTION_EVICTED(
                _UniffiConverterTypeTxid.read(buf),
            )
        if variant == 16:
            return Event.SYNC_PROGRESS(
                _UniffiConverterTypeSyncType.read(buf),
                _UniffiConverterUInt8.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 17:
            return Event.SYNC_COMPLETED(
                _UniffiConverterTypeSyncType.read(buf),
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 18:
            return Event.BALANCE_CHANGED(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_payment_successful():
            _UniffiConverterOptionalTypePaymentId.check_lower(value.payment_id)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.payment_preimage)
            _UniffiConverterOptionalUInt64.check_lower(value.fee_paid_msat)
            return
        if value.is_payment_failed():
            _UniffiConverterOptionalTypePaymentId.check_lower(value.payment_id)
            _UniffiConverterOptionalTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterOptionalTypePaymentFailureReason.check_lower(value.reason)
            return
        if value.is_payment_received():
            _UniffiConverterOptionalTypePaymentId.check_lower(value.payment_id)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterUInt64.check_lower(value.amount_msat)
            _UniffiConverterSequenceTypeCustomTlvRecord.check_lower(value.custom_records)
            return
        if value.is_payment_claimable():
            _UniffiConverterTypePaymentId.check_lower(value.payment_id)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterUInt64.check_lower(value.claimable_amount_msat)
            _UniffiConverterOptionalUInt32.check_lower(value.claim_deadline)
            _UniffiConverterSequenceTypeCustomTlvRecord.check_lower(value.custom_records)
            return
        if value.is_payment_forwarded():
            _UniffiConverterTypeChannelId.check_lower(value.prev_channel_id)
            _UniffiConverterTypeChannelId.check_lower(value.next_channel_id)
            _UniffiConverterOptionalTypeUserChannelId.check_lower(value.prev_user_channel_id)
            _UniffiConverterOptionalTypeUserChannelId.check_lower(value.next_user_channel_id)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.prev_node_id)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.next_node_id)
            _UniffiConverterOptionalUInt64.check_lower(value.total_fee_earned_msat)
            _UniffiConverterOptionalUInt64.check_lower(value.skimmed_fee_msat)
            _UniffiConverterBool.check_lower(value.claim_from_onchain_tx)
            _UniffiConverterOptionalUInt64.check_lower(value.outbound_amount_forwarded_msat)
            return
        if value.is_channel_pending():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
            _UniffiConverterTypeChannelId.check_lower(value.former_temporary_channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterTypeOutPoint.check_lower(value.funding_txo)
            return
        if value.is_channel_ready():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterOptionalTypeOutPoint.check_lower(value.funding_txo)
            return
        if value.is_channel_closed():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
            _UniffiConverterOptionalTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterOptionalTypeClosureReason.check_lower(value.reason)
            return
        if value.is_splice_pending():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterTypeOutPoint.check_lower(value.new_funding_txo)
            return
        if value.is_splice_failed():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeUserChannelId.check_lower(value.user_channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterOptionalTypeOutPoint.check_lower(value.abandoned_funding_txo)
            return
        if value.is_onchain_transaction_confirmed():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            _UniffiConverterTypeBlockHash.check_lower(value.block_hash)
            _UniffiConverterUInt32.check_lower(value.block_height)
            _UniffiConverterUInt64.check_lower(value.confirmation_time)
            _UniffiConverterTypeTransactionDetails.check_lower(value.details)
            return
        if value.is_onchain_transaction_received():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            _UniffiConverterTypeTransactionDetails.check_lower(value.details)
            return
        if value.is_onchain_transaction_replaced():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            _UniffiConverterSequenceTypeTxid.check_lower(value.conflicts)
            return
        if value.is_onchain_transaction_reorged():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            return
        if value.is_onchain_transaction_evicted():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            return
        if value.is_sync_progress():
            _UniffiConverterTypeSyncType.check_lower(value.sync_type)
            _UniffiConverterUInt8.check_lower(value.progress_percent)
            _UniffiConverterUInt32.check_lower(value.current_block_height)
            _UniffiConverterUInt32.check_lower(value.target_block_height)
            return
        if value.is_sync_completed():
            _UniffiConverterTypeSyncType.check_lower(value.sync_type)
            _UniffiConverterUInt32.check_lower(value.synced_block_height)
            return
        if value.is_balance_changed():
            _UniffiConverterUInt64.check_lower(value.old_spendable_onchain_balance_sats)
            _UniffiConverterUInt64.check_lower(value.new_spendable_onchain_balance_sats)
            _UniffiConverterUInt64.check_lower(value.old_total_onchain_balance_sats)
            _UniffiConverterUInt64.check_lower(value.new_total_onchain_balance_sats)
            _UniffiConverterUInt64.check_lower(value.old_total_lightning_balance_sats)
            _UniffiConverterUInt64.check_lower(value.new_total_lightning_balance_sats)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_payment_successful():
            buf.write_i32(1)
            _UniffiConverterOptionalTypePaymentId.write(value.payment_id, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.payment_preimage, buf)
            _UniffiConverterOptionalUInt64.write(value.fee_paid_msat, buf)
        if value.is_payment_failed():
            buf.write_i32(2)
            _UniffiConverterOptionalTypePaymentId.write(value.payment_id, buf)
            _UniffiConverterOptionalTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterOptionalTypePaymentFailureReason.write(value.reason, buf)
        if value.is_payment_received():
            buf.write_i32(3)
            _UniffiConverterOptionalTypePaymentId.write(value.payment_id, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterUInt64.write(value.amount_msat, buf)
            _UniffiConverterSequenceTypeCustomTlvRecord.write(value.custom_records, buf)
        if value.is_payment_claimable():
            buf.write_i32(4)
            _UniffiConverterTypePaymentId.write(value.payment_id, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterUInt64.write(value.claimable_amount_msat, buf)
            _UniffiConverterOptionalUInt32.write(value.claim_deadline, buf)
            _UniffiConverterSequenceTypeCustomTlvRecord.write(value.custom_records, buf)
        if value.is_payment_forwarded():
            buf.write_i32(5)
            _UniffiConverterTypeChannelId.write(value.prev_channel_id, buf)
            _UniffiConverterTypeChannelId.write(value.next_channel_id, buf)
            _UniffiConverterOptionalTypeUserChannelId.write(value.prev_user_channel_id, buf)
            _UniffiConverterOptionalTypeUserChannelId.write(value.next_user_channel_id, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.prev_node_id, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.next_node_id, buf)
            _UniffiConverterOptionalUInt64.write(value.total_fee_earned_msat, buf)
            _UniffiConverterOptionalUInt64.write(value.skimmed_fee_msat, buf)
            _UniffiConverterBool.write(value.claim_from_onchain_tx, buf)
            _UniffiConverterOptionalUInt64.write(value.outbound_amount_forwarded_msat, buf)
        if value.is_channel_pending():
            buf.write_i32(6)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            _UniffiConverterTypeChannelId.write(value.former_temporary_channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterTypeOutPoint.write(value.funding_txo, buf)
        if value.is_channel_ready():
            buf.write_i32(7)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterOptionalTypeOutPoint.write(value.funding_txo, buf)
        if value.is_channel_closed():
            buf.write_i32(8)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            _UniffiConverterOptionalTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterOptionalTypeClosureReason.write(value.reason, buf)
        if value.is_splice_pending():
            buf.write_i32(9)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterTypeOutPoint.write(value.new_funding_txo, buf)
        if value.is_splice_failed():
            buf.write_i32(10)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeUserChannelId.write(value.user_channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterOptionalTypeOutPoint.write(value.abandoned_funding_txo, buf)
        if value.is_onchain_transaction_confirmed():
            buf.write_i32(11)
            _UniffiConverterTypeTxid.write(value.txid, buf)
            _UniffiConverterTypeBlockHash.write(value.block_hash, buf)
            _UniffiConverterUInt32.write(value.block_height, buf)
            _UniffiConverterUInt64.write(value.confirmation_time, buf)
            _UniffiConverterTypeTransactionDetails.write(value.details, buf)
        if value.is_onchain_transaction_received():
            buf.write_i32(12)
            _UniffiConverterTypeTxid.write(value.txid, buf)
            _UniffiConverterTypeTransactionDetails.write(value.details, buf)
        if value.is_onchain_transaction_replaced():
            buf.write_i32(13)
            _UniffiConverterTypeTxid.write(value.txid, buf)
            _UniffiConverterSequenceTypeTxid.write(value.conflicts, buf)
        if value.is_onchain_transaction_reorged():
            buf.write_i32(14)
            _UniffiConverterTypeTxid.write(value.txid, buf)
        if value.is_onchain_transaction_evicted():
            buf.write_i32(15)
            _UniffiConverterTypeTxid.write(value.txid, buf)
        if value.is_sync_progress():
            buf.write_i32(16)
            _UniffiConverterTypeSyncType.write(value.sync_type, buf)
            _UniffiConverterUInt8.write(value.progress_percent, buf)
            _UniffiConverterUInt32.write(value.current_block_height, buf)
            _UniffiConverterUInt32.write(value.target_block_height, buf)
        if value.is_sync_completed():
            buf.write_i32(17)
            _UniffiConverterTypeSyncType.write(value.sync_type, buf)
            _UniffiConverterUInt32.write(value.synced_block_height, buf)
        if value.is_balance_changed():
            buf.write_i32(18)
            _UniffiConverterUInt64.write(value.old_spendable_onchain_balance_sats, buf)
            _UniffiConverterUInt64.write(value.new_spendable_onchain_balance_sats, buf)
            _UniffiConverterUInt64.write(value.old_total_onchain_balance_sats, buf)
            _UniffiConverterUInt64.write(value.new_total_onchain_balance_sats, buf)
            _UniffiConverterUInt64.write(value.old_total_lightning_balance_sats, buf)
            _UniffiConverterUInt64.write(value.new_total_lightning_balance_sats, buf)







class LightningBalance:
    def __init__(self):
        raise RuntimeError("LightningBalance cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CLAIMABLE_ON_CHANNEL_CLOSE:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"
        transaction_fee_satoshis: "int"
        outbound_payment_htlc_rounded_msat: "int"
        outbound_forwarded_htlc_rounded_msat: "int"
        inbound_claiming_htlc_rounded_msat: "int"
        inbound_htlc_rounded_msat: "int"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int", transaction_fee_satoshis: "int", outbound_payment_htlc_rounded_msat: "int", outbound_forwarded_htlc_rounded_msat: "int", inbound_claiming_htlc_rounded_msat: "int", inbound_htlc_rounded_msat: "int"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis
            self.transaction_fee_satoshis = transaction_fee_satoshis
            self.outbound_payment_htlc_rounded_msat = outbound_payment_htlc_rounded_msat
            self.outbound_forwarded_htlc_rounded_msat = outbound_forwarded_htlc_rounded_msat
            self.inbound_claiming_htlc_rounded_msat = inbound_claiming_htlc_rounded_msat
            self.inbound_htlc_rounded_msat = inbound_htlc_rounded_msat

        def __str__(self):
            return "LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE(channel_id={}, counterparty_node_id={}, amount_satoshis={}, transaction_fee_satoshis={}, outbound_payment_htlc_rounded_msat={}, outbound_forwarded_htlc_rounded_msat={}, inbound_claiming_htlc_rounded_msat={}, inbound_htlc_rounded_msat={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis, self.transaction_fee_satoshis, self.outbound_payment_htlc_rounded_msat, self.outbound_forwarded_htlc_rounded_msat, self.inbound_claiming_htlc_rounded_msat, self.inbound_htlc_rounded_msat)

        def __eq__(self, other):
            if not other.is_claimable_on_channel_close():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            if self.transaction_fee_satoshis != other.transaction_fee_satoshis:
                return False
            if self.outbound_payment_htlc_rounded_msat != other.outbound_payment_htlc_rounded_msat:
                return False
            if self.outbound_forwarded_htlc_rounded_msat != other.outbound_forwarded_htlc_rounded_msat:
                return False
            if self.inbound_claiming_htlc_rounded_msat != other.inbound_claiming_htlc_rounded_msat:
                return False
            if self.inbound_htlc_rounded_msat != other.inbound_htlc_rounded_msat:
                return False
            return True
    
    class CLAIMABLE_AWAITING_CONFIRMATIONS:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"
        confirmation_height: "int"
        source: "BalanceSource"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int", confirmation_height: "int", source: "BalanceSource"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis
            self.confirmation_height = confirmation_height
            self.source = source

        def __str__(self):
            return "LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS(channel_id={}, counterparty_node_id={}, amount_satoshis={}, confirmation_height={}, source={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis, self.confirmation_height, self.source)

        def __eq__(self, other):
            if not other.is_claimable_awaiting_confirmations():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            if self.confirmation_height != other.confirmation_height:
                return False
            if self.source != other.source:
                return False
            return True
    
    class CONTENTIOUS_CLAIMABLE:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"
        timeout_height: "int"
        payment_hash: "PaymentHash"
        payment_preimage: "PaymentPreimage"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int", timeout_height: "int", payment_hash: "PaymentHash", payment_preimage: "PaymentPreimage"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis
            self.timeout_height = timeout_height
            self.payment_hash = payment_hash
            self.payment_preimage = payment_preimage

        def __str__(self):
            return "LightningBalance.CONTENTIOUS_CLAIMABLE(channel_id={}, counterparty_node_id={}, amount_satoshis={}, timeout_height={}, payment_hash={}, payment_preimage={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis, self.timeout_height, self.payment_hash, self.payment_preimage)

        def __eq__(self, other):
            if not other.is_contentious_claimable():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            if self.timeout_height != other.timeout_height:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.payment_preimage != other.payment_preimage:
                return False
            return True
    
    class MAYBE_TIMEOUT_CLAIMABLE_HTLC:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"
        claimable_height: "int"
        payment_hash: "PaymentHash"
        outbound_payment: "bool"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int", claimable_height: "int", payment_hash: "PaymentHash", outbound_payment: "bool"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis
            self.claimable_height = claimable_height
            self.payment_hash = payment_hash
            self.outbound_payment = outbound_payment

        def __str__(self):
            return "LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC(channel_id={}, counterparty_node_id={}, amount_satoshis={}, claimable_height={}, payment_hash={}, outbound_payment={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis, self.claimable_height, self.payment_hash, self.outbound_payment)

        def __eq__(self, other):
            if not other.is_maybe_timeout_claimable_htlc():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            if self.claimable_height != other.claimable_height:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            if self.outbound_payment != other.outbound_payment:
                return False
            return True
    
    class MAYBE_PREIMAGE_CLAIMABLE_HTLC:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"
        expiry_height: "int"
        payment_hash: "PaymentHash"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int", expiry_height: "int", payment_hash: "PaymentHash"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis
            self.expiry_height = expiry_height
            self.payment_hash = payment_hash

        def __str__(self):
            return "LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC(channel_id={}, counterparty_node_id={}, amount_satoshis={}, expiry_height={}, payment_hash={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis, self.expiry_height, self.payment_hash)

        def __eq__(self, other):
            if not other.is_maybe_preimage_claimable_htlc():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            if self.expiry_height != other.expiry_height:
                return False
            if self.payment_hash != other.payment_hash:
                return False
            return True
    
    class COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE:
        channel_id: "ChannelId"
        counterparty_node_id: "PublicKey"
        amount_satoshis: "int"

        def __init__(self,channel_id: "ChannelId", counterparty_node_id: "PublicKey", amount_satoshis: "int"):
            self.channel_id = channel_id
            self.counterparty_node_id = counterparty_node_id
            self.amount_satoshis = amount_satoshis

        def __str__(self):
            return "LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE(channel_id={}, counterparty_node_id={}, amount_satoshis={})".format(self.channel_id, self.counterparty_node_id, self.amount_satoshis)

        def __eq__(self, other):
            if not other.is_counterparty_revoked_output_claimable():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.counterparty_node_id != other.counterparty_node_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_claimable_on_channel_close(self) -> bool:
        return isinstance(self, LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE)
    def is_claimable_awaiting_confirmations(self) -> bool:
        return isinstance(self, LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS)
    def is_contentious_claimable(self) -> bool:
        return isinstance(self, LightningBalance.CONTENTIOUS_CLAIMABLE)
    def is_maybe_timeout_claimable_htlc(self) -> bool:
        return isinstance(self, LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC)
    def is_maybe_preimage_claimable_htlc(self) -> bool:
        return isinstance(self, LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC)
    def is_counterparty_revoked_output_claimable(self) -> bool:
        return isinstance(self, LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE = type("LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE", (LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE, LightningBalance,), {})  # type: ignore
LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS = type("LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS", (LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS, LightningBalance,), {})  # type: ignore
LightningBalance.CONTENTIOUS_CLAIMABLE = type("LightningBalance.CONTENTIOUS_CLAIMABLE", (LightningBalance.CONTENTIOUS_CLAIMABLE, LightningBalance,), {})  # type: ignore
LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC = type("LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC", (LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC, LightningBalance,), {})  # type: ignore
LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC = type("LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC", (LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC, LightningBalance,), {})  # type: ignore
LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE = type("LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE", (LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE, LightningBalance,), {})  # type: ignore




class _UniffiConverterTypeLightningBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LightningBalance.CLAIMABLE_ON_CHANNEL_CLOSE(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return LightningBalance.CLAIMABLE_AWAITING_CONFIRMATIONS(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterTypeBalanceSource.read(buf),
            )
        if variant == 3:
            return LightningBalance.CONTENTIOUS_CLAIMABLE(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterTypePaymentPreimage.read(buf),
            )
        if variant == 4:
            return LightningBalance.MAYBE_TIMEOUT_CLAIMABLE_HTLC(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterBool.read(buf),
            )
        if variant == 5:
            return LightningBalance.MAYBE_PREIMAGE_CLAIMABLE_HTLC(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterTypePaymentHash.read(buf),
            )
        if variant == 6:
            return LightningBalance.COUNTERPARTY_REVOKED_OUTPUT_CLAIMABLE(
                _UniffiConverterTypeChannelId.read(buf),
                _UniffiConverterTypePublicKey.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_claimable_on_channel_close():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            _UniffiConverterUInt64.check_lower(value.transaction_fee_satoshis)
            _UniffiConverterUInt64.check_lower(value.outbound_payment_htlc_rounded_msat)
            _UniffiConverterUInt64.check_lower(value.outbound_forwarded_htlc_rounded_msat)
            _UniffiConverterUInt64.check_lower(value.inbound_claiming_htlc_rounded_msat)
            _UniffiConverterUInt64.check_lower(value.inbound_htlc_rounded_msat)
            return
        if value.is_claimable_awaiting_confirmations():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            _UniffiConverterUInt32.check_lower(value.confirmation_height)
            _UniffiConverterTypeBalanceSource.check_lower(value.source)
            return
        if value.is_contentious_claimable():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            _UniffiConverterUInt32.check_lower(value.timeout_height)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterTypePaymentPreimage.check_lower(value.payment_preimage)
            return
        if value.is_maybe_timeout_claimable_htlc():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            _UniffiConverterUInt32.check_lower(value.claimable_height)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            _UniffiConverterBool.check_lower(value.outbound_payment)
            return
        if value.is_maybe_preimage_claimable_htlc():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            _UniffiConverterUInt32.check_lower(value.expiry_height)
            _UniffiConverterTypePaymentHash.check_lower(value.payment_hash)
            return
        if value.is_counterparty_revoked_output_claimable():
            _UniffiConverterTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypePublicKey.check_lower(value.counterparty_node_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_claimable_on_channel_close():
            buf.write_i32(1)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
            _UniffiConverterUInt64.write(value.transaction_fee_satoshis, buf)
            _UniffiConverterUInt64.write(value.outbound_payment_htlc_rounded_msat, buf)
            _UniffiConverterUInt64.write(value.outbound_forwarded_htlc_rounded_msat, buf)
            _UniffiConverterUInt64.write(value.inbound_claiming_htlc_rounded_msat, buf)
            _UniffiConverterUInt64.write(value.inbound_htlc_rounded_msat, buf)
        if value.is_claimable_awaiting_confirmations():
            buf.write_i32(2)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
            _UniffiConverterUInt32.write(value.confirmation_height, buf)
            _UniffiConverterTypeBalanceSource.write(value.source, buf)
        if value.is_contentious_claimable():
            buf.write_i32(3)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
            _UniffiConverterUInt32.write(value.timeout_height, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterTypePaymentPreimage.write(value.payment_preimage, buf)
        if value.is_maybe_timeout_claimable_htlc():
            buf.write_i32(4)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
            _UniffiConverterUInt32.write(value.claimable_height, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
            _UniffiConverterBool.write(value.outbound_payment, buf)
        if value.is_maybe_preimage_claimable_htlc():
            buf.write_i32(5)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
            _UniffiConverterUInt32.write(value.expiry_height, buf)
            _UniffiConverterTypePaymentHash.write(value.payment_hash, buf)
        if value.is_counterparty_revoked_output_claimable():
            buf.write_i32(6)
            _UniffiConverterTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypePublicKey.write(value.counterparty_node_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)







class LogLevel(enum.Enum):
    GOSSIP = 0
    
    TRACE = 1
    
    DEBUG = 2
    
    INFO = 3
    
    WARN = 4
    
    ERROR = 5
    


class _UniffiConverterTypeLogLevel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LogLevel.GOSSIP
        if variant == 2:
            return LogLevel.TRACE
        if variant == 3:
            return LogLevel.DEBUG
        if variant == 4:
            return LogLevel.INFO
        if variant == 5:
            return LogLevel.WARN
        if variant == 6:
            return LogLevel.ERROR
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == LogLevel.GOSSIP:
            return
        if value == LogLevel.TRACE:
            return
        if value == LogLevel.DEBUG:
            return
        if value == LogLevel.INFO:
            return
        if value == LogLevel.WARN:
            return
        if value == LogLevel.ERROR:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == LogLevel.GOSSIP:
            buf.write_i32(1)
        if value == LogLevel.TRACE:
            buf.write_i32(2)
        if value == LogLevel.DEBUG:
            buf.write_i32(3)
        if value == LogLevel.INFO:
            buf.write_i32(4)
        if value == LogLevel.WARN:
            buf.write_i32(5)
        if value == LogLevel.ERROR:
            buf.write_i32(6)







class Lsps1PaymentState(enum.Enum):
    EXPECT_PAYMENT = 0
    
    PAID = 1
    
    REFUNDED = 2
    


class _UniffiConverterTypeLsps1PaymentState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Lsps1PaymentState.EXPECT_PAYMENT
        if variant == 2:
            return Lsps1PaymentState.PAID
        if variant == 3:
            return Lsps1PaymentState.REFUNDED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Lsps1PaymentState.EXPECT_PAYMENT:
            return
        if value == Lsps1PaymentState.PAID:
            return
        if value == Lsps1PaymentState.REFUNDED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Lsps1PaymentState.EXPECT_PAYMENT:
            buf.write_i32(1)
        if value == Lsps1PaymentState.PAID:
            buf.write_i32(2)
        if value == Lsps1PaymentState.REFUNDED:
            buf.write_i32(3)







class MaxDustHtlcExposure:
    def __init__(self):
        raise RuntimeError("MaxDustHtlcExposure cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class FIXED_LIMIT:
        limit_msat: "int"

        def __init__(self,limit_msat: "int"):
            self.limit_msat = limit_msat

        def __str__(self):
            return "MaxDustHtlcExposure.FIXED_LIMIT(limit_msat={})".format(self.limit_msat)

        def __eq__(self, other):
            if not other.is_fixed_limit():
                return False
            if self.limit_msat != other.limit_msat:
                return False
            return True
    
    class FEE_RATE_MULTIPLIER:
        multiplier: "int"

        def __init__(self,multiplier: "int"):
            self.multiplier = multiplier

        def __str__(self):
            return "MaxDustHtlcExposure.FEE_RATE_MULTIPLIER(multiplier={})".format(self.multiplier)

        def __eq__(self, other):
            if not other.is_fee_rate_multiplier():
                return False
            if self.multiplier != other.multiplier:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_fixed_limit(self) -> bool:
        return isinstance(self, MaxDustHtlcExposure.FIXED_LIMIT)
    def is_fee_rate_multiplier(self) -> bool:
        return isinstance(self, MaxDustHtlcExposure.FEE_RATE_MULTIPLIER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
MaxDustHtlcExposure.FIXED_LIMIT = type("MaxDustHtlcExposure.FIXED_LIMIT", (MaxDustHtlcExposure.FIXED_LIMIT, MaxDustHtlcExposure,), {})  # type: ignore
MaxDustHtlcExposure.FEE_RATE_MULTIPLIER = type("MaxDustHtlcExposure.FEE_RATE_MULTIPLIER", (MaxDustHtlcExposure.FEE_RATE_MULTIPLIER, MaxDustHtlcExposure,), {})  # type: ignore




class _UniffiConverterTypeMaxDustHtlcExposure(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MaxDustHtlcExposure.FIXED_LIMIT(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return MaxDustHtlcExposure.FEE_RATE_MULTIPLIER(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_fixed_limit():
            _UniffiConverterUInt64.check_lower(value.limit_msat)
            return
        if value.is_fee_rate_multiplier():
            _UniffiConverterUInt64.check_lower(value.multiplier)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_fixed_limit():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.limit_msat, buf)
        if value.is_fee_rate_multiplier():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.multiplier, buf)







class Network(enum.Enum):
    BITCOIN = 0
    
    TESTNET = 1
    
    SIGNET = 2
    
    REGTEST = 3
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.BITCOIN:
            return
        if value == Network.TESTNET:
            return
        if value == Network.SIGNET:
            return
        if value == Network.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Network.BITCOIN:
            buf.write_i32(1)
        if value == Network.TESTNET:
            buf.write_i32(2)
        if value == Network.SIGNET:
            buf.write_i32(3)
        if value == Network.REGTEST:
            buf.write_i32(4)




# NodeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class NodeError(Exception):
    pass

_UniffiTempNodeError = NodeError

class NodeError:  # type: ignore
    class AlreadyRunning(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.AlreadyRunning({})".format(repr(str(self)))
    _UniffiTempNodeError.AlreadyRunning = AlreadyRunning # type: ignore
    class NotRunning(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.NotRunning({})".format(repr(str(self)))
    _UniffiTempNodeError.NotRunning = NotRunning # type: ignore
    class OnchainTxCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.OnchainTxCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.OnchainTxCreationFailed = OnchainTxCreationFailed # type: ignore
    class ConnectionFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ConnectionFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ConnectionFailed = ConnectionFailed # type: ignore
    class InvoiceCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvoiceCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.InvoiceCreationFailed = InvoiceCreationFailed # type: ignore
    class InvoiceRequestCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvoiceRequestCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.InvoiceRequestCreationFailed = InvoiceRequestCreationFailed # type: ignore
    class OfferCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.OfferCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.OfferCreationFailed = OfferCreationFailed # type: ignore
    class RefundCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.RefundCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.RefundCreationFailed = RefundCreationFailed # type: ignore
    class PaymentSendingFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.PaymentSendingFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.PaymentSendingFailed = PaymentSendingFailed # type: ignore
    class InvalidCustomTlvs(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidCustomTlvs({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidCustomTlvs = InvalidCustomTlvs # type: ignore
    class ProbeSendingFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ProbeSendingFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ProbeSendingFailed = ProbeSendingFailed # type: ignore
    class RouteNotFound(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.RouteNotFound({})".format(repr(str(self)))
    _UniffiTempNodeError.RouteNotFound = RouteNotFound # type: ignore
    class ChannelCreationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ChannelCreationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ChannelCreationFailed = ChannelCreationFailed # type: ignore
    class ChannelClosingFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ChannelClosingFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ChannelClosingFailed = ChannelClosingFailed # type: ignore
    class ChannelSplicingFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ChannelSplicingFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ChannelSplicingFailed = ChannelSplicingFailed # type: ignore
    class ChannelConfigUpdateFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.ChannelConfigUpdateFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.ChannelConfigUpdateFailed = ChannelConfigUpdateFailed # type: ignore
    class PersistenceFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.PersistenceFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.PersistenceFailed = PersistenceFailed # type: ignore
    class FeerateEstimationUpdateFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.FeerateEstimationUpdateFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.FeerateEstimationUpdateFailed = FeerateEstimationUpdateFailed # type: ignore
    class FeerateEstimationUpdateTimeout(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.FeerateEstimationUpdateTimeout({})".format(repr(str(self)))
    _UniffiTempNodeError.FeerateEstimationUpdateTimeout = FeerateEstimationUpdateTimeout # type: ignore
    class WalletOperationFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.WalletOperationFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.WalletOperationFailed = WalletOperationFailed # type: ignore
    class WalletOperationTimeout(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.WalletOperationTimeout({})".format(repr(str(self)))
    _UniffiTempNodeError.WalletOperationTimeout = WalletOperationTimeout # type: ignore
    class OnchainTxSigningFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.OnchainTxSigningFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.OnchainTxSigningFailed = OnchainTxSigningFailed # type: ignore
    class TxSyncFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.TxSyncFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.TxSyncFailed = TxSyncFailed # type: ignore
    class TxSyncTimeout(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.TxSyncTimeout({})".format(repr(str(self)))
    _UniffiTempNodeError.TxSyncTimeout = TxSyncTimeout # type: ignore
    class GossipUpdateFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.GossipUpdateFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.GossipUpdateFailed = GossipUpdateFailed # type: ignore
    class GossipUpdateTimeout(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.GossipUpdateTimeout({})".format(repr(str(self)))
    _UniffiTempNodeError.GossipUpdateTimeout = GossipUpdateTimeout # type: ignore
    class LiquidityRequestFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.LiquidityRequestFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.LiquidityRequestFailed = LiquidityRequestFailed # type: ignore
    class UriParameterParsingFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.UriParameterParsingFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.UriParameterParsingFailed = UriParameterParsingFailed # type: ignore
    class InvalidAddress(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidAddress({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidAddress = InvalidAddress # type: ignore
    class InvalidSocketAddress(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidSocketAddress({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidSocketAddress = InvalidSocketAddress # type: ignore
    class InvalidPublicKey(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidPublicKey({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidPublicKey = InvalidPublicKey # type: ignore
    class InvalidSecretKey(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidSecretKey({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidSecretKey = InvalidSecretKey # type: ignore
    class InvalidOfferId(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidOfferId({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidOfferId = InvalidOfferId # type: ignore
    class InvalidNodeId(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidNodeId({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidNodeId = InvalidNodeId # type: ignore
    class InvalidPaymentId(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidPaymentId({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidPaymentId = InvalidPaymentId # type: ignore
    class InvalidPaymentHash(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidPaymentHash({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidPaymentHash = InvalidPaymentHash # type: ignore
    class InvalidPaymentPreimage(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidPaymentPreimage({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidPaymentPreimage = InvalidPaymentPreimage # type: ignore
    class InvalidPaymentSecret(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidPaymentSecret({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidPaymentSecret = InvalidPaymentSecret # type: ignore
    class InvalidAmount(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidAmount({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidAmount = InvalidAmount # type: ignore
    class InvalidInvoice(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidInvoice({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidInvoice = InvalidInvoice # type: ignore
    class InvalidOffer(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidOffer({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidOffer = InvalidOffer # type: ignore
    class InvalidRefund(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidRefund({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidRefund = InvalidRefund # type: ignore
    class InvalidChannelId(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidChannelId({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidChannelId = InvalidChannelId # type: ignore
    class InvalidNetwork(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidNetwork({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidNetwork = InvalidNetwork # type: ignore
    class InvalidUri(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidUri({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidUri = InvalidUri # type: ignore
    class InvalidQuantity(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidQuantity({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidQuantity = InvalidQuantity # type: ignore
    class InvalidNodeAlias(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidNodeAlias({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidNodeAlias = InvalidNodeAlias # type: ignore
    class InvalidDateTime(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidDateTime({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidDateTime = InvalidDateTime # type: ignore
    class InvalidFeeRate(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidFeeRate({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidFeeRate = InvalidFeeRate # type: ignore
    class DuplicatePayment(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.DuplicatePayment({})".format(repr(str(self)))
    _UniffiTempNodeError.DuplicatePayment = DuplicatePayment # type: ignore
    class UnsupportedCurrency(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.UnsupportedCurrency({})".format(repr(str(self)))
    _UniffiTempNodeError.UnsupportedCurrency = UnsupportedCurrency # type: ignore
    class InsufficientFunds(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InsufficientFunds({})".format(repr(str(self)))
    _UniffiTempNodeError.InsufficientFunds = InsufficientFunds # type: ignore
    class LiquiditySourceUnavailable(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.LiquiditySourceUnavailable({})".format(repr(str(self)))
    _UniffiTempNodeError.LiquiditySourceUnavailable = LiquiditySourceUnavailable # type: ignore
    class LiquidityFeeTooHigh(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.LiquidityFeeTooHigh({})".format(repr(str(self)))
    _UniffiTempNodeError.LiquidityFeeTooHigh = LiquidityFeeTooHigh # type: ignore
    class InvalidBlindedPaths(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidBlindedPaths({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidBlindedPaths = InvalidBlindedPaths # type: ignore
    class AsyncPaymentServicesDisabled(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.AsyncPaymentServicesDisabled({})".format(repr(str(self)))
    _UniffiTempNodeError.AsyncPaymentServicesDisabled = AsyncPaymentServicesDisabled # type: ignore
    class CannotRbfFundingTransaction(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.CannotRbfFundingTransaction({})".format(repr(str(self)))
    _UniffiTempNodeError.CannotRbfFundingTransaction = CannotRbfFundingTransaction # type: ignore
    class TransactionNotFound(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.TransactionNotFound({})".format(repr(str(self)))
    _UniffiTempNodeError.TransactionNotFound = TransactionNotFound # type: ignore
    class TransactionAlreadyConfirmed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.TransactionAlreadyConfirmed({})".format(repr(str(self)))
    _UniffiTempNodeError.TransactionAlreadyConfirmed = TransactionAlreadyConfirmed # type: ignore
    class NoSpendableOutputs(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.NoSpendableOutputs({})".format(repr(str(self)))
    _UniffiTempNodeError.NoSpendableOutputs = NoSpendableOutputs # type: ignore
    class CoinSelectionFailed(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.CoinSelectionFailed({})".format(repr(str(self)))
    _UniffiTempNodeError.CoinSelectionFailed = CoinSelectionFailed # type: ignore
    class InvalidMnemonic(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.InvalidMnemonic({})".format(repr(str(self)))
    _UniffiTempNodeError.InvalidMnemonic = InvalidMnemonic # type: ignore
    class BackgroundSyncNotEnabled(_UniffiTempNodeError):

        def __repr__(self):
            return "NodeError.BackgroundSyncNotEnabled({})".format(repr(str(self)))
    _UniffiTempNodeError.BackgroundSyncNotEnabled = BackgroundSyncNotEnabled # type: ignore

NodeError = _UniffiTempNodeError # type: ignore
del _UniffiTempNodeError


class _UniffiConverterTypeNodeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NodeError.AlreadyRunning(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return NodeError.NotRunning(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return NodeError.OnchainTxCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return NodeError.ConnectionFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return NodeError.InvoiceCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return NodeError.InvoiceRequestCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return NodeError.OfferCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return NodeError.RefundCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return NodeError.PaymentSendingFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return NodeError.InvalidCustomTlvs(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return NodeError.ProbeSendingFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return NodeError.RouteNotFound(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return NodeError.ChannelCreationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return NodeError.ChannelClosingFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return NodeError.ChannelSplicingFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return NodeError.ChannelConfigUpdateFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return NodeError.PersistenceFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return NodeError.FeerateEstimationUpdateFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 19:
            return NodeError.FeerateEstimationUpdateTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return NodeError.WalletOperationFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return NodeError.WalletOperationTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return NodeError.OnchainTxSigningFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 23:
            return NodeError.TxSyncFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 24:
            return NodeError.TxSyncTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return NodeError.GossipUpdateFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 26:
            return NodeError.GossipUpdateTimeout(
                _UniffiConverterString.read(buf),
            )
        if variant == 27:
            return NodeError.LiquidityRequestFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 28:
            return NodeError.UriParameterParsingFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 29:
            return NodeError.InvalidAddress(
                _UniffiConverterString.read(buf),
            )
        if variant == 30:
            return NodeError.InvalidSocketAddress(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return NodeError.InvalidPublicKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 32:
            return NodeError.InvalidSecretKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 33:
            return NodeError.InvalidOfferId(
                _UniffiConverterString.read(buf),
            )
        if variant == 34:
            return NodeError.InvalidNodeId(
                _UniffiConverterString.read(buf),
            )
        if variant == 35:
            return NodeError.InvalidPaymentId(
                _UniffiConverterString.read(buf),
            )
        if variant == 36:
            return NodeError.InvalidPaymentHash(
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return NodeError.InvalidPaymentPreimage(
                _UniffiConverterString.read(buf),
            )
        if variant == 38:
            return NodeError.InvalidPaymentSecret(
                _UniffiConverterString.read(buf),
            )
        if variant == 39:
            return NodeError.InvalidAmount(
                _UniffiConverterString.read(buf),
            )
        if variant == 40:
            return NodeError.InvalidInvoice(
                _UniffiConverterString.read(buf),
            )
        if variant == 41:
            return NodeError.InvalidOffer(
                _UniffiConverterString.read(buf),
            )
        if variant == 42:
            return NodeError.InvalidRefund(
                _UniffiConverterString.read(buf),
            )
        if variant == 43:
            return NodeError.InvalidChannelId(
                _UniffiConverterString.read(buf),
            )
        if variant == 44:
            return NodeError.InvalidNetwork(
                _UniffiConverterString.read(buf),
            )
        if variant == 45:
            return NodeError.InvalidUri(
                _UniffiConverterString.read(buf),
            )
        if variant == 46:
            return NodeError.InvalidQuantity(
                _UniffiConverterString.read(buf),
            )
        if variant == 47:
            return NodeError.InvalidNodeAlias(
                _UniffiConverterString.read(buf),
            )
        if variant == 48:
            return NodeError.InvalidDateTime(
                _UniffiConverterString.read(buf),
            )
        if variant == 49:
            return NodeError.InvalidFeeRate(
                _UniffiConverterString.read(buf),
            )
        if variant == 50:
            return NodeError.DuplicatePayment(
                _UniffiConverterString.read(buf),
            )
        if variant == 51:
            return NodeError.UnsupportedCurrency(
                _UniffiConverterString.read(buf),
            )
        if variant == 52:
            return NodeError.InsufficientFunds(
                _UniffiConverterString.read(buf),
            )
        if variant == 53:
            return NodeError.LiquiditySourceUnavailable(
                _UniffiConverterString.read(buf),
            )
        if variant == 54:
            return NodeError.LiquidityFeeTooHigh(
                _UniffiConverterString.read(buf),
            )
        if variant == 55:
            return NodeError.InvalidBlindedPaths(
                _UniffiConverterString.read(buf),
            )
        if variant == 56:
            return NodeError.AsyncPaymentServicesDisabled(
                _UniffiConverterString.read(buf),
            )
        if variant == 57:
            return NodeError.CannotRbfFundingTransaction(
                _UniffiConverterString.read(buf),
            )
        if variant == 58:
            return NodeError.TransactionNotFound(
                _UniffiConverterString.read(buf),
            )
        if variant == 59:
            return NodeError.TransactionAlreadyConfirmed(
                _UniffiConverterString.read(buf),
            )
        if variant == 60:
            return NodeError.NoSpendableOutputs(
                _UniffiConverterString.read(buf),
            )
        if variant == 61:
            return NodeError.CoinSelectionFailed(
                _UniffiConverterString.read(buf),
            )
        if variant == 62:
            return NodeError.InvalidMnemonic(
                _UniffiConverterString.read(buf),
            )
        if variant == 63:
            return NodeError.BackgroundSyncNotEnabled(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, NodeError.AlreadyRunning):
            return
        if isinstance(value, NodeError.NotRunning):
            return
        if isinstance(value, NodeError.OnchainTxCreationFailed):
            return
        if isinstance(value, NodeError.ConnectionFailed):
            return
        if isinstance(value, NodeError.InvoiceCreationFailed):
            return
        if isinstance(value, NodeError.InvoiceRequestCreationFailed):
            return
        if isinstance(value, NodeError.OfferCreationFailed):
            return
        if isinstance(value, NodeError.RefundCreationFailed):
            return
        if isinstance(value, NodeError.PaymentSendingFailed):
            return
        if isinstance(value, NodeError.InvalidCustomTlvs):
            return
        if isinstance(value, NodeError.ProbeSendingFailed):
            return
        if isinstance(value, NodeError.RouteNotFound):
            return
        if isinstance(value, NodeError.ChannelCreationFailed):
            return
        if isinstance(value, NodeError.ChannelClosingFailed):
            return
        if isinstance(value, NodeError.ChannelSplicingFailed):
            return
        if isinstance(value, NodeError.ChannelConfigUpdateFailed):
            return
        if isinstance(value, NodeError.PersistenceFailed):
            return
        if isinstance(value, NodeError.FeerateEstimationUpdateFailed):
            return
        if isinstance(value, NodeError.FeerateEstimationUpdateTimeout):
            return
        if isinstance(value, NodeError.WalletOperationFailed):
            return
        if isinstance(value, NodeError.WalletOperationTimeout):
            return
        if isinstance(value, NodeError.OnchainTxSigningFailed):
            return
        if isinstance(value, NodeError.TxSyncFailed):
            return
        if isinstance(value, NodeError.TxSyncTimeout):
            return
        if isinstance(value, NodeError.GossipUpdateFailed):
            return
        if isinstance(value, NodeError.GossipUpdateTimeout):
            return
        if isinstance(value, NodeError.LiquidityRequestFailed):
            return
        if isinstance(value, NodeError.UriParameterParsingFailed):
            return
        if isinstance(value, NodeError.InvalidAddress):
            return
        if isinstance(value, NodeError.InvalidSocketAddress):
            return
        if isinstance(value, NodeError.InvalidPublicKey):
            return
        if isinstance(value, NodeError.InvalidSecretKey):
            return
        if isinstance(value, NodeError.InvalidOfferId):
            return
        if isinstance(value, NodeError.InvalidNodeId):
            return
        if isinstance(value, NodeError.InvalidPaymentId):
            return
        if isinstance(value, NodeError.InvalidPaymentHash):
            return
        if isinstance(value, NodeError.InvalidPaymentPreimage):
            return
        if isinstance(value, NodeError.InvalidPaymentSecret):
            return
        if isinstance(value, NodeError.InvalidAmount):
            return
        if isinstance(value, NodeError.InvalidInvoice):
            return
        if isinstance(value, NodeError.InvalidOffer):
            return
        if isinstance(value, NodeError.InvalidRefund):
            return
        if isinstance(value, NodeError.InvalidChannelId):
            return
        if isinstance(value, NodeError.InvalidNetwork):
            return
        if isinstance(value, NodeError.InvalidUri):
            return
        if isinstance(value, NodeError.InvalidQuantity):
            return
        if isinstance(value, NodeError.InvalidNodeAlias):
            return
        if isinstance(value, NodeError.InvalidDateTime):
            return
        if isinstance(value, NodeError.InvalidFeeRate):
            return
        if isinstance(value, NodeError.DuplicatePayment):
            return
        if isinstance(value, NodeError.UnsupportedCurrency):
            return
        if isinstance(value, NodeError.InsufficientFunds):
            return
        if isinstance(value, NodeError.LiquiditySourceUnavailable):
            return
        if isinstance(value, NodeError.LiquidityFeeTooHigh):
            return
        if isinstance(value, NodeError.InvalidBlindedPaths):
            return
        if isinstance(value, NodeError.AsyncPaymentServicesDisabled):
            return
        if isinstance(value, NodeError.CannotRbfFundingTransaction):
            return
        if isinstance(value, NodeError.TransactionNotFound):
            return
        if isinstance(value, NodeError.TransactionAlreadyConfirmed):
            return
        if isinstance(value, NodeError.NoSpendableOutputs):
            return
        if isinstance(value, NodeError.CoinSelectionFailed):
            return
        if isinstance(value, NodeError.InvalidMnemonic):
            return
        if isinstance(value, NodeError.BackgroundSyncNotEnabled):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, NodeError.AlreadyRunning):
            buf.write_i32(1)
        if isinstance(value, NodeError.NotRunning):
            buf.write_i32(2)
        if isinstance(value, NodeError.OnchainTxCreationFailed):
            buf.write_i32(3)
        if isinstance(value, NodeError.ConnectionFailed):
            buf.write_i32(4)
        if isinstance(value, NodeError.InvoiceCreationFailed):
            buf.write_i32(5)
        if isinstance(value, NodeError.InvoiceRequestCreationFailed):
            buf.write_i32(6)
        if isinstance(value, NodeError.OfferCreationFailed):
            buf.write_i32(7)
        if isinstance(value, NodeError.RefundCreationFailed):
            buf.write_i32(8)
        if isinstance(value, NodeError.PaymentSendingFailed):
            buf.write_i32(9)
        if isinstance(value, NodeError.InvalidCustomTlvs):
            buf.write_i32(10)
        if isinstance(value, NodeError.ProbeSendingFailed):
            buf.write_i32(11)
        if isinstance(value, NodeError.RouteNotFound):
            buf.write_i32(12)
        if isinstance(value, NodeError.ChannelCreationFailed):
            buf.write_i32(13)
        if isinstance(value, NodeError.ChannelClosingFailed):
            buf.write_i32(14)
        if isinstance(value, NodeError.ChannelSplicingFailed):
            buf.write_i32(15)
        if isinstance(value, NodeError.ChannelConfigUpdateFailed):
            buf.write_i32(16)
        if isinstance(value, NodeError.PersistenceFailed):
            buf.write_i32(17)
        if isinstance(value, NodeError.FeerateEstimationUpdateFailed):
            buf.write_i32(18)
        if isinstance(value, NodeError.FeerateEstimationUpdateTimeout):
            buf.write_i32(19)
        if isinstance(value, NodeError.WalletOperationFailed):
            buf.write_i32(20)
        if isinstance(value, NodeError.WalletOperationTimeout):
            buf.write_i32(21)
        if isinstance(value, NodeError.OnchainTxSigningFailed):
            buf.write_i32(22)
        if isinstance(value, NodeError.TxSyncFailed):
            buf.write_i32(23)
        if isinstance(value, NodeError.TxSyncTimeout):
            buf.write_i32(24)
        if isinstance(value, NodeError.GossipUpdateFailed):
            buf.write_i32(25)
        if isinstance(value, NodeError.GossipUpdateTimeout):
            buf.write_i32(26)
        if isinstance(value, NodeError.LiquidityRequestFailed):
            buf.write_i32(27)
        if isinstance(value, NodeError.UriParameterParsingFailed):
            buf.write_i32(28)
        if isinstance(value, NodeError.InvalidAddress):
            buf.write_i32(29)
        if isinstance(value, NodeError.InvalidSocketAddress):
            buf.write_i32(30)
        if isinstance(value, NodeError.InvalidPublicKey):
            buf.write_i32(31)
        if isinstance(value, NodeError.InvalidSecretKey):
            buf.write_i32(32)
        if isinstance(value, NodeError.InvalidOfferId):
            buf.write_i32(33)
        if isinstance(value, NodeError.InvalidNodeId):
            buf.write_i32(34)
        if isinstance(value, NodeError.InvalidPaymentId):
            buf.write_i32(35)
        if isinstance(value, NodeError.InvalidPaymentHash):
            buf.write_i32(36)
        if isinstance(value, NodeError.InvalidPaymentPreimage):
            buf.write_i32(37)
        if isinstance(value, NodeError.InvalidPaymentSecret):
            buf.write_i32(38)
        if isinstance(value, NodeError.InvalidAmount):
            buf.write_i32(39)
        if isinstance(value, NodeError.InvalidInvoice):
            buf.write_i32(40)
        if isinstance(value, NodeError.InvalidOffer):
            buf.write_i32(41)
        if isinstance(value, NodeError.InvalidRefund):
            buf.write_i32(42)
        if isinstance(value, NodeError.InvalidChannelId):
            buf.write_i32(43)
        if isinstance(value, NodeError.InvalidNetwork):
            buf.write_i32(44)
        if isinstance(value, NodeError.InvalidUri):
            buf.write_i32(45)
        if isinstance(value, NodeError.InvalidQuantity):
            buf.write_i32(46)
        if isinstance(value, NodeError.InvalidNodeAlias):
            buf.write_i32(47)
        if isinstance(value, NodeError.InvalidDateTime):
            buf.write_i32(48)
        if isinstance(value, NodeError.InvalidFeeRate):
            buf.write_i32(49)
        if isinstance(value, NodeError.DuplicatePayment):
            buf.write_i32(50)
        if isinstance(value, NodeError.UnsupportedCurrency):
            buf.write_i32(51)
        if isinstance(value, NodeError.InsufficientFunds):
            buf.write_i32(52)
        if isinstance(value, NodeError.LiquiditySourceUnavailable):
            buf.write_i32(53)
        if isinstance(value, NodeError.LiquidityFeeTooHigh):
            buf.write_i32(54)
        if isinstance(value, NodeError.InvalidBlindedPaths):
            buf.write_i32(55)
        if isinstance(value, NodeError.AsyncPaymentServicesDisabled):
            buf.write_i32(56)
        if isinstance(value, NodeError.CannotRbfFundingTransaction):
            buf.write_i32(57)
        if isinstance(value, NodeError.TransactionNotFound):
            buf.write_i32(58)
        if isinstance(value, NodeError.TransactionAlreadyConfirmed):
            buf.write_i32(59)
        if isinstance(value, NodeError.NoSpendableOutputs):
            buf.write_i32(60)
        if isinstance(value, NodeError.CoinSelectionFailed):
            buf.write_i32(61)
        if isinstance(value, NodeError.InvalidMnemonic):
            buf.write_i32(62)
        if isinstance(value, NodeError.BackgroundSyncNotEnabled):
            buf.write_i32(63)





class OfferAmount:
    def __init__(self):
        raise RuntimeError("OfferAmount cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BITCOIN:
        amount_msats: "int"

        def __init__(self,amount_msats: "int"):
            self.amount_msats = amount_msats

        def __str__(self):
            return "OfferAmount.BITCOIN(amount_msats={})".format(self.amount_msats)

        def __eq__(self, other):
            if not other.is_bitcoin():
                return False
            if self.amount_msats != other.amount_msats:
                return False
            return True
    
    class CURRENCY:
        iso4217_code: "str"
        amount: "int"

        def __init__(self,iso4217_code: "str", amount: "int"):
            self.iso4217_code = iso4217_code
            self.amount = amount

        def __str__(self):
            return "OfferAmount.CURRENCY(iso4217_code={}, amount={})".format(self.iso4217_code, self.amount)

        def __eq__(self, other):
            if not other.is_currency():
                return False
            if self.iso4217_code != other.iso4217_code:
                return False
            if self.amount != other.amount:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bitcoin(self) -> bool:
        return isinstance(self, OfferAmount.BITCOIN)
    def is_currency(self) -> bool:
        return isinstance(self, OfferAmount.CURRENCY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
OfferAmount.BITCOIN = type("OfferAmount.BITCOIN", (OfferAmount.BITCOIN, OfferAmount,), {})  # type: ignore
OfferAmount.CURRENCY = type("OfferAmount.CURRENCY", (OfferAmount.CURRENCY, OfferAmount,), {})  # type: ignore




class _UniffiConverterTypeOfferAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OfferAmount.BITCOIN(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return OfferAmount.CURRENCY(
                _UniffiConverterString.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_bitcoin():
            _UniffiConverterUInt64.check_lower(value.amount_msats)
            return
        if value.is_currency():
            _UniffiConverterString.check_lower(value.iso4217_code)
            _UniffiConverterUInt64.check_lower(value.amount)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_bitcoin():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.amount_msats, buf)
        if value.is_currency():
            buf.write_i32(2)
            _UniffiConverterString.write(value.iso4217_code, buf)
            _UniffiConverterUInt64.write(value.amount, buf)







class PaymentDirection(enum.Enum):
    INBOUND = 0
    
    OUTBOUND = 1
    


class _UniffiConverterTypePaymentDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentDirection.INBOUND
        if variant == 2:
            return PaymentDirection.OUTBOUND
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentDirection.INBOUND:
            return
        if value == PaymentDirection.OUTBOUND:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentDirection.INBOUND:
            buf.write_i32(1)
        if value == PaymentDirection.OUTBOUND:
            buf.write_i32(2)







class PaymentFailureReason(enum.Enum):
    RECIPIENT_REJECTED = 0
    
    USER_ABANDONED = 1
    
    RETRIES_EXHAUSTED = 2
    
    PAYMENT_EXPIRED = 3
    
    ROUTE_NOT_FOUND = 4
    
    UNEXPECTED_ERROR = 5
    
    UNKNOWN_REQUIRED_FEATURES = 6
    
    INVOICE_REQUEST_EXPIRED = 7
    
    INVOICE_REQUEST_REJECTED = 8
    
    BLINDED_PATH_CREATION_FAILED = 9
    


class _UniffiConverterTypePaymentFailureReason(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentFailureReason.RECIPIENT_REJECTED
        if variant == 2:
            return PaymentFailureReason.USER_ABANDONED
        if variant == 3:
            return PaymentFailureReason.RETRIES_EXHAUSTED
        if variant == 4:
            return PaymentFailureReason.PAYMENT_EXPIRED
        if variant == 5:
            return PaymentFailureReason.ROUTE_NOT_FOUND
        if variant == 6:
            return PaymentFailureReason.UNEXPECTED_ERROR
        if variant == 7:
            return PaymentFailureReason.UNKNOWN_REQUIRED_FEATURES
        if variant == 8:
            return PaymentFailureReason.INVOICE_REQUEST_EXPIRED
        if variant == 9:
            return PaymentFailureReason.INVOICE_REQUEST_REJECTED
        if variant == 10:
            return PaymentFailureReason.BLINDED_PATH_CREATION_FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentFailureReason.RECIPIENT_REJECTED:
            return
        if value == PaymentFailureReason.USER_ABANDONED:
            return
        if value == PaymentFailureReason.RETRIES_EXHAUSTED:
            return
        if value == PaymentFailureReason.PAYMENT_EXPIRED:
            return
        if value == PaymentFailureReason.ROUTE_NOT_FOUND:
            return
        if value == PaymentFailureReason.UNEXPECTED_ERROR:
            return
        if value == PaymentFailureReason.UNKNOWN_REQUIRED_FEATURES:
            return
        if value == PaymentFailureReason.INVOICE_REQUEST_EXPIRED:
            return
        if value == PaymentFailureReason.INVOICE_REQUEST_REJECTED:
            return
        if value == PaymentFailureReason.BLINDED_PATH_CREATION_FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentFailureReason.RECIPIENT_REJECTED:
            buf.write_i32(1)
        if value == PaymentFailureReason.USER_ABANDONED:
            buf.write_i32(2)
        if value == PaymentFailureReason.RETRIES_EXHAUSTED:
            buf.write_i32(3)
        if value == PaymentFailureReason.PAYMENT_EXPIRED:
            buf.write_i32(4)
        if value == PaymentFailureReason.ROUTE_NOT_FOUND:
            buf.write_i32(5)
        if value == PaymentFailureReason.UNEXPECTED_ERROR:
            buf.write_i32(6)
        if value == PaymentFailureReason.UNKNOWN_REQUIRED_FEATURES:
            buf.write_i32(7)
        if value == PaymentFailureReason.INVOICE_REQUEST_EXPIRED:
            buf.write_i32(8)
        if value == PaymentFailureReason.INVOICE_REQUEST_REJECTED:
            buf.write_i32(9)
        if value == PaymentFailureReason.BLINDED_PATH_CREATION_FAILED:
            buf.write_i32(10)







class PaymentKind:
    def __init__(self):
        raise RuntimeError("PaymentKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONCHAIN:
        txid: "Txid"
        status: "ConfirmationStatus"

        def __init__(self,txid: "Txid", status: "ConfirmationStatus"):
            self.txid = txid
            self.status = status

        def __str__(self):
            return "PaymentKind.ONCHAIN(txid={}, status={})".format(self.txid, self.status)

        def __eq__(self, other):
            if not other.is_onchain():
                return False
            if self.txid != other.txid:
                return False
            if self.status != other.status:
                return False
            return True
    
    class BOLT11:
        hash: "PaymentHash"
        preimage: "typing.Optional[PaymentPreimage]"
        secret: "typing.Optional[PaymentSecret]"
        description: "typing.Optional[str]"
        bolt11: "typing.Optional[str]"

        def __init__(self,hash: "PaymentHash", preimage: "typing.Optional[PaymentPreimage]", secret: "typing.Optional[PaymentSecret]", description: "typing.Optional[str]", bolt11: "typing.Optional[str]"):
            self.hash = hash
            self.preimage = preimage
            self.secret = secret
            self.description = description
            self.bolt11 = bolt11

        def __str__(self):
            return "PaymentKind.BOLT11(hash={}, preimage={}, secret={}, description={}, bolt11={})".format(self.hash, self.preimage, self.secret, self.description, self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.hash != other.hash:
                return False
            if self.preimage != other.preimage:
                return False
            if self.secret != other.secret:
                return False
            if self.description != other.description:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    
    class BOLT11_JIT:
        hash: "PaymentHash"
        preimage: "typing.Optional[PaymentPreimage]"
        secret: "typing.Optional[PaymentSecret]"
        counterparty_skimmed_fee_msat: "typing.Optional[int]"
        lsp_fee_limits: "LspFeeLimits"
        description: "typing.Optional[str]"
        bolt11: "typing.Optional[str]"

        def __init__(self,hash: "PaymentHash", preimage: "typing.Optional[PaymentPreimage]", secret: "typing.Optional[PaymentSecret]", counterparty_skimmed_fee_msat: "typing.Optional[int]", lsp_fee_limits: "LspFeeLimits", description: "typing.Optional[str]", bolt11: "typing.Optional[str]"):
            self.hash = hash
            self.preimage = preimage
            self.secret = secret
            self.counterparty_skimmed_fee_msat = counterparty_skimmed_fee_msat
            self.lsp_fee_limits = lsp_fee_limits
            self.description = description
            self.bolt11 = bolt11

        def __str__(self):
            return "PaymentKind.BOLT11_JIT(hash={}, preimage={}, secret={}, counterparty_skimmed_fee_msat={}, lsp_fee_limits={}, description={}, bolt11={})".format(self.hash, self.preimage, self.secret, self.counterparty_skimmed_fee_msat, self.lsp_fee_limits, self.description, self.bolt11)

        def __eq__(self, other):
            if not other.is_bolt11_jit():
                return False
            if self.hash != other.hash:
                return False
            if self.preimage != other.preimage:
                return False
            if self.secret != other.secret:
                return False
            if self.counterparty_skimmed_fee_msat != other.counterparty_skimmed_fee_msat:
                return False
            if self.lsp_fee_limits != other.lsp_fee_limits:
                return False
            if self.description != other.description:
                return False
            if self.bolt11 != other.bolt11:
                return False
            return True
    
    class BOLT12_OFFER:
        hash: "typing.Optional[PaymentHash]"
        preimage: "typing.Optional[PaymentPreimage]"
        secret: "typing.Optional[PaymentSecret]"
        offer_id: "OfferId"
        payer_note: "typing.Optional[UntrustedString]"
        quantity: "typing.Optional[int]"

        def __init__(self,hash: "typing.Optional[PaymentHash]", preimage: "typing.Optional[PaymentPreimage]", secret: "typing.Optional[PaymentSecret]", offer_id: "OfferId", payer_note: "typing.Optional[UntrustedString]", quantity: "typing.Optional[int]"):
            self.hash = hash
            self.preimage = preimage
            self.secret = secret
            self.offer_id = offer_id
            self.payer_note = payer_note
            self.quantity = quantity

        def __str__(self):
            return "PaymentKind.BOLT12_OFFER(hash={}, preimage={}, secret={}, offer_id={}, payer_note={}, quantity={})".format(self.hash, self.preimage, self.secret, self.offer_id, self.payer_note, self.quantity)

        def __eq__(self, other):
            if not other.is_bolt12_offer():
                return False
            if self.hash != other.hash:
                return False
            if self.preimage != other.preimage:
                return False
            if self.secret != other.secret:
                return False
            if self.offer_id != other.offer_id:
                return False
            if self.payer_note != other.payer_note:
                return False
            if self.quantity != other.quantity:
                return False
            return True
    
    class BOLT12_REFUND:
        hash: "typing.Optional[PaymentHash]"
        preimage: "typing.Optional[PaymentPreimage]"
        secret: "typing.Optional[PaymentSecret]"
        payer_note: "typing.Optional[UntrustedString]"
        quantity: "typing.Optional[int]"

        def __init__(self,hash: "typing.Optional[PaymentHash]", preimage: "typing.Optional[PaymentPreimage]", secret: "typing.Optional[PaymentSecret]", payer_note: "typing.Optional[UntrustedString]", quantity: "typing.Optional[int]"):
            self.hash = hash
            self.preimage = preimage
            self.secret = secret
            self.payer_note = payer_note
            self.quantity = quantity

        def __str__(self):
            return "PaymentKind.BOLT12_REFUND(hash={}, preimage={}, secret={}, payer_note={}, quantity={})".format(self.hash, self.preimage, self.secret, self.payer_note, self.quantity)

        def __eq__(self, other):
            if not other.is_bolt12_refund():
                return False
            if self.hash != other.hash:
                return False
            if self.preimage != other.preimage:
                return False
            if self.secret != other.secret:
                return False
            if self.payer_note != other.payer_note:
                return False
            if self.quantity != other.quantity:
                return False
            return True
    
    class SPONTANEOUS:
        hash: "PaymentHash"
        preimage: "typing.Optional[PaymentPreimage]"

        def __init__(self,hash: "PaymentHash", preimage: "typing.Optional[PaymentPreimage]"):
            self.hash = hash
            self.preimage = preimage

        def __str__(self):
            return "PaymentKind.SPONTANEOUS(hash={}, preimage={})".format(self.hash, self.preimage)

        def __eq__(self, other):
            if not other.is_spontaneous():
                return False
            if self.hash != other.hash:
                return False
            if self.preimage != other.preimage:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_onchain(self) -> bool:
        return isinstance(self, PaymentKind.ONCHAIN)
    def is_bolt11(self) -> bool:
        return isinstance(self, PaymentKind.BOLT11)
    def is_bolt11_jit(self) -> bool:
        return isinstance(self, PaymentKind.BOLT11_JIT)
    def is_bolt12_offer(self) -> bool:
        return isinstance(self, PaymentKind.BOLT12_OFFER)
    def is_bolt12_refund(self) -> bool:
        return isinstance(self, PaymentKind.BOLT12_REFUND)
    def is_spontaneous(self) -> bool:
        return isinstance(self, PaymentKind.SPONTANEOUS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PaymentKind.ONCHAIN = type("PaymentKind.ONCHAIN", (PaymentKind.ONCHAIN, PaymentKind,), {})  # type: ignore
PaymentKind.BOLT11 = type("PaymentKind.BOLT11", (PaymentKind.BOLT11, PaymentKind,), {})  # type: ignore
PaymentKind.BOLT11_JIT = type("PaymentKind.BOLT11_JIT", (PaymentKind.BOLT11_JIT, PaymentKind,), {})  # type: ignore
PaymentKind.BOLT12_OFFER = type("PaymentKind.BOLT12_OFFER", (PaymentKind.BOLT12_OFFER, PaymentKind,), {})  # type: ignore
PaymentKind.BOLT12_REFUND = type("PaymentKind.BOLT12_REFUND", (PaymentKind.BOLT12_REFUND, PaymentKind,), {})  # type: ignore
PaymentKind.SPONTANEOUS = type("PaymentKind.SPONTANEOUS", (PaymentKind.SPONTANEOUS, PaymentKind,), {})  # type: ignore




class _UniffiConverterTypePaymentKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentKind.ONCHAIN(
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterTypeConfirmationStatus.read(buf),
            )
        if variant == 2:
            return PaymentKind.BOLT11(
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
                _UniffiConverterOptionalTypePaymentSecret.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 3:
            return PaymentKind.BOLT11_JIT(
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
                _UniffiConverterOptionalTypePaymentSecret.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
                _UniffiConverterTypeLspFeeLimits.read(buf),
                _UniffiConverterOptionalString.read(buf),
                _UniffiConverterOptionalString.read(buf),
            )
        if variant == 4:
            return PaymentKind.BOLT12_OFFER(
                _UniffiConverterOptionalTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
                _UniffiConverterOptionalTypePaymentSecret.read(buf),
                _UniffiConverterTypeOfferId.read(buf),
                _UniffiConverterOptionalTypeUntrustedString.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
            )
        if variant == 5:
            return PaymentKind.BOLT12_REFUND(
                _UniffiConverterOptionalTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
                _UniffiConverterOptionalTypePaymentSecret.read(buf),
                _UniffiConverterOptionalTypeUntrustedString.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
            )
        if variant == 6:
            return PaymentKind.SPONTANEOUS(
                _UniffiConverterTypePaymentHash.read(buf),
                _UniffiConverterOptionalTypePaymentPreimage.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_onchain():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            _UniffiConverterTypeConfirmationStatus.check_lower(value.status)
            return
        if value.is_bolt11():
            _UniffiConverterTypePaymentHash.check_lower(value.hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.preimage)
            _UniffiConverterOptionalTypePaymentSecret.check_lower(value.secret)
            _UniffiConverterOptionalString.check_lower(value.description)
            _UniffiConverterOptionalString.check_lower(value.bolt11)
            return
        if value.is_bolt11_jit():
            _UniffiConverterTypePaymentHash.check_lower(value.hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.preimage)
            _UniffiConverterOptionalTypePaymentSecret.check_lower(value.secret)
            _UniffiConverterOptionalUInt64.check_lower(value.counterparty_skimmed_fee_msat)
            _UniffiConverterTypeLspFeeLimits.check_lower(value.lsp_fee_limits)
            _UniffiConverterOptionalString.check_lower(value.description)
            _UniffiConverterOptionalString.check_lower(value.bolt11)
            return
        if value.is_bolt12_offer():
            _UniffiConverterOptionalTypePaymentHash.check_lower(value.hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.preimage)
            _UniffiConverterOptionalTypePaymentSecret.check_lower(value.secret)
            _UniffiConverterTypeOfferId.check_lower(value.offer_id)
            _UniffiConverterOptionalTypeUntrustedString.check_lower(value.payer_note)
            _UniffiConverterOptionalUInt64.check_lower(value.quantity)
            return
        if value.is_bolt12_refund():
            _UniffiConverterOptionalTypePaymentHash.check_lower(value.hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.preimage)
            _UniffiConverterOptionalTypePaymentSecret.check_lower(value.secret)
            _UniffiConverterOptionalTypeUntrustedString.check_lower(value.payer_note)
            _UniffiConverterOptionalUInt64.check_lower(value.quantity)
            return
        if value.is_spontaneous():
            _UniffiConverterTypePaymentHash.check_lower(value.hash)
            _UniffiConverterOptionalTypePaymentPreimage.check_lower(value.preimage)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_onchain():
            buf.write_i32(1)
            _UniffiConverterTypeTxid.write(value.txid, buf)
            _UniffiConverterTypeConfirmationStatus.write(value.status, buf)
        if value.is_bolt11():
            buf.write_i32(2)
            _UniffiConverterTypePaymentHash.write(value.hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)
            _UniffiConverterOptionalTypePaymentSecret.write(value.secret, buf)
            _UniffiConverterOptionalString.write(value.description, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_bolt11_jit():
            buf.write_i32(3)
            _UniffiConverterTypePaymentHash.write(value.hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)
            _UniffiConverterOptionalTypePaymentSecret.write(value.secret, buf)
            _UniffiConverterOptionalUInt64.write(value.counterparty_skimmed_fee_msat, buf)
            _UniffiConverterTypeLspFeeLimits.write(value.lsp_fee_limits, buf)
            _UniffiConverterOptionalString.write(value.description, buf)
            _UniffiConverterOptionalString.write(value.bolt11, buf)
        if value.is_bolt12_offer():
            buf.write_i32(4)
            _UniffiConverterOptionalTypePaymentHash.write(value.hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)
            _UniffiConverterOptionalTypePaymentSecret.write(value.secret, buf)
            _UniffiConverterTypeOfferId.write(value.offer_id, buf)
            _UniffiConverterOptionalTypeUntrustedString.write(value.payer_note, buf)
            _UniffiConverterOptionalUInt64.write(value.quantity, buf)
        if value.is_bolt12_refund():
            buf.write_i32(5)
            _UniffiConverterOptionalTypePaymentHash.write(value.hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)
            _UniffiConverterOptionalTypePaymentSecret.write(value.secret, buf)
            _UniffiConverterOptionalTypeUntrustedString.write(value.payer_note, buf)
            _UniffiConverterOptionalUInt64.write(value.quantity, buf)
        if value.is_spontaneous():
            buf.write_i32(6)
            _UniffiConverterTypePaymentHash.write(value.hash, buf)
            _UniffiConverterOptionalTypePaymentPreimage.write(value.preimage, buf)







class PaymentStatus(enum.Enum):
    PENDING = 0
    
    SUCCEEDED = 1
    
    FAILED = 2
    


class _UniffiConverterTypePaymentStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PaymentStatus.PENDING
        if variant == 2:
            return PaymentStatus.SUCCEEDED
        if variant == 3:
            return PaymentStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PaymentStatus.PENDING:
            return
        if value == PaymentStatus.SUCCEEDED:
            return
        if value == PaymentStatus.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PaymentStatus.PENDING:
            buf.write_i32(1)
        if value == PaymentStatus.SUCCEEDED:
            buf.write_i32(2)
        if value == PaymentStatus.FAILED:
            buf.write_i32(3)







class PendingSweepBalance:
    def __init__(self):
        raise RuntimeError("PendingSweepBalance cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class PENDING_BROADCAST:
        channel_id: "typing.Optional[ChannelId]"
        amount_satoshis: "int"

        def __init__(self,channel_id: "typing.Optional[ChannelId]", amount_satoshis: "int"):
            self.channel_id = channel_id
            self.amount_satoshis = amount_satoshis

        def __str__(self):
            return "PendingSweepBalance.PENDING_BROADCAST(channel_id={}, amount_satoshis={})".format(self.channel_id, self.amount_satoshis)

        def __eq__(self, other):
            if not other.is_pending_broadcast():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            return True
    
    class BROADCAST_AWAITING_CONFIRMATION:
        channel_id: "typing.Optional[ChannelId]"
        latest_broadcast_height: "int"
        latest_spending_txid: "Txid"
        amount_satoshis: "int"

        def __init__(self,channel_id: "typing.Optional[ChannelId]", latest_broadcast_height: "int", latest_spending_txid: "Txid", amount_satoshis: "int"):
            self.channel_id = channel_id
            self.latest_broadcast_height = latest_broadcast_height
            self.latest_spending_txid = latest_spending_txid
            self.amount_satoshis = amount_satoshis

        def __str__(self):
            return "PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION(channel_id={}, latest_broadcast_height={}, latest_spending_txid={}, amount_satoshis={})".format(self.channel_id, self.latest_broadcast_height, self.latest_spending_txid, self.amount_satoshis)

        def __eq__(self, other):
            if not other.is_broadcast_awaiting_confirmation():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.latest_broadcast_height != other.latest_broadcast_height:
                return False
            if self.latest_spending_txid != other.latest_spending_txid:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            return True
    
    class AWAITING_THRESHOLD_CONFIRMATIONS:
        channel_id: "typing.Optional[ChannelId]"
        latest_spending_txid: "Txid"
        confirmation_hash: "BlockHash"
        confirmation_height: "int"
        amount_satoshis: "int"

        def __init__(self,channel_id: "typing.Optional[ChannelId]", latest_spending_txid: "Txid", confirmation_hash: "BlockHash", confirmation_height: "int", amount_satoshis: "int"):
            self.channel_id = channel_id
            self.latest_spending_txid = latest_spending_txid
            self.confirmation_hash = confirmation_hash
            self.confirmation_height = confirmation_height
            self.amount_satoshis = amount_satoshis

        def __str__(self):
            return "PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS(channel_id={}, latest_spending_txid={}, confirmation_hash={}, confirmation_height={}, amount_satoshis={})".format(self.channel_id, self.latest_spending_txid, self.confirmation_hash, self.confirmation_height, self.amount_satoshis)

        def __eq__(self, other):
            if not other.is_awaiting_threshold_confirmations():
                return False
            if self.channel_id != other.channel_id:
                return False
            if self.latest_spending_txid != other.latest_spending_txid:
                return False
            if self.confirmation_hash != other.confirmation_hash:
                return False
            if self.confirmation_height != other.confirmation_height:
                return False
            if self.amount_satoshis != other.amount_satoshis:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_pending_broadcast(self) -> bool:
        return isinstance(self, PendingSweepBalance.PENDING_BROADCAST)
    def is_broadcast_awaiting_confirmation(self) -> bool:
        return isinstance(self, PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION)
    def is_awaiting_threshold_confirmations(self) -> bool:
        return isinstance(self, PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PendingSweepBalance.PENDING_BROADCAST = type("PendingSweepBalance.PENDING_BROADCAST", (PendingSweepBalance.PENDING_BROADCAST, PendingSweepBalance,), {})  # type: ignore
PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION = type("PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION", (PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION, PendingSweepBalance,), {})  # type: ignore
PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS = type("PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS", (PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS, PendingSweepBalance,), {})  # type: ignore




class _UniffiConverterTypePendingSweepBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PendingSweepBalance.PENDING_BROADCAST(
                _UniffiConverterOptionalTypeChannelId.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return PendingSweepBalance.BROADCAST_AWAITING_CONFIRMATION(
                _UniffiConverterOptionalTypeChannelId.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return PendingSweepBalance.AWAITING_THRESHOLD_CONFIRMATIONS(
                _UniffiConverterOptionalTypeChannelId.read(buf),
                _UniffiConverterTypeTxid.read(buf),
                _UniffiConverterTypeBlockHash.read(buf),
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_pending_broadcast():
            _UniffiConverterOptionalTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            return
        if value.is_broadcast_awaiting_confirmation():
            _UniffiConverterOptionalTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterUInt32.check_lower(value.latest_broadcast_height)
            _UniffiConverterTypeTxid.check_lower(value.latest_spending_txid)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            return
        if value.is_awaiting_threshold_confirmations():
            _UniffiConverterOptionalTypeChannelId.check_lower(value.channel_id)
            _UniffiConverterTypeTxid.check_lower(value.latest_spending_txid)
            _UniffiConverterTypeBlockHash.check_lower(value.confirmation_hash)
            _UniffiConverterUInt32.check_lower(value.confirmation_height)
            _UniffiConverterUInt64.check_lower(value.amount_satoshis)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_pending_broadcast():
            buf.write_i32(1)
            _UniffiConverterOptionalTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
        if value.is_broadcast_awaiting_confirmation():
            buf.write_i32(2)
            _UniffiConverterOptionalTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterUInt32.write(value.latest_broadcast_height, buf)
            _UniffiConverterTypeTxid.write(value.latest_spending_txid, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)
        if value.is_awaiting_threshold_confirmations():
            buf.write_i32(3)
            _UniffiConverterOptionalTypeChannelId.write(value.channel_id, buf)
            _UniffiConverterTypeTxid.write(value.latest_spending_txid, buf)
            _UniffiConverterTypeBlockHash.write(value.confirmation_hash, buf)
            _UniffiConverterUInt32.write(value.confirmation_height, buf)
            _UniffiConverterUInt64.write(value.amount_satoshis, buf)







class QrPaymentResult:
    def __init__(self):
        raise RuntimeError("QrPaymentResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ONCHAIN:
        txid: "Txid"

        def __init__(self,txid: "Txid"):
            self.txid = txid

        def __str__(self):
            return "QrPaymentResult.ONCHAIN(txid={})".format(self.txid)

        def __eq__(self, other):
            if not other.is_onchain():
                return False
            if self.txid != other.txid:
                return False
            return True
    
    class BOLT11:
        payment_id: "PaymentId"

        def __init__(self,payment_id: "PaymentId"):
            self.payment_id = payment_id

        def __str__(self):
            return "QrPaymentResult.BOLT11(payment_id={})".format(self.payment_id)

        def __eq__(self, other):
            if not other.is_bolt11():
                return False
            if self.payment_id != other.payment_id:
                return False
            return True
    
    class BOLT12:
        payment_id: "PaymentId"

        def __init__(self,payment_id: "PaymentId"):
            self.payment_id = payment_id

        def __str__(self):
            return "QrPaymentResult.BOLT12(payment_id={})".format(self.payment_id)

        def __eq__(self, other):
            if not other.is_bolt12():
                return False
            if self.payment_id != other.payment_id:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_onchain(self) -> bool:
        return isinstance(self, QrPaymentResult.ONCHAIN)
    def is_bolt11(self) -> bool:
        return isinstance(self, QrPaymentResult.BOLT11)
    def is_bolt12(self) -> bool:
        return isinstance(self, QrPaymentResult.BOLT12)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
QrPaymentResult.ONCHAIN = type("QrPaymentResult.ONCHAIN", (QrPaymentResult.ONCHAIN, QrPaymentResult,), {})  # type: ignore
QrPaymentResult.BOLT11 = type("QrPaymentResult.BOLT11", (QrPaymentResult.BOLT11, QrPaymentResult,), {})  # type: ignore
QrPaymentResult.BOLT12 = type("QrPaymentResult.BOLT12", (QrPaymentResult.BOLT12, QrPaymentResult,), {})  # type: ignore




class _UniffiConverterTypeQrPaymentResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return QrPaymentResult.ONCHAIN(
                _UniffiConverterTypeTxid.read(buf),
            )
        if variant == 2:
            return QrPaymentResult.BOLT11(
                _UniffiConverterTypePaymentId.read(buf),
            )
        if variant == 3:
            return QrPaymentResult.BOLT12(
                _UniffiConverterTypePaymentId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_onchain():
            _UniffiConverterTypeTxid.check_lower(value.txid)
            return
        if value.is_bolt11():
            _UniffiConverterTypePaymentId.check_lower(value.payment_id)
            return
        if value.is_bolt12():
            _UniffiConverterTypePaymentId.check_lower(value.payment_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_onchain():
            buf.write_i32(1)
            _UniffiConverterTypeTxid.write(value.txid, buf)
        if value.is_bolt11():
            buf.write_i32(2)
            _UniffiConverterTypePaymentId.write(value.payment_id, buf)
        if value.is_bolt12():
            buf.write_i32(3)
            _UniffiConverterTypePaymentId.write(value.payment_id, buf)







class SyncType(enum.Enum):
    ONCHAIN_WALLET = 0
    
    LIGHTNING_WALLET = 1
    
    FEE_RATE_CACHE = 2
    


class _UniffiConverterTypeSyncType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SyncType.ONCHAIN_WALLET
        if variant == 2:
            return SyncType.LIGHTNING_WALLET
        if variant == 3:
            return SyncType.FEE_RATE_CACHE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SyncType.ONCHAIN_WALLET:
            return
        if value == SyncType.LIGHTNING_WALLET:
            return
        if value == SyncType.FEE_RATE_CACHE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SyncType.ONCHAIN_WALLET:
            buf.write_i32(1)
        if value == SyncType.LIGHTNING_WALLET:
            buf.write_i32(2)
        if value == SyncType.FEE_RATE_CACHE:
            buf.write_i32(3)




# VssHeaderProviderError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class VssHeaderProviderError(Exception):
    pass

_UniffiTempVssHeaderProviderError = VssHeaderProviderError

class VssHeaderProviderError:  # type: ignore
    class InvalidData(_UniffiTempVssHeaderProviderError):

        def __repr__(self):
            return "VssHeaderProviderError.InvalidData({})".format(repr(str(self)))
    _UniffiTempVssHeaderProviderError.InvalidData = InvalidData # type: ignore
    class RequestError(_UniffiTempVssHeaderProviderError):

        def __repr__(self):
            return "VssHeaderProviderError.RequestError({})".format(repr(str(self)))
    _UniffiTempVssHeaderProviderError.RequestError = RequestError # type: ignore
    class AuthorizationError(_UniffiTempVssHeaderProviderError):

        def __repr__(self):
            return "VssHeaderProviderError.AuthorizationError({})".format(repr(str(self)))
    _UniffiTempVssHeaderProviderError.AuthorizationError = AuthorizationError # type: ignore
    class InternalError(_UniffiTempVssHeaderProviderError):

        def __repr__(self):
            return "VssHeaderProviderError.InternalError({})".format(repr(str(self)))
    _UniffiTempVssHeaderProviderError.InternalError = InternalError # type: ignore

VssHeaderProviderError = _UniffiTempVssHeaderProviderError # type: ignore
del _UniffiTempVssHeaderProviderError


class _UniffiConverterTypeVssHeaderProviderError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return VssHeaderProviderError.InvalidData(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return VssHeaderProviderError.RequestError(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return VssHeaderProviderError.AuthorizationError(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return VssHeaderProviderError.InternalError(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, VssHeaderProviderError.InvalidData):
            return
        if isinstance(value, VssHeaderProviderError.RequestError):
            return
        if isinstance(value, VssHeaderProviderError.AuthorizationError):
            return
        if isinstance(value, VssHeaderProviderError.InternalError):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, VssHeaderProviderError.InvalidData):
            buf.write_i32(1)
        if isinstance(value, VssHeaderProviderError.RequestError):
            buf.write_i32(2)
        if isinstance(value, VssHeaderProviderError.AuthorizationError):
            buf.write_i32(3)
        if isinstance(value, VssHeaderProviderError.InternalError):
            buf.write_i32(4)





class WordCount(enum.Enum):
    WORDS12 = 0
    
    WORDS15 = 1
    
    WORDS18 = 2
    
    WORDS21 = 3
    
    WORDS24 = 4
    


class _UniffiConverterTypeWordCount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WordCount.WORDS12
        if variant == 2:
            return WordCount.WORDS15
        if variant == 3:
            return WordCount.WORDS18
        if variant == 4:
            return WordCount.WORDS21
        if variant == 5:
            return WordCount.WORDS24
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WordCount.WORDS12:
            return
        if value == WordCount.WORDS15:
            return
        if value == WordCount.WORDS18:
            return
        if value == WordCount.WORDS21:
            return
        if value == WordCount.WORDS24:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == WordCount.WORDS12:
            buf.write_i32(1)
        if value == WordCount.WORDS15:
            buf.write_i32(2)
        if value == WordCount.WORDS18:
            buf.write_i32(3)
        if value == WordCount.WORDS21:
            buf.write_i32(4)
        if value == WordCount.WORDS24:
            buf.write_i32(5)





class _UniffiConverterOptionalUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt16.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt16.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt16.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFeeRate(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFeeRate.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFeeRate.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFeeRate.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAnchorChannelsConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAnchorChannelsConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAnchorChannelsConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAnchorChannelsConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBackgroundSyncConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBackgroundSyncConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBackgroundSyncConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBackgroundSyncConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeChannelConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeChannelConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeChannelConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeChannelConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeChannelInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeChannelInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeChannelInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeChannelInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeChannelUpdateInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeChannelUpdateInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeChannelUpdateInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeChannelUpdateInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeElectrumSyncConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeElectrumSyncConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeElectrumSyncConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeElectrumSyncConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEsploraSyncConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEsploraSyncConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEsploraSyncConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEsploraSyncConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLsps1Bolt11PaymentInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLsps1Bolt11PaymentInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLsps1Bolt11PaymentInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLsps1Bolt11PaymentInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLsps1ChannelInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLsps1ChannelInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLsps1ChannelInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLsps1ChannelInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLsps1OnchainPaymentInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLsps1OnchainPaymentInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLsps1OnchainPaymentInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLsps1OnchainPaymentInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeAnnouncementInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeAnnouncementInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeAnnouncementInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeAnnouncementInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeInfo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOutPoint.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOutPoint.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOutPoint.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentDetails.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeRouteParametersConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeRouteParametersConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeRouteParametersConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeRouteParametersConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionDetails.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionDetails.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionDetails.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAsyncPaymentsRole(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAsyncPaymentsRole.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAsyncPaymentsRole.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAsyncPaymentsRole.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeClosureReason(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeClosureReason.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeClosureReason.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeClosureReason.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEvent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLogLevel(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLogLevel.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLogLevel.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLogLevel.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNetwork(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNetwork.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNetwork.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNetwork.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOfferAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOfferAmount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOfferAmount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOfferAmount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentFailureReason(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentFailureReason.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentFailureReason.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentFailureReason.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWordCount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWordCount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWordCount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWordCount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSpendableUtxo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSpendableUtxo.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSpendableUtxo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSpendableUtxo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceSequenceUInt8.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSocketAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSocketAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSocketAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSocketAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeChannelId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeChannelId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeChannelId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeChannelId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeAlias(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeAlias.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeAlias.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeAlias.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentHash(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentHash.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentHash.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentHash.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentPreimage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentPreimage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentPreimage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentPreimage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaymentSecret(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaymentSecret.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaymentSecret.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaymentSecret.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUntrustedString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeUntrustedString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUntrustedString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUntrustedString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUserChannelId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeUserChannelId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUserChannelId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUserChannelId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeChannelDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeChannelDetails.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeChannelDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeChannelDetails.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCustomTlvRecord(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCustomTlvRecord.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCustomTlvRecord.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCustomTlvRecord.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePaymentDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePaymentDetails.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePaymentDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePaymentDetails.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePeerDetails(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePeerDetails.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePeerDetails.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePeerDetails.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeRouteHintHop(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeRouteHintHop.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeRouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeRouteHintHop.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSpendableUtxo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSpendableUtxo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSpendableUtxo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSpendableUtxo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxInput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxInput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxInput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxInput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLightningBalance(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLightningBalance.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLightningBalance.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLightningBalance.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNetwork(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNetwork.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNetwork.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNetwork.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePendingSweepBalance(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePendingSweepBalance.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePendingSweepBalance.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePendingSweepBalance.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceTypeRouteHintHop(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceTypeRouteHintHop.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceTypeRouteHintHop.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceTypeRouteHintHop.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNodeId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNodeId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNodeId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNodeId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePublicKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePublicKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePublicKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSocketAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSocketAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSocketAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSocketAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxid(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxid.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxid.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxid.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterString.read(buf)
            d[key] = val
        return d


class _UniffiConverterTypeAddress:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeBlockHash:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeChannelId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeLsps1OrderId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeLspsDateTime:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeMnemonic:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeNodeAlias:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeNodeId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeOfferId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypePaymentHash:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypePaymentId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypePaymentPreimage:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypePaymentSecret:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypePublicKey:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeSocketAddress:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeTxid:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeUntrustedString:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeUserChannelId:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)
Address = str
BlockHash = str
ChannelId = str
Lsps1OrderId = str
LspsDateTime = str
Mnemonic = str
NodeAlias = str
NodeId = str
OfferId = str
PaymentHash = str
PaymentId = str
PaymentPreimage = str
PaymentSecret = str
PublicKey = str
SocketAddress = str
Txid = str
UntrustedString = str
UserChannelId = str

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

def battery_saving_sync_intervals() -> "RuntimeSyncIntervals":
    return _UniffiConverterTypeRuntimeSyncIntervals.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_func_battery_saving_sync_intervals,))


def default_config() -> "Config":
    return _UniffiConverterTypeConfig.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_func_default_config,))


def derive_node_secret_from_mnemonic(mnemonic: "str",passphrase: "typing.Optional[str]") -> "typing.List[int]":
    _UniffiConverterString.check_lower(mnemonic)
    
    _UniffiConverterOptionalString.check_lower(passphrase)
    
    return _UniffiConverterSequenceUInt8.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeNodeError,_UniffiLib.uniffi_ldk_node_fn_func_derive_node_secret_from_mnemonic,
        _UniffiConverterString.lower(mnemonic),
        _UniffiConverterOptionalString.lower(passphrase)))


def generate_entropy_mnemonic(word_count: "typing.Optional[WordCount]") -> "Mnemonic":
    _UniffiConverterOptionalTypeWordCount.check_lower(word_count)
    
    return _UniffiConverterTypeMnemonic.lift(_uniffi_rust_call(_UniffiLib.uniffi_ldk_node_fn_func_generate_entropy_mnemonic,
        _UniffiConverterOptionalTypeWordCount.lower(word_count)))


__all__ = [
    "InternalError",
    "AsyncPaymentsRole",
    "BalanceSource",
    "Bolt11InvoiceDescription",
    "BuildError",
    "ClosureReason",
    "CoinSelectionAlgorithm",
    "ConfirmationStatus",
    "Currency",
    "Event",
    "LightningBalance",
    "LogLevel",
    "Lsps1PaymentState",
    "MaxDustHtlcExposure",
    "Network",
    "NodeError",
    "OfferAmount",
    "PaymentDirection",
    "PaymentFailureReason",
    "PaymentKind",
    "PaymentStatus",
    "PendingSweepBalance",
    "QrPaymentResult",
    "SyncType",
    "VssHeaderProviderError",
    "WordCount",
    "AnchorChannelsConfig",
    "BackgroundSyncConfig",
    "BalanceDetails",
    "BestBlock",
    "ChannelConfig",
    "ChannelDataMigration",
    "ChannelDetails",
    "ChannelInfo",
    "ChannelUpdateInfo",
    "Config",
    "CustomTlvRecord",
    "ElectrumSyncConfig",
    "EsploraSyncConfig",
    "LogRecord",
    "LspFeeLimits",
    "Lsps1Bolt11PaymentInfo",
    "Lsps1ChannelInfo",
    "Lsps1OnchainPaymentInfo",
    "Lsps1OrderParams",
    "Lsps1OrderStatus",
    "Lsps1PaymentInfo",
    "Lsps2ServiceConfig",
    "NodeAnnouncementInfo",
    "NodeInfo",
    "NodeStatus",
    "OutPoint",
    "PaymentDetails",
    "PeerDetails",
    "RouteHintHop",
    "RouteParametersConfig",
    "RoutingFees",
    "RuntimeSyncIntervals",
    "SpendableUtxo",
    "TransactionDetails",
    "TxInput",
    "TxOutput",
    "battery_saving_sync_intervals",
    "default_config",
    "derive_node_secret_from_mnemonic",
    "generate_entropy_mnemonic",
    "Bolt11Invoice",
    "Bolt11Payment",
    "Bolt12Invoice",
    "Bolt12Payment",
    "Builder",
    "FeeRate",
    "Lsps1Liquidity",
    "LogWriter",
    "NetworkGraph",
    "Node",
    "Offer",
    "OnchainPayment",
    "Refund",
    "SpontaneousPayment",
    "UnifiedQrPayment",
    "VssHeaderProvider",
]

